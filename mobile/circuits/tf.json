{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":6005523602893578662,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}]},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"65":{"source":"mod common;\nmod action;\nuse action::Action;\nuse action::{ new_action, parse_actions, serialize_actions };\nuse action::{ ACTION_ACTION, ACTION_ACTOR, ACTION_TARGET_X, ACTION_TARGET_Y };\nuse action::execute_action;\nuse action::can_move_to;\nmod character;\nuse character::Character;\nuse character::parse_characters;\nmod event;\nuse event::Event;\nmod obstacle;\nuse obstacle::Obstacle;\nmod map;\nuse dep::std;\n\n// #[export]\n// pub fn ext_can_move_to(x: u8, y: u8, obstacles: [Obstacle; MAX_OBSTACLES], their_obstacles: [Obstacle]) -> bool {\n//     assert(MAX_OBSTACLES == 24);\n//     let mut my_obstacles_parsed = Obstacle::parse_my_obstacles(my_obstacles, events).as_array();\n//     // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n//     // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n//     let enemy_objects_parsed = Obstacle::parse_their_obstacles(enemy_objects);\n\n//     let mut can = true;\n//     for i in 0..MAX_OBSTACLES {\n//         if !obstacles[i].is_traversible() & (obstacles[i].x == x) & (obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     for i in 0..their_obstacles.len() {\n//         if !their_obstacles[i].is_traversible() & (their_obstacles[i].x == x) & (their_obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     can\n// }\n// MAP\nglobal WIDTH_BITS: u8 = 5;\nglobal WIDTH_MASK: u8 = (1 << WIDTH_BITS) - 1;\nglobal WIDTH: u8 = 1 << WIDTH_BITS;\nglobal HEIGHT_BITS: u8 = 4;\nglobal HEIGHT_MASK: u8 = (1 << HEIGHT_BITS) - 1;\nglobal HEIGHT: u8 = 10;\nglobal NOWHERE: u8 = 255;\n\n// CLASSES\nglobal UNKNOWN_CLASS: u8 = 0;\nglobal ARCHER: u8 = 1;\nglobal RITUALIST: u8 = 2;\nglobal ROGUE: u8 = 3;\nglobal KNIGHT: u8 = 4;\nglobal MAGE: u8 = 5;\nglobal CLASS_BITS: u8 = 3;\nglobal CLASS_MASK: u8 = (1 << CLASS_BITS) - 1;\nglobal CLASS_COUNT: u8 = 6;\n\n// ACTIONS\nglobal WAIT: u8 = 0;\nglobal SNEAK: u8 = 1;\nglobal MOVE: u8 = 2;          // => SEE_COLUMN (depr: MOVE)\nglobal RITUAL: u8 = 3;        // => SEE_RITUAL | WIN\nglobal SEARCH: u8 = 4;        // => SEE_SEARCH_TRAP\nglobal ATTACK: u8 = 5;        // => RECEIVE_ATTACK | DESTROY // affects my obstacles; TODO: with more attack types might also affect other own characters\nglobal SET_TRAP: u8 = 6;\nglobal CAST_FIREBALL: u8 = 7; // => SEE_CAST | SEE_SPELL | DESTROY // affects other characters if status == FIREBALL_ROUNDS_FOR_CAST\nglobal DRAW: u8 = 8;          // => SEE_DRAW\nglobal SHOOT: u8 = 9;         // => RECEIVE_ATTACK\n//global TRIGGER_TRAP = 9;  // => TRIGGERED_TRAP ?????????\nglobal DISARM_TRAP: u8 = 10;  // => DESTROY\nglobal ACTION_COUNT: u8 = 11;\n\n// EVENTS\nglobal NO_EVENT: u8 = 0 ;\nglobal DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n//global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n//global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\nglobal SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n//global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\nglobal SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\nglobal SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\nglobal SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\nglobal SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n//global RECEIVE_DAMAGE = 9;   // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\nglobal RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\nglobal TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\nglobal FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\nglobal WIN: u8 = 13;\nglobal LOSE: u8 = 14;\nglobal EVENT_COUNT: u8 = 15;\n\n// ATTACKS\nglobal ATTACK_MELEE: u8 = 0;\nglobal ATTACK_RANGED: u8 = 1;\nglobal ATTACK_FIREBALL: u8 = 2;\nglobal ATTACK_COUNT: u8 = 3;\n// TODO: instead of enum, use a global array of structs with damage, range, etc.\n\n\n// TILES\nglobal EMPTY: u8 = 0;\nglobal WALL: u8 = 6;\nglobal WATER: u8 = 7;\nglobal UNKNOWN_CLASS_TILE: u8 = 8;\nglobal NON_EMPTY_WALKABLE_TILE_MIN: u8 = 9;\nglobal FLAG: u8 = 9;\nglobal TRAP: u8 = 10;\nglobal TRAP_USED: u8 = 11;\nglobal TRAP_FOUND: u8 = 12;\nglobal BODY: u8 = 13;\nglobal BODY_LOOTED: u8 = 14;\nglobal FOG: u8 = 15;\nglobal TILE_COUNT: u8 = 16;\n\n// STATUS\n#[export]\nglobal RITUAL_ROUNDS_FOR_WIN: u8 = 16;\nglobal FIREBALL_ROUNDS_FOR_CAST: u8 = 3;\nglobal DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\nglobal MIN_DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\nglobal MAX_DRAW_ROUNDS_FOR_SHOOT: u8 = 3;\nglobal STATUS_BITS: u8 = 4;\nglobal STATUS_MASK: u8 = (1 << STATUS_BITS) - 1;\nglobal STATUS_COUNT: u8 = 16 ; // just to be more in line with the other constants, actually used as a counter\n\n// GAMEPLAY\nglobal VIEW_DISTANCE: u8 = 6;\nglobal MAX_TRAPS: Field = 15; // note: only lowest bit of first byte of field is usable! => ! Field = 1 bit + 31 bytes!\nglobal TRAPS_BUFFER_SIZE: Field = 16;\nglobal TRAPS_BUFFER_MASK: Field = 15; // has to be 2^n - 1\nglobal MAX_ACTIONS: u32 = 4;\nglobal MAX_EVENTS: u32 = 4; // = MAX_ACTIONS // NO! handle traps in a different way (by passing as argument!)+ 4 (2 FOUND_TRAP + WIN/LOSE + 1 reserved)\nglobal MAX_OBSTACLES: u32 = 24;\nglobal MAX_CHARACTERS: u32 = 5;\nglobal SERIALIZED_OBSTACLE_BYTE_SIZE: u32 = 3;\npub global SERIALIZED_OBSTACLES_ARRAY_SIZE: u32 = 3; // TODO: we take 3 because 3 x 8 = MAX_OBSTACLES ... should assert on this (MAX_OBSTACLES + MAX_CHARACTERS + 7) / 8;\npub global SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE: u32 = SERIALIZED_OBSTACLES_ARRAY_SIZE + 1; // +1 because enemy characters are also serialized as obstacles\nglobal SERIALIZED_OBSTACLES_PER_FIELD: u32 = 8; // TODO: need to verify that SERIALIED_OBSTACLES_ARRAY_SIZE * SERIALIZED_OBSTACLES_PER_FIELD = MAX_OBSTACLES!\nglobal SERIALIZED_EVENT_BYTE_SIZE: u32 = 7;\npub global SERIALIZED_EVENTS_ARRAY_SIZE: u32 = 1; // MAX_EVENTS / SERIALIZED_EVENTS_PER_FIELD => 4 / 4 = 1\nglobal SERIALIZED_EVENTS_PER_FIELD: u32 = 4; // 31 / 7 = 4\nglobal SERIALIZED_ACTION_BYTE_SIZE: u32 = 5;\npub global SERIALIZED_ACTIONS_ARRAY_SIZE: u32 = 1;\nglobal SERIALIZED_ACTIONS_PER_FIELD: u32 = 4; // could be up to 6, but we only use 4\nglobal UNREADABLE_BYTES_PER_FIELD: u32 = 1;\n\n#[export]\nfn tf(x: Field) -> (u32, [u8;32]) {\n    let mut result: [u8;32] = [0;32];\n    let bts = x.to_be_bytes::<32>();\n    for j in 0..31 {\n        result[j] = 2*j;//bts[j];\n    }\n    (32 , result)\n}\n// i,\n// 20, 0 -> 25,\n// 25 -> 0, \n// x, 0, 0, d0,\n// x, 0, 0, 9d, 1, 0,\n// x, 0, 0, 1, 0, b4, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 91, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 23, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, d4, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, 66, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 50, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b9, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, c5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 55, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b2, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, e8, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2a, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, cb, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 9b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 5c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, a6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 86, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, d5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 38, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8e, 1, 0, 0, 1,\n// 0, 32, 1, 0, 1, 1, x, 0, 0, 1,\n// x, 0, 0, 1, x, 0, 0, 1, 0, 1, 1\n\n// i,\n// 20, 0, 1e -> 0, 0 -> 1e, 0\n// x, 0, 0, d0,\n// x, 0, 0, ba, 1, 0,\n// x, 0, 0, 1, 0, cf, 1, 0, 1, 1,\n\n#[export]\nfn get_actor_from_move(mut move: u32) -> u8 {\n    if (move % 2) == 1 {\n        move -= 1; //((move % 10) - 1) >> 1 // actually not needed ... but clearer this way\n    }\n    let single_digit: u32 = (move % 10 as u32) >> 1;\n    single_digit as u8\n}\n// 3, 1, 1, 1, 0, 1, 2, 0, 2, 8, 1, 0, 0, 1\n// 4, 2, 2, 0, x, 0, 0, 0, 4, a, 2, 0, 0, 2\n\n#[export]\npub fn hash_match(my_chars: Field, my_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], secret_be_bytes: [u8; 32]) -> Field {\n    let my_chars_be_bytes: [u8; 32] = my_chars.to_be_bytes::<32>();\n    //assert(my_chars_be_bytes.len() == 32);\n    let gamestate_before_hash_calculated = get_data_hash(secret_be_bytes, my_chars_be_bytes, my_obstacles);\n    let gamestate_before_hash_calculated_field = std::field::bytes32_to_field(gamestate_before_hash_calculated);\n    gamestate_before_hash_calculated_field\n}\n\n#[export]\npub fn turn(\n    // My Secret State\n    secret: Field,\n    my_chars: Field,\n    my_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE],\n    actions: [Field; SERIALIZED_ACTIONS_ARRAY_SIZE],\n    // Common Inputs\n    move: pub u32,\n    // Enemy Inputs\n    enemy_advance: pub u8,\n    enemy_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    events: pub [Field; SERIALIZED_EVENTS_ARRAY_SIZE], //MAX_EVENTS],\n    // My Results\n    my_advance: pub u8, // 1 bit win, 1 bit lose, 1 bit reserved, 5 bits advance\n    my_result_events: pub [Field; SERIALIZED_EVENTS_ARRAY_SIZE],\n    my_result_objects: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // Gamestate Hashes\n    gamestate_before_hash: pub Field,\n    gamestate_after_hash: pub Field,\n) -> bool {\n    // Validate global constants (to make sure one didn't change one without updating dependet ones)\n    comptime {\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    //assert(secret_be_bytes.len() == 32);\n\n    let gamestate_before_hash_calculated_field = hash_match(my_chars, my_obstacles, secret_be_bytes);\n    assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n\n    // TODO: Validate map => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    let events: [Event; MAX_EVENTS] = Event::parse_events(events);\n    \n    let side = move as u1;\n    let mut my_chars = parse_characters(my_chars, events, enemy_advance, side);\n\n    let actor_id = get_actor_from_move(move);\n    let mut actor = my_chars[actor_id]; //Character::parse(actor_id, my_chars, events);\n    \n    let actions = parse_actions(actions); // actions.map(|action| Action::from_field(action));\n    \n    comptime {\n        assert(MAX_OBSTACLES == 24);\n    }\n\n    let mut my_obstacles_parsed = Obstacle::parse_my_obstacles(my_obstacles, events).as_array();\n    // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n    let enemy_objects_parsed = Obstacle::parse_their_obstacles(enemy_objects);\n\n    let mut energy: u8 = 12;\n    let mut result_events_calculated: [Event] = &[];\n    for i in 0..MAX_ACTIONS {\n        // TODO: ensure that if actor committed suicide, it is not allowed to do any more actions\n        let action = actions[i];\n        let result = execute_action(action, side, enemy_advance, actor, energy, my_obstacles_parsed, enemy_objects_parsed);\n        assert(result.0);\n        let result_event = result.1;\n        actor = result.2;\n        energy = result.3;\n        \n        my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n        my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| update_my_obstacle(obstacle, result_event));\n\n        result_events_calculated = result_events_calculated.push_back(result_event);\n    }\n    let result_events_calculated = Event::serialize_events(result_events_calculated);\n    assert(result_events_calculated.len() == SERIALIZED_EVENTS_ARRAY_SIZE);\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        assert(result_event_should == result_event_calculated, f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\");\n    }\n\n    // send death events => no need\n\n    // determine view range\n    let mut my_advance_calculated = 0;\n    if side == 0 {\n        for i in 0..MAX_CHARACTERS {\n            if my_chars[i].x > my_advance_calculated {\n                my_advance_calculated = my_chars[i].x;\n            }\n        }\n        my_advance_calculated += VIEW_DISTANCE;\n    } else {\n        my_advance_calculated = WIDTH - 1;\n        for i in 0..MAX_CHARACTERS {\n            if my_chars[i].x < my_advance_calculated {\n                my_advance_calculated = my_chars[i].x;\n            }\n        }\n        my_advance_calculated -= VIEW_DISTANCE;\n    }\n    assert(my_advance == my_advance_calculated, f\"{my_advance} != {my_advance_calculated}\");\n\n    // validate result\n    let serialized_characters = serialize_chars(my_chars);\n    let serialized_obstacles: [Field] = Obstacle::serialize_obstacles(side, enemy_advance, my_obstacles_parsed);\n    assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    // println(secret);\n    // println(serialized_characters);\n    // println(serialized_obstacles);\n    let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes();\n    assert(serialized_characters_be_bytes.len() == 32);\n    let new_hash_bytes = get_data_hash(secret_be_bytes, serialized_characters_be_bytes, serialized_obstacles.as_array());\n    let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    let serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] = serialized_obstacles.push_back(serialize_chars_as_obstacles(my_chars)).as_array();\n    for i in 0..my_result_objects.len() {\n        let my_result_object = my_result_objects[i];\n        let serialized_obstacle = serialized_obstacles[i];\n        assert(my_result_object == serialized_obstacle, f\"{i}: {my_result_object} != {serialized_obstacle}\");\n    }\n    assert(new_hash == gamestate_after_hash, f\"{new_hash} != {gamestate_after_hash}\");\n    true\n}\n\nfn wb_apply_damage_to_char(mut c: Character, event: Event, actor: Character) -> Character {\n    if c.id == actor.id {\n        c = actor;\n    }\n    apply_damage_to_char(c, event)\n}\n\nfn apply_damage_to_char(c: Character, event: Event) -> Character {\n    let dmg = event.get_applied_damage_to_my_asset(c.x, c.y, c.class);\n    Character {\n        id: c.id,\n        x: c.x,\n        y: c.y,\n        class: c.class,\n        health: safe_subtract_dmg(c.health, dmg),\n        status: c.status,\n        target_x: c.target_x,\n        target_y: c.target_y,\n        has_been_seen: c.has_been_seen,\n        is_hidden: c.is_hidden,\n        damage_mod: c.damage_mod,\n    }\n}\nfn update_my_obstacle(obstacle: Obstacle, event: Event) -> Obstacle {\n    let dmg = event.get_applied_damage_to_my_asset(obstacle.x, obstacle.y, obstacle.obstacle_type);\n    Obstacle {\n        health: safe_subtract_dmg(obstacle.health, dmg),\n        id: obstacle.id,\n        x: obstacle.x,\n        y: obstacle.y,\n        obstacle_type: obstacle.obstacle_type,\n    }\n}\n\nfn get_data_hash(secret: [u8], characters: [u8], obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> [u8; 32] {\n    assert(secret.len() == 32);\n    assert(characters.len() == 32);\n\n    let mut data: [u8; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32] = [0; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32];\n    for i in 0..32 {\n        data[i] = secret[i];\n        data[i + 32] = characters[i];\n    }\n    let offset = 32 + 32;\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let obstacle: [u8; 32] = obstacles[i].to_be_bytes();\n        assert(obstacle.len() == 32);\n        for j in 0..32 {\n            data[offset + i * 32 + j] = obstacle[j];\n        }\n    }\n    // let offset = WIDTH * HEIGHT + 32 * 3;\n    // for i in 0..10 {\n    //     data[offset + i * 4] = (searched_traps[i] & 255) as u8;\n    //     data[offset + i * 4 + 1] = ((searched_traps[i] >> 8) & 255) as u8;\n    //     data[offset + i * 4 + 2] = ((searched_traps[i] >> 16) & 255) as u8;\n    //     data[offset + i * 4 + 3] = ((searched_traps[i] >> 24) & 255) as u8;\n    // }\n    std::hash::blake3(data)\n}\n\nfn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> Field {\n    assert(MAX_CHARACTERS <= 5);\n    let mut result: [u8; 32] = [0; 32];\n    for i in 0..MAX_CHARACTERS {\n        let serialized = chars[i].serialize();\n        for j in 0..6 {\n            result[2 + i * 6 + j] = serialized[j];\n        }\n    }\n    std::field::bytes32_to_field(result)\n}\n\nfn serialize_chars_as_obstacles(chars: [Character; MAX_CHARACTERS]) -> Field {\n    let mut result: [u8; 32] = [0; 32];\n    for i in 0..MAX_CHARACTERS {\n        let char_as_obstacle = chars[i].to_obstacle();\n        let serialized = char_as_obstacle.serialize();\n        result[2 + i * 3] = serialized[0];\n        result[2 + i * 3 + 1] = serialized[1];\n        result[2 + i * 3 + 2] = serialized[2];\n    }\n    std::field::bytes32_to_field(result)\n}\n\nfn safe_subtract_dmg(a: u8, b: u16) -> u8 {\n    let mut result = 0;\n    if (a as u16) > b {\n        result = a - (b as u8);\n    }\n    result\n}\n\nfn test_result_object_builder(chars: [Character; MAX_CHARACTERS], obs: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] {\n    let mut result: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        result[i] = obs[i];\n    }\n    result[SERIALIZED_OBSTACLES_ARRAY_SIZE] = serialize_chars_as_obstacles(chars);\n    result\n}\n\nfn test_helper_roster(actor: Character, mut chars: [Character; MAX_CHARACTERS]) -> [Character; MAX_CHARACTERS] {\n    chars[actor.id] = actor;\n    chars\n}\n\nfn test_helper_execute_move(move: u32, actor: Character, advances: [u8; 2], secret: [Field; 2], last_hashes: [Field; 2], chars: [[Character; MAX_CHARACTERS]; 2], obs: [[Obstacle; MAX_OBSTACLES]; 2], actions: [Action], my_events: [Event], their_events: [Event]) -> (u32, [Character; MAX_CHARACTERS], Field) {\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = test_helper_roster(actor, chars[side]);\n    let my_obstacles_serialized = Obstacle::serialize_obstacles(side, advances[other_side], obs[side]);\n    let secret_be_bytes: [u8; 32] = secret[side].to_be_bytes();\n    assert(secret_be_bytes.len() == 32);\n    let serialized_chars_after = serialize_chars(chars_after);\n    let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes();\n    assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, my_obstacles_serialized)); \n\n    turn(\n        secret[side],\n        character::serialize_chars(chars[side]),\n        my_obstacles_serialized,\n        serialize_actions(actions),\n        move,\n        advances[other_side],\n        test_result_object_builder(chars[other_side], Obstacle::serialize_obstacles(other_side, advances[side], obs[other_side])),\n        Event::serialize_events(their_events).as_array(),\n        advances[side],\n        Event::serialize_events(my_events).as_array(),\n        test_result_object_builder(chars_after, my_obstacles_serialized),\n        last_hashes[side],\n        current_hash\n    );\n\n    (move + 1, chars_after, current_hash)\n}\n\n// #[test]\n// fn test_main() {\n//     let secrets = [123456789, 9876543210];\n//     let mut chars = [ character::get_default_characters(0), character::get_default_characters(1) ];\n//     let mut obs = [ Obstacle::get_default_obstacles(0), Obstacle::get_default_obstacles(1) ];\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 2, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 3, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 4, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 5, target_y: 1 },\n//     ];\n//     let their_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let mut move = 0;\n//     let mut actor = chars[0][0].move(5, 1);\n//     let mut last_hashes = [ 0x12b8f97907a05ec6a77da3f70368fa3b02e166c74edab8ea0695d6f406146559, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n//     let mut advances = [2 + VIEW_DISTANCE, 29 - VIEW_DISTANCE];\n//     advances[0] = 5 + VIEW_DISTANCE;\n\n//     let mut side = move % 2;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 0 },\n//         Action { action: MOVE, actor: 0, target_x: 27, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(27, 0);\n//     advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 1, target_y: 3 },\n//         Action { action: MOVE, actor: 1, target_x: 0, target_y: 3 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(0, 3);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 2 },\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 1, target_x: 28, target_y: 1 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(28, 1);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n// }\n\n#[test]\nfn test_main_fireball_ff() {\n    let secrets = [123456789, 9876543210];\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, status: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0 },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, status: 2, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10 },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, status: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0 },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0 },\n        ]\n    ];\n    let mut obs = [ Obstacle::get_default_obstacles(0), Obstacle::get_default_obstacles(1) ];\n    let actions = &[\n        new_action(CAST_FIREBALL, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(MOVE, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event] = &[\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 11, y: 3, subtype: ATTACK_RANGED, value: 50 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 0, y: 0, subtype: 0, value: 0 },\n    ];\n    let my_events: [Event] = &[\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 110 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 0, y: 0, subtype: 0, value: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 0, y: 0, subtype: 0, value: 0 },\n    ];\n    let mut move = 8;\n    let mut actor = chars[0][4].move(9, 7).set_status(0);\n    let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 11 - VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 55), chars[side][2].take_damage(ATTACK_FIREBALL, 55), chars[side][3].take_damage(ATTACK_FIREBALL, 55), actor ];\n    let my_obstacles_serialized = Obstacle::serialize_obstacles(side, advances[other_side], obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes();\n    assert(secret_be_bytes.len() == 32);\n    let serialized_chars_after = serialize_chars(chars_after);\n    let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes();\n    assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, my_obstacles_serialized)); \n\n    println(secrets[side]);\n    println(character::serialize_chars(chars[side]));\n    println(my_obstacles_serialized);\n    println(serialize_actions(actions));\n    println(move);\n    println(advances[other_side]);\n    println(test_result_object_builder(chars[other_side], Obstacle::serialize_obstacles(other_side, advances[side], obs[other_side])));\n    println(Event::serialize_events(their_events));\n    println(advances[side]);\n    println(Event::serialize_events(my_events));\n    println(test_result_object_builder(chars_after, my_obstacles_serialized));\n    println(last_hashes[side]);\n    println(f\"Current hash: {current_hash}\");\n    turn(\n        secrets[side],\n        character::serialize_chars(chars[side]),\n        my_obstacles_serialized,\n        serialize_actions(actions),\n        move,\n        advances[other_side],\n        test_result_object_builder(chars[other_side], Obstacle::serialize_obstacles(other_side, advances[side], obs[other_side])),\n        Event::serialize_events(their_events).as_array(),\n        advances[side],\n        Event::serialize_events(my_events).as_array(),\n        test_result_object_builder(chars_after, my_obstacles_serialized),\n        last_hashes[side],\n        current_hash\n    );\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta/noir-react-native-starter-main/circuits/skpl/src/lib.nr"}},"names":["tf"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}