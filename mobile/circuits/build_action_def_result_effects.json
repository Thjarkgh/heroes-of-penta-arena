{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9835106134927867723,"abi":{"parameters":[{"name":"action_result_required_energy","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_result_progress_increment","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_result_progress_multiplier","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_result_move_to_target","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_result_hide","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_result_reveal","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"actionResultEffect::ActionResultEffect","fields":[{"name":"register","type":{"kind":"array","length":2,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"H4sIAAAAAAAA/9WYS27CMBCGnQeQBxBeUYWqqqrUA9h5gLNrFz0IiLDvLXqA3qE9SRftopfoQYqprVrGZMNMBCNFE8bx4PnmjxPFIX+W7o57ee7sDk96YYERcywx1xLzLDHfEuvImC//zyWHptbyID09zRhgLmpZLlBuRnUWgfSh2SQFT4+F5B+oMg8RYk4XRVEvs5rlbEWzas1LWpTrBWeclbzcZDzPa17wZbWulrRiRV6zbVnl9XZvLADItZULC+FqpG2K0iGXJ8pI+lgBUQIUA6YoY4IvSofAiTIicKKMCU5zXeDmxoA19wFr1nUk8gbIOgLcRFgfkOkAiemAtP8UdsklbHi00FkMpU8UEAVQDHSNWGIBCS1UHeKJG95mSOCEmpBL2PBo4QHWPCI4N6fIi73hAfaLjQCZjpGYji1MgbXFfUAOEyQOkxa0BdhDNgFkOkViOkXXFqMdQA4zJA6zFrQF2EM2A2SaIjFN0bVFWReQA+QLK2bNvTPtvcjR1epWn9uEHsTzpWNhIq7vGTpJpP96/f54f1lttKH9s1BY+vM4f/58e9LHrhrmzRvmXTfMu2mYd9sw7+7IPP1TpbBQ+kgb19/z6GmWqfwxTn7aI4cWaeexMab67lvmOUd+u4ZvutaM67GBZUzlnEqvr1fV8Quyn08eexYAAA==","debug_symbols":"ndTdqoQgEADgd/G6C3+zepXDYbGyRRALqwOH2HdfN7Z2EZfFuXMcPhnHwQ31ul2vF+OGcUbNz4bs2KnFjC5EGyr3rXlS7hHNi/ILaoiQvEDa9WFZYnYr0GCsRk3Jb78Fkvmkyid1PiE4ZSiW4mkowTI2BGAowDCA4UnDJT2MwPXLkN0IgCk/GPIyMjYSYJJjQKk4a6OViHtQ5xuKAYYATHoOOGOH4eHikWEAw7/1Ojxv1GsqACY9B0Li802rKq5NAkwFqK3ONyw9B2V99lqS+A9hBGAooDaWa0LQemOtuV7ef/Cw/ae8Ua3Vz3BYXfeWXf6nI3P4yY+d7levHyftuXD8HQ==","file_map":{"61":{"source":"use dep::std::{append::Append};\nuse skplg::UNREADABLE_BYTES_PER_FIELD;\n\npub trait ActionDefinitionPartBuilder<T> { fn new() -> T; }\npub type DEF_ROW<T> = (Quoted, u8, T);\npub comptime fn get_def_register_value(register: Quoted, bytes: u32, bits: u8, bitsize: u8) -> Quoted {\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    if bitsize == 8 {\n      quote { $register[$bytes] }\n      // quote { ($register / $multiplier) as u8 }\n    } else {\n      let divisor = 1 << bits;\n      let mask = std::wrapping_sub(1 << bitsize, 1);\n      if bitsize == 1 {\n        // quote { (($register / $multiplier) as u1) == 1 }\n        quote { (($register[$bytes] as u8 & $divisor as u8) != 0 as u8) }\n      } else {\n        quote { (($register[$bytes] as u8 / $divisor as u8) & $mask as u8) }\n        // quote { (($register / $multiplier) as u8) & $mask as u8 }\n      }\n    }\n}\npub comptime fn build_over_def_array<Env, T>(array: [DEF_ROW<T>], base_index: u32, builder: fn[Env] (u32, u8, Quoted, u8, T) -> Quoted) -> Quoted {\n  let mut result = quote {};\n  \n  let mut bits: u8 = 0;\n  let mut bytes: u32 = base_index;\n\n  for i in 0..array.len() {\n    let (varname, bitsize, args) = array[i];\n    assert(bitsize <= 8, f\"Invalid bit size: {bitsize}\");\n    if (bits + bitsize) > 8 {\n      bytes += 1;\n      bits = 0;\n    }\n    assert(bits < 8, f\"bits must not reach 8 or higher: {bits}\");\n\n    let new_result = builder(bytes, bits, varname, bitsize, args);\n    result = quote { $result $new_result };\n\n    bits += bitsize;\n  }\n  result\n}\npub comptime fn derive_action_def_def_builder<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let mut params: [(Quoted, Type)] = &[];\n  let mut last_byte: u32 = 0;\n  let mut result: Quoted = build_over_def_array(array, 0, |bytes, bits, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { u8 }.as_type() } else { quote { u8 }.as_type() };\n    params = params.push_back((varname, t));\n    let mut r = quote {};\n    if bytes != last_byte {\n      r = r.append(quote { , });\n    } else if (bytes + bits as u32) != 0 {\n      r = r.append(quote { + });\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = r.append(quote { $varname  });\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = r.append(quote { $varname as u8 * $multiplier });\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = r.append(quote { (( $varname & $mask ) * $multiplier) });\n      }\n    }\n    last_byte = bytes;\n    r\n  });\n  f.set_parameters(params);\n\n  let return_type = f.return_type();\n\n  f.set_body(quote { $return_type { register: [ $result ] } }.as_expr().unwrap());\n  // println(f.body());\n}\npub comptime fn get_action_def_def_register_size<T>(array: [DEF_ROW<T>]) -> u32 {\n  let mut size = 0;\n  let _ = build_over_def_array(array, 0, |bytes, _, _, _, _|{\n    size = bytes;\n    quote {}\n  });\n  size + 1\n}\npub comptime fn get_action_def_def_register_element_type() -> Type {\n  quote { u8 }.as_type()\n}\npub comptime fn get_action_def_def_register_type<T>(array: [DEF_ROW<T>]) -> Type {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  quote { [$et; $size] }.as_type()\n}\npub comptime fn derive_action_def_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  // let size = get_action_def_requirements_register_size();\n  let fields = s.fields([]);\n  assert(fields.len() == 1);\n  s.set_fields([(fields[0].0, get_action_def_def_register_type(array))]);\n}\npub comptime fn derive_action_def_def_struct_new<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  let t = get_action_def_def_register_type(array);\n  f.set_return_type(t);\n  f.set_body(quote { ActionRequirement { [0 as $et; $size] } }.as_expr().unwrap());\n}\npub comptime fn derive_frontend_action_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  let mut fields: [(Quoted, Type)] = &[];\n  let _ = build_over_def_array(array, UNREADABLE_BYTES_PER_FIELD, |_, _, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    fields = fields.push_back((varname, t));\n    quote {}\n  });\n  s.set_fields(fields);\n}\npub comptime fn derive_frontend_action_def_struct_builder<T>(param_name: Quoted, base_index: u32, array: [DEF_ROW<T>]) -> Quoted {\n  // let mut params: [(Quoted, Type)] = &[];\n  let mut first = true;\n  let mut result: Quoted = build_over_def_array(array, base_index, |bytes, bits, varname, bitsize, _|{\n    // let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    // params = params.push_back((varname, t));\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    let mut r = quote {};\n    if !first {\n      r = quote { , };\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = quote { $r $varname: $param_name[$bytes] };\n      // r = quote { $r $varname: ($param_name / $multiplier) as u8 };\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = quote { $r $varname: ($param_name[$bytes] & $multiplier) != 0 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u1) == 1 };\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = quote { $r $varname: (( $param_name[$bytes] / $multiplier) & $mask ) as u8 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u8) & $mask as u8 };\n      }\n    }\n    first = false;\n    r\n  });\n  // f.set_parameters(params);\n\n  // let return_type = f.return_type();\n  // // f.set_return_type(return_type.as_type());\n  // f.set_return_data();\n  // f.set_return_public(true);\n  // // println(result);\n  // f.\nresult\n  // quote {  $result } };\n}\n\n// pub global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2; // u2\n\n// global YES: u8 = 1;\n// global NO: u8 = 0;\n// global MIN_STATUS: u8 = 0;\n// global MAX_STATUS: u8 = 15;\n\n// // pub type ActionDefinitionRegister = \n// pub fn build_action_def_requirements_none() -> ActionRequirement {\n//   build_action_def_requirements(\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     MIN_STATUS,\n//     MAX_STATUS,\n//     0 as u8,\n//     255 as u8)\n// }\n// pub fn build_action_def_pre_calc_effects_idle() -> ActionPreCalcEffect {\n//   build_action_def_pre_calc_effect(\n//     WAIT,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1)\n// }\n// // comptime fn no_requirements() -> CtString {\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1, \n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         0 as u8,\n// //         NO as u1)\n// // }\n// pub fn build_action_def_result_event_none() -> ActionResultEvent {\n//   build_action_def_result_event(\n//     0,\n//     0,\n//     ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//     NO_EVENT,\n//     NO_EVENT,\n//     0 as u8\n//   )\n// }\n// // comptime fn no_event() -> CtString {\n// //     build_action_event_def(NO_EVENT, NO_EVENT, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 0 as u8)\n// // }\n// pub fn build_wait_action_def() -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements_none(),\n//     build_action_def_pre_calc_effects_idle(),\n//     build_action_def_result_effects(\n//       0 as u8,\n//       0 as u8,\n//       1 as u8,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_wait_action_def() -> CtString {\n// //     build_action_def(\n// //         no_requirements(),\n// //         no_event(),\n// //         no_event(),\n// //         1 as u8,\n// //         0 as u8,\n// //         ACTION_RESULT_COORDINATES_IDX_SELF,\n// //         NO as u1,\n// //         WAIT\n// //     )\n// // }\n// // pub global WAIT_ACTION: ActionDefinition = comptime { let x = build_wait_action_def(); f\"[{x}]\".quoted_contents() };\n// pub fn build_sneak_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0 as u8,\n//       1 as u8),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0 as u8,\n//       0 as u8,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       YES as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_sneak_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     no_event(), // TODO: not sure if on-seen we should not send a move event instead - that way one could sneak and stay hidden, but not sneak while visible\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_move_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       1),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_MOVE,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_move_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_MOVE, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_cast_action(this_action_id: u8, energy: u8, class: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_CAST,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_cast_action(this_action_id: u8, energy: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_CAST, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_ritual_action(cast_action_id: u8, energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       RITUAL_ROUNDS_FOR_WIN,\n//       MAX_STATUS,\n//       0,\n//       255),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_ritual_action(this_action_id: u8, energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         RITUAL_ROUNDS_FOR_WIN,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 255 as u8),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 255 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1), // TODO: Maybe set this to handle friendly fire???\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     cast_action_id)\n// // }\n// pub fn build_search_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_search_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS, // should be max of shoot\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_DRAW,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_DRAW, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       draw_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     draw_action_id)\n// // }\n// pub fn build_disarm_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_disarm_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_set_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         ADD_OBSTACLE,\n//         TRAP,\n//         0),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_set_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         YES as u1),\n// //     no_event(),\n// //     build_action_event_def(ADD_OBSTACLE, TRAP, 0 as u8, 50 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n\n// // pub fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // fn get_action_needs_target_free_space(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// // }\n// // fn get_action_needs_target_is_not_self(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// // }\n// // fn get_action_needs_status_visible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// // }\n// // fn get_action_needs_status_invisible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// // }\n// // fn get_action_needs_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_sets_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_removes_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_max_range(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_MAX_RANGE]\n// // }\n// // fn get_action_needs_min_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MIN_STATUS]\n// // }\n// // fn get_action_needs_max_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MAX_STATUS]\n// // }\n// // fn get_action_needed_energy(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDED_ENERGY]\n// // }\n// // fn get_action_unseen_event_is_internal(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_EVENT_IS_TRAP] == 1\n// // }\n// // fn get_action_result_event_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_event_not_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_not_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_not_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_not_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_not_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_not_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_status_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// // }\n// // fn get_action_move_to_target(action: ActionDefinition) -> u1 {\n// //     action.register[action.base_index + ACTION_MOVE_TO_TARGET] as u1\n// // }\n// // fn get_action_is_continuous(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_IS_CONTINUOUS] == 1\n// // }\n// // fn get_action_needs_previous_action(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_PREVIOUS_ACTION] as u8\n// // }\n\n// // pub global ACTION_DEFINITION_SIZE: u32 = (ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 5) as u32; // 2 bytes for move_to_target and status_multiplier\n// // pub global ACTION_DEFINITION_REGISTER_SIZE: u32 = ACTION_DEFINITION_SIZE * (1 + (MAX_ACTIONS_PER_CHARACTER - 1) * (CLASS_COUNT - 1));\n\n// // fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // pub struct ActionDefinitionRegister {\n// //   register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinitionRegister {\n// //   pub fn new(register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinitionRegister {\n// //     ActionDefinitionRegister {\n// //       register: register\n// //     }\n// //   }\n\n// //   pub fn resolve_action(self, action: Action) -> ActionDefinition {\n// //     ActionDefinition {\n// //       base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //       action: action,\n// //       register: self.register\n// //     }\n// //   }\n// // }\n\n// // pub struct ActionDefinition {\n// //     base_index: u16,\n// //     action: Action,\n// //     register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinition {\n// //     pub fn new(action: Action, register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinition {\n// //         ActionDefinition {\n// //             base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //             action: action,\n// //             register: register\n// //         }\n// //     }\n// // }\n\n// // impl ResolvedAction for ActionDefinition {\n// //     fn get_action_needs_target_free_space(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: ActionDefinition) -> u1 {\n// //         self.register[self.base_index + ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n\n// // pub struct TestActionDefinition {\n// //     pub register: [u8; ACTION_DEFINITION_SIZE],\n// //     pub action: Action,\n// // }\n\n// // impl ResolvedAction for TestActionDefinition {\n// //     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n// //         self.register[ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n// // #[test]\n// // fn test_execute_action() {\n// //     let action = build_test_action_def!(build_move_action(4), quote { 1, 2, 3, 4 }); //new_action(1, 2, 3, 4);\n// //     let my_advance = 10;\n// //     let their_advance = 1;\n// //     let actor = Character {\n// //         id: 2,\n// //         x: 2,\n// //         y: 4,\n// //         target_x: 0,\n// //         target_y: 0,\n// //         health: 255,\n// //         damage_mod: 1,\n// //         last_action: WAIT,\n// //         class: MAGE,\n// //         is_hidden: 0 as u1,\n// //         has_been_seen: true,\n// //         status: 0,\n// //         actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]\n// //     };\n// //     let energy = 15;\n// //     let my_obstacles = get_default_obstacles(0);\n// //     let their_obstacles = get_default_obstacles(1);\n// //     let (valid, event, internal_event, c, result_energy) = execute_action(\n// //         action,\n// //         my_advance,\n// //         their_advance,\n// //         actor,\n// //         energy,\n// //         my_obstacles,\n// //         their_obstacles\n// //     );\n// //     assert(valid, \"valid\");\n// //     assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n// //     assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n// //     assert(event.x == action.get_action_target_x(), f\"{event}.target_x is not action target x\");\n// //     assert(event.y == action.get_action_target_y(), f\"{event}.target_y is not action target y\");\n// //     assert(c.x == event.x, f\"{c}.x is not action target x\");\n// //     assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n// //     assert(result_energy == 11, f\"{result_energy} != 11\");\n// // }\n\n// // #[export]\n// // pub fn build_action_register(actions: [])\n\npub type CharacterActionDefinition = [u8; 32];\npub type CharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [CharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedCharacterActionDefinition = Field;\npub type SerializedCharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedRosterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32, let MAX_CHARACTERS: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS];","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionDefinition.nr"},"64":{"source":"// pub type ActionResultEffects = (bool, bool, bool, bool);\n// pub comptime fn to_action_result_effect(set_hidden: bool, remove_hidden: bool, move_to_target: bool, continuous: bool) -> Quoted {\n//     quote { ($set_hidden, $remove_hidden, $move_to_target, $continuous ) }\n// }\n\n// pub comptime fn get_sets_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_removes_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_move_to_target_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_is_continuous_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse skplg::softassert;\nuse crate::actionPreCalcEffect::{get_action_def_pre_calc_base_index, get_action_def_pre_calc_effects_byte_size};\nuse std::append::Append;\n\npub type ActionDefDefPreCalcEffect = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefPreCalcEffect> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_RESULT_EFFECTS: [DEF_ROW<ActionDefDefPreCalcEffect>] = [\n    action_def_def(quote { action_result_required_energy }, 4, |action_required_energy|{\n      let check = softassert(quote { is_valid }, quote { action_required_energy <= result_energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_required_energy}\" });\n      quote {\n        let action_required_energy = $action_required_energy;\n        $check\n        result_energy = std::wrapping_sub(result_energy, action_required_energy);\n      }\n    }),\n    action_def_def(quote { action_result_progress_increment }, 4, |progress_increment|quote { let action_result_effect_progress_increment: u32 = $progress_increment as u32; }),\n    action_def_def(quote { action_result_progress_multiplier }, 2, |progress_multiplier|quote { let action_result_effect_progress_multiplier: u32 = $progress_multiplier as u32; }),\n    action_def_def(quote { action_result_move_to_target }, 1, |move_to_target|quote { result_coords = coords[$move_to_target as u8]; }),\n    action_def_def(quote { action_result_hide }, 1, |hide|quote { let action_result_effect_hide: bool = $hide as bool; }),\n    action_def_def(quote { action_result_reveal }, 1, |leave_shadows|quote { let action_result_effect_leave_shadows: bool = $leave_shadows as bool; })\n];\npub comptime fn get_action_def_result_effect_base_index() -> u32 {\n  get_action_def_pre_calc_base_index() + get_action_def_pre_calc_effects_byte_size()\n}\n\npub comptime fn get_action_def_result_effects_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_RESULT_EFFECTS)\n}\n\ncomptime fn derive_action_def_def_result_effect_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n// }\n#[derive_action_def_def_result_effect_struct]\npub struct ActionResultEffect {\n  pub register: [u8; 32]\n}\nimpl ActionResultEffect {\n  //#[derive_action_def_result_effects_struct_new]\n  pub fn new() -> ActionResultEffect {\n    ActionResultEffect { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_result_effects_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[export]\n#[derive_action_def_def_result_effects_builder]\npub fn build_action_def_result_effects() -> pub ActionResultEffect { ActionResultEffect::new() }\n\npub comptime fn apply_action_result_effects(register: Quoted) -> Quoted {\n  let base_index = get_action_def_result_effect_base_index();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_RESULT_EFFECTS, base_index, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n// println(result);\n  quote {\n    $result\n\n    let result_progress_raw = actor_progress as u32 * action_result_effect_progress_multiplier + action_result_effect_progress_increment;\n    //softassert!(quote { is_valid }, quote { result_progress_raw <= MAX_PROGRESS as u32 }, quote { f\"Invalid result progress: {result_progress_raw} > {MAX_PROGRESS}\" });\n    result_progress = result_progress_raw as u8;\n\n    result_is_hidden = (result_is_hidden & !action_result_effect_leave_shadows) | action_result_effect_hide;\n    result_is_visible = !result_is_hidden & is_visible(enemy_advance, result_coords.0);\n  }\n}\n\npub comptime fn set_action_def_result_effects_in_action_def(effects: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_result_effect_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_result_effects_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $effects.register[$i]; });\n    // result = quote { $result $action_def += $effects.register[$i] as Field * $multiplier; };\n    // multiplier *= 2;\n  }\n  result\n}\n\ncomptime fn derive_frontend_action_def_result_effects_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[derive_frontend_action_def_result_effects_struct]\n#[derive(Default)]\npub struct FrontendActionDefResultEffects {}\n\n\npub comptime fn derive_frontend_action_def_result_effects_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_result_effect_base_index(), ACTION_DEF_DEF_RESULT_EFFECTS);\n  quote { FrontendActionDefResultEffects { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionResultEffect.nr"}},"names":["build_action_def_result_effects"],"brillig_names":["directive_integer_quotient"]}