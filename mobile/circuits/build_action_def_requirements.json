{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9386192237130727421,"abi":{"parameters":[{"name":"action_req_target_free_space","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_target_is_not_self","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_status_visible","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_status_invisible","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_status_hidden","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_min_progress","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_max_progress","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_status","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"action_req_max_range","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"actionRequirements::ActionRequirement","fields":[{"name":"register","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"H4sIAAAAAAAA/9WZS1LCQBCGO4CAIu9XEFaWW6tm8pBkpwsPImXYewsP4B30JC504SU8iA5Ol11hyEK6U9JVqQ499FT6mz89IXjwY4vv49Kee99H1XpjzVzMc8QqjljVEas5YkeOWN0RazhiTXtQq1h/bb3azwKPzBWqqyjKlkGmQ32ngnSVxCqKV1eJTnScxPdBEoZZEiXLdJUuVaqjMNPrOA3XdrI233UpyqHt4FDl5aA552ozMu0IMe3IayuqMHLoCnHolqAtxjXUXUamPSGmPXltJVVGDn0hDv0StMW4hrrPyHQgxHQgri2taowchkIchiVoi3EN9ZCR6UiI6cgyreV0Rc1jZnzEWIvjctnuCcpibP0EgSDAsYVHYxP4BYrGLVQK8a/iytYb02PgE+qEr0ZVpijrcHiinFrvIxAU4BS2RemDvCjrwCfKKfCJ0geZxeXehX3Gmmcgs2OYeaV3YcYmomeMTM+EmJ5B+btwAw6v4c2tXyAQBDiH7Ya3APmGRyHu2/DmwCfUBRxCw1P6mLFmzkdkyZpP4H82JMmaWweo7X2vs8nI75S55mNSN77uN73R9Evzy8I8yOHreTTspSbXaNis6ak9R8Pz96eP15fHu3sytPmusfHnzezh7fmWjnUK8noFeYOCvFFB3qQgzy/IOy/Iu9iRR/92MYbsT8g4fbWn9rMA52/JzK8asG1UA63cGN5XNUeet+NzJeeLvpuP01jbMYZzDq2n14t1fAFXj5jcRxsAAA==","debug_symbols":"ndXbaoQwEAbgd8n1XiQzOfoqpSwe4hIQFQ+FIvvuVWm6S0gvnDsnwxeG4cdsrPHV+riHvh1mVnxsrBvqcglDv1cbc+fRPJb9Uc1LOS2sEFqYG/N9c3xK/byxNnSeFRqfnzcmOMGIrEEuo0GE1ADBYNZY0NFYJVIjCUYRZtMEY3IGxN9sIBSmxhKMuz4bcILJ5gAkRgNS2dQAwSBhNkkw2RyAdjzOZkS6a9AEYwjGEkw2B+CkisbpdNfICUYQDBAM5rNjIBrF3cuI00iCUf8Y8TImNZpgsjlA4PHfiwAy3YElGHfdSH7V7EU1ha4Lj/v7o7Qff5VTKKvO/5bt2tdv3eV7jJ3ox2mofbNO/rjp7O3X/wA=","file_map":{"61":{"source":"use dep::std::{append::Append};\nuse skplg::UNREADABLE_BYTES_PER_FIELD;\n\npub trait ActionDefinitionPartBuilder<T> { fn new() -> T; }\npub type DEF_ROW<T> = (Quoted, u8, T);\npub comptime fn get_def_register_value(register: Quoted, bytes: u32, bits: u8, bitsize: u8) -> Quoted {\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    if bitsize == 8 {\n      quote { $register[$bytes] }\n      // quote { ($register / $multiplier) as u8 }\n    } else {\n      let divisor = 1 << bits;\n      let mask = std::wrapping_sub(1 << bitsize, 1);\n      if bitsize == 1 {\n        // quote { (($register / $multiplier) as u1) == 1 }\n        quote { (($register[$bytes] as u8 & $divisor as u8) != 0 as u8) }\n      } else {\n        quote { (($register[$bytes] as u8 / $divisor as u8) & $mask as u8) }\n        // quote { (($register / $multiplier) as u8) & $mask as u8 }\n      }\n    }\n}\npub comptime fn build_over_def_array<Env, T>(array: [DEF_ROW<T>], base_index: u32, builder: fn[Env] (u32, u8, Quoted, u8, T) -> Quoted) -> Quoted {\n  let mut result = quote {};\n  \n  let mut bits: u8 = 0;\n  let mut bytes: u32 = base_index;\n\n  for i in 0..array.len() {\n    let (varname, bitsize, args) = array[i];\n    assert(bitsize <= 8, f\"Invalid bit size: {bitsize}\");\n    if (bits + bitsize) > 8 {\n      bytes += 1;\n      bits = 0;\n    }\n    assert(bits < 8, f\"bits must not reach 8 or higher: {bits}\");\n\n    let new_result = builder(bytes, bits, varname, bitsize, args);\n    result = quote { $result $new_result };\n\n    bits += bitsize;\n  }\n  result\n}\npub comptime fn derive_action_def_def_builder<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let mut params: [(Quoted, Type)] = &[];\n  let mut last_byte: u32 = 0;\n  let mut result: Quoted = build_over_def_array(array, 0, |bytes, bits, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { u8 }.as_type() } else { quote { u8 }.as_type() };\n    params = params.push_back((varname, t));\n    let mut r = quote {};\n    if bytes != last_byte {\n      r = r.append(quote { , });\n    } else if (bytes + bits as u32) != 0 {\n      r = r.append(quote { + });\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = r.append(quote { $varname  });\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = r.append(quote { $varname as u8 * $multiplier });\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = r.append(quote { (( $varname & $mask ) * $multiplier) });\n      }\n    }\n    last_byte = bytes;\n    r\n  });\n  f.set_parameters(params);\n\n  let return_type = f.return_type();\n\n  f.set_body(quote { $return_type { register: [ $result ] } }.as_expr().unwrap());\n  // println(f.body());\n}\npub comptime fn get_action_def_def_register_size<T>(array: [DEF_ROW<T>]) -> u32 {\n  let mut size = 0;\n  let _ = build_over_def_array(array, 0, |bytes, _, _, _, _|{\n    size = bytes;\n    quote {}\n  });\n  size + 1\n}\npub comptime fn get_action_def_def_register_element_type() -> Type {\n  quote { u8 }.as_type()\n}\npub comptime fn get_action_def_def_register_type<T>(array: [DEF_ROW<T>]) -> Type {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  quote { [$et; $size] }.as_type()\n}\npub comptime fn derive_action_def_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  // let size = get_action_def_requirements_register_size();\n  let fields = s.fields([]);\n  assert(fields.len() == 1);\n  s.set_fields([(fields[0].0, get_action_def_def_register_type(array))]);\n}\npub comptime fn derive_action_def_def_struct_new<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  let t = get_action_def_def_register_type(array);\n  f.set_return_type(t);\n  f.set_body(quote { ActionRequirement { [0 as $et; $size] } }.as_expr().unwrap());\n}\npub comptime fn derive_frontend_action_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  let mut fields: [(Quoted, Type)] = &[];\n  let _ = build_over_def_array(array, UNREADABLE_BYTES_PER_FIELD, |_, _, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    fields = fields.push_back((varname, t));\n    quote {}\n  });\n  s.set_fields(fields);\n}\npub comptime fn derive_frontend_action_def_struct_builder<T>(param_name: Quoted, base_index: u32, array: [DEF_ROW<T>]) -> Quoted {\n  // let mut params: [(Quoted, Type)] = &[];\n  let mut first = true;\n  let mut result: Quoted = build_over_def_array(array, base_index, |bytes, bits, varname, bitsize, _|{\n    // let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    // params = params.push_back((varname, t));\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    let mut r = quote {};\n    if !first {\n      r = quote { , };\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = quote { $r $varname: $param_name[$bytes] };\n      // r = quote { $r $varname: ($param_name / $multiplier) as u8 };\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = quote { $r $varname: ($param_name[$bytes] & $multiplier) != 0 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u1) == 1 };\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = quote { $r $varname: (( $param_name[$bytes] / $multiplier) & $mask ) as u8 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u8) & $mask as u8 };\n      }\n    }\n    first = false;\n    r\n  });\n  // f.set_parameters(params);\n\n  // let return_type = f.return_type();\n  // // f.set_return_type(return_type.as_type());\n  // f.set_return_data();\n  // f.set_return_public(true);\n  // // println(result);\n  // f.\nresult\n  // quote {  $result } };\n}\n\n// pub global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2; // u2\n\n// global YES: u8 = 1;\n// global NO: u8 = 0;\n// global MIN_STATUS: u8 = 0;\n// global MAX_STATUS: u8 = 15;\n\n// // pub type ActionDefinitionRegister = \n// pub fn build_action_def_requirements_none() -> ActionRequirement {\n//   build_action_def_requirements(\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     MIN_STATUS,\n//     MAX_STATUS,\n//     0 as u8,\n//     255 as u8)\n// }\n// pub fn build_action_def_pre_calc_effects_idle() -> ActionPreCalcEffect {\n//   build_action_def_pre_calc_effect(\n//     WAIT,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1)\n// }\n// // comptime fn no_requirements() -> CtString {\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1, \n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         0 as u8,\n// //         NO as u1)\n// // }\n// pub fn build_action_def_result_event_none() -> ActionResultEvent {\n//   build_action_def_result_event(\n//     0,\n//     0,\n//     ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//     NO_EVENT,\n//     NO_EVENT,\n//     0 as u8\n//   )\n// }\n// // comptime fn no_event() -> CtString {\n// //     build_action_event_def(NO_EVENT, NO_EVENT, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 0 as u8)\n// // }\n// pub fn build_wait_action_def() -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements_none(),\n//     build_action_def_pre_calc_effects_idle(),\n//     build_action_def_result_effects(\n//       0 as u8,\n//       0 as u8,\n//       1 as u8,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_wait_action_def() -> CtString {\n// //     build_action_def(\n// //         no_requirements(),\n// //         no_event(),\n// //         no_event(),\n// //         1 as u8,\n// //         0 as u8,\n// //         ACTION_RESULT_COORDINATES_IDX_SELF,\n// //         NO as u1,\n// //         WAIT\n// //     )\n// // }\n// // pub global WAIT_ACTION: ActionDefinition = comptime { let x = build_wait_action_def(); f\"[{x}]\".quoted_contents() };\n// pub fn build_sneak_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0 as u8,\n//       1 as u8),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0 as u8,\n//       0 as u8,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       YES as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_sneak_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     no_event(), // TODO: not sure if on-seen we should not send a move event instead - that way one could sneak and stay hidden, but not sneak while visible\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_move_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       1),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_MOVE,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_move_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_MOVE, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_cast_action(this_action_id: u8, energy: u8, class: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_CAST,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_cast_action(this_action_id: u8, energy: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_CAST, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_ritual_action(cast_action_id: u8, energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       RITUAL_ROUNDS_FOR_WIN,\n//       MAX_STATUS,\n//       0,\n//       255),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_ritual_action(this_action_id: u8, energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         RITUAL_ROUNDS_FOR_WIN,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 255 as u8),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 255 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1), // TODO: Maybe set this to handle friendly fire???\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     cast_action_id)\n// // }\n// pub fn build_search_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_search_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS, // should be max of shoot\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_DRAW,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_DRAW, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       draw_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     draw_action_id)\n// // }\n// pub fn build_disarm_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_disarm_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_set_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         ADD_OBSTACLE,\n//         TRAP,\n//         0),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_set_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         YES as u1),\n// //     no_event(),\n// //     build_action_event_def(ADD_OBSTACLE, TRAP, 0 as u8, 50 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n\n// // pub fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // fn get_action_needs_target_free_space(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// // }\n// // fn get_action_needs_target_is_not_self(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// // }\n// // fn get_action_needs_status_visible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// // }\n// // fn get_action_needs_status_invisible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// // }\n// // fn get_action_needs_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_sets_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_removes_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_max_range(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_MAX_RANGE]\n// // }\n// // fn get_action_needs_min_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MIN_STATUS]\n// // }\n// // fn get_action_needs_max_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MAX_STATUS]\n// // }\n// // fn get_action_needed_energy(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDED_ENERGY]\n// // }\n// // fn get_action_unseen_event_is_internal(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_EVENT_IS_TRAP] == 1\n// // }\n// // fn get_action_result_event_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_event_not_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_not_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_not_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_not_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_not_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_not_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_status_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// // }\n// // fn get_action_move_to_target(action: ActionDefinition) -> u1 {\n// //     action.register[action.base_index + ACTION_MOVE_TO_TARGET] as u1\n// // }\n// // fn get_action_is_continuous(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_IS_CONTINUOUS] == 1\n// // }\n// // fn get_action_needs_previous_action(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_PREVIOUS_ACTION] as u8\n// // }\n\n// // pub global ACTION_DEFINITION_SIZE: u32 = (ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 5) as u32; // 2 bytes for move_to_target and status_multiplier\n// // pub global ACTION_DEFINITION_REGISTER_SIZE: u32 = ACTION_DEFINITION_SIZE * (1 + (MAX_ACTIONS_PER_CHARACTER - 1) * (CLASS_COUNT - 1));\n\n// // fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // pub struct ActionDefinitionRegister {\n// //   register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinitionRegister {\n// //   pub fn new(register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinitionRegister {\n// //     ActionDefinitionRegister {\n// //       register: register\n// //     }\n// //   }\n\n// //   pub fn resolve_action(self, action: Action) -> ActionDefinition {\n// //     ActionDefinition {\n// //       base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //       action: action,\n// //       register: self.register\n// //     }\n// //   }\n// // }\n\n// // pub struct ActionDefinition {\n// //     base_index: u16,\n// //     action: Action,\n// //     register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinition {\n// //     pub fn new(action: Action, register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinition {\n// //         ActionDefinition {\n// //             base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //             action: action,\n// //             register: register\n// //         }\n// //     }\n// // }\n\n// // impl ResolvedAction for ActionDefinition {\n// //     fn get_action_needs_target_free_space(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: ActionDefinition) -> u1 {\n// //         self.register[self.base_index + ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n\n// // pub struct TestActionDefinition {\n// //     pub register: [u8; ACTION_DEFINITION_SIZE],\n// //     pub action: Action,\n// // }\n\n// // impl ResolvedAction for TestActionDefinition {\n// //     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n// //         self.register[ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n// // #[test]\n// // fn test_execute_action() {\n// //     let action = build_test_action_def!(build_move_action(4), quote { 1, 2, 3, 4 }); //new_action(1, 2, 3, 4);\n// //     let my_advance = 10;\n// //     let their_advance = 1;\n// //     let actor = Character {\n// //         id: 2,\n// //         x: 2,\n// //         y: 4,\n// //         target_x: 0,\n// //         target_y: 0,\n// //         health: 255,\n// //         damage_mod: 1,\n// //         last_action: WAIT,\n// //         class: MAGE,\n// //         is_hidden: 0 as u1,\n// //         has_been_seen: true,\n// //         status: 0,\n// //         actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]\n// //     };\n// //     let energy = 15;\n// //     let my_obstacles = get_default_obstacles(0);\n// //     let their_obstacles = get_default_obstacles(1);\n// //     let (valid, event, internal_event, c, result_energy) = execute_action(\n// //         action,\n// //         my_advance,\n// //         their_advance,\n// //         actor,\n// //         energy,\n// //         my_obstacles,\n// //         their_obstacles\n// //     );\n// //     assert(valid, \"valid\");\n// //     assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n// //     assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n// //     assert(event.x == action.get_action_target_x(), f\"{event}.target_x is not action target x\");\n// //     assert(event.y == action.get_action_target_y(), f\"{event}.target_y is not action target y\");\n// //     assert(c.x == event.x, f\"{c}.x is not action target x\");\n// //     assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n// //     assert(result_energy == 11, f\"{result_energy} != 11\");\n// // }\n\n// // #[export]\n// // pub fn build_action_register(actions: [])\n\npub type CharacterActionDefinition = [u8; 32];\npub type CharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [CharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedCharacterActionDefinition = Field;\npub type SerializedCharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedRosterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32, let MAX_CHARACTERS: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS];","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionDefinition.nr"},"63":{"source":"use skplg::{UNREADABLE_BYTES_PER_FIELD, softassert};\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse std::append::Append;\nuse crate::{actionDefinition::derive_frontend_action_def_struct, actionDefinition::derive_frontend_action_def_struct_builder};\n\n    // fn get_action_req_target_free_space(self) -> bool;\n    // fn get_action_req_target_is_not_self(self) -> bool;\n    // fn get_action_req_status_visible(self) -> bool;\n    // fn get_action_req_status_invisible(self) -> bool;\n    // fn get_action_req_status_hidden(self) -> bool;\n    // fn get_action_req_max_range(self) -> u8;\n    // fn get_action_req_min_status(self) -> u8;\n    // fn get_action_req_max_status(self) -> u8;\n    // fn get_action_req_energy(self) -> u8;\n    // fn get_action_req_previous_action(self) -> u8;\npub type ActionDefDefRequirementCheck = (Quoted, Quoted);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, expr: Quoted, msg: Quoted) -> DEF_ROW<ActionDefDefRequirementCheck> {\n    (varname, bit_size, (expr, msg))\n}\n// comptime global ACTION_DEF_DEF_FIELD_COUNT: u32 = 11;\nglobal ACTION_DEF_DEF_REQUIREMENTS: [DEF_ROW<ActionDefDefRequirementCheck>] = [\n    action_def_def(quote { action_req_target_free_space }, 1, quote { can_move_to(distance, action_target_x, action_target_y, my_obstacles, their_obstacles) }, quote { f\"Target space cannot be moved to {action_target_x},{action_target_y}) cannot be moved to: {VIEW_DISTANCE},{my_obstacles},{their_obstacles}\" }),\n    action_def_def(quote { action_req_target_is_not_self }, 1, quote { (actor_x != action_target_x) | (actor_y != action_target_y) }, quote { f\"Target cannot be self ({action_target_x},{action_target_y})\" }),\n    action_def_def(quote { action_req_status_visible }, 1, quote { actor_is_in_view_range & !actor_is_hidden },  quote { f\"Character must be fully visible for action {action_type}: in_view_range: {actor_is_in_view_range} & !hidden {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_invisible }, 1, quote { !actor_is_in_view_range | actor_is_hidden }, quote { f\"Character must not be visible to perform action {action_type}: !in_view_range: {actor_is_in_view_range} || hidden: {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_hidden }, 1, quote { actor_is_hidden }, quote { f\"Character needs to be hidden to perform action {action_type}\" }),\n    // action_def_def(quote { action_req_previous_action }, 3, quote { true }, quote { f\"\" }),\n    action_def_def(quote { action_req_min_progress }, 4, quote { action_req_min_progress as u8 <= actor_progress as u8 }, quote { f\"Character needs min progress {action_req_min_progress} to perform action {action_type}, but only has {actor_progress}\" }),\n    action_def_def(quote { action_req_max_progress }, 4, quote { action_req_max_progress as u8 >= actor_progress as u8 }, quote { f\"Character cannot have a higher progress than {action_req_max_progress} to perform action {action_type}: got {actor_progress}\" }),\n    action_def_def(quote { action_req_status }, 4, quote { (action_req_status as u8 == 0 as u8) | (action_req_status as u8 == actor_progress as u8) }, quote { f\"Character can only perform action {action_type} while having status {action_req_status}. Invalid status {actor_status}\" }),\n    // action_def_def(quote { action_req_required_energy }, 4, quote { action_req_required_energy <= energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_req_required_energy}\" }),\n    action_def_def(quote { action_req_max_range }, 8, quote { distance as u16 <= (action_req_max_range as u16) * (action_req_max_range as u16) }, quote { f\"Character is out of range! Distance: {distance} > {action_req_max_range}: {{{actor_x},{actor_y}}} - {{{action_target_x},{action_target_y}}} with {action_req_max_range}\" }),\n];\npub comptime fn get_action_def_requirements_base_index() -> u32 {\n  UNREADABLE_BYTES_PER_FIELD as u32\n}\n\npub comptime fn get_action_def_requirements_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_REQUIREMENTS)\n}\n\ncomptime fn derive_action_def_def_req_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n// comptime fn derive_action_def_requirements_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_REQUIREMENTS);\n// }\n\n#[derive_action_def_def_req_struct]\npub struct ActionRequirement {\n  pub register: [u8; 32]\n}\nimpl ActionRequirement {\n  #[derive_action_def_requirements_struct_new()]\n  pub fn new() -> ActionRequirement {\n    ActionRequirement { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_req_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[export]\n#[derive_action_def_def_req_builder]\npub fn build_action_def_requirements() -> pub ActionRequirement { ActionRequirement::new() }\n\npub comptime fn validate_action_requirements(valid_varname: Quoted, register: Quoted) -> Quoted {\n  let mut result = build_over_def_array(ACTION_DEF_DEF_REQUIREMENTS, get_action_def_requirements_base_index(), |bytes, bits, varname, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    // let varname = f\"action_requirement_{i}_is_valid\".quoted_contents();\n    let (checkexpr, msg) = args;\n    let check = if bitsize == 1 { quote { !($varname as bool) | ($checkexpr) } } else { quote { $checkexpr } };\n    let sa = softassert(valid_varname, check, msg);\n    quote {\n      let $varname = $expr;\n      $sa\n    }\n  });\n  // println(result);\n  // quote { assert(1==1); }\n  result\n}\n\npub comptime fn set_action_def_requirements_in_action_def(requirements: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_requirements_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_requirements_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $requirements.register[$i]; });\n    // result = quote { $result $action_def += $requirements.register[$i] as Field * $multiplier; };\n    // multiplier *= 2.pow_32(8);\n  }\n  // println(result);\n  result\n}\n\ncomptime fn derive_frontend_action_def_requirements_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[derive_frontend_action_def_requirements_struct]\n#[derive(Default)]\npub struct FrontendActionDefRequirements {}\n\n\npub comptime fn derive_frontend_action_def_requirements_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_requirements_base_index(), ACTION_DEF_DEF_REQUIREMENTS);\n  // println(content);\n  quote { FrontendActionDefRequirements { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionRequirements.nr"}},"names":["build_action_def_requirements"],"brillig_names":["directive_integer_quotient"]}