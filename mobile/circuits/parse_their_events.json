{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9751636141153306892,"abi":{"parameters":[{"name":"fields","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"array","length":4,"type":{"kind":"struct","path":"event::Event","fields":[{"name":"event","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"subtype","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"radius","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"74":{"source":"use arenalib::{ NO_EVENT, SEE_MOVE, RECEIVE_ATTACK, TRIGGERED_TRAP }; //, SEE_RITUAL, SEE_CAST, SEE_DRAW, SEE_SEARCH_TRAP, FOUND_TRAP\n// use crate::{ EMPTY, WALL };\nuse arenalib::{ EVENT_COUNT };\nuse arenalib::{ ATTACK_FIREBALL };\nuse arenalib::{ SERIALIZED_EVENT_BYTE_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD };\nuse arenalib::{ WIDTH };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS }; //, MAX_TRAPS\nuse arenalib::SerializedArenaEvents;\n// use crate::TRAPS_BUFFER_MASK;\nuse crate::map::get_distance;\n// use crate::character::Character;\nuse crate::character::{ get_attack_damage_to_tile, get_trap_damage_to_tile };\nuse crate::map::their_x_to_mine;\nuse skplg::{ debug, softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD };\n\npub struct Event {\n    pub event: u8,\n    pub actor_id: u8,\n    pub subtype: u8,\n    pub x: u8,\n    pub y: u8,\n    pub value: u8,\n    pub radius: u8,\n}\n\n\n    #[export]\n    pub fn parse_their_events(fields: SerializedArenaEvents) -> pub (bool, [Event; MAX_EVENTS]) {\n        comptime {\n            assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENT_BYTE_SIZE <= 32);\n            assert(SERIALIZED_EVENTS_ARRAY_SIZE * SERIALIZED_EVENTS_PER_FIELD == MAX_EVENTS);\n            assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n        }\n\n        let mut valid = true;\n        let mut events: [Event; MAX_EVENTS] = [Event::empty(0); MAX_EVENTS];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let split: [u8; 32] = fields[i].to_be_bytes::<32>(); //.to_be_bytes<32>();\n            //assert(split.len() == 32);\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                let raw_x = split[offset + 2];\n                let (x_parsed_valid, x_parsed) = their_x_to_mine(raw_x);\n                softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to calculate their_x_to_mine: {raw_x}\" });\n                events[i * SERIALIZED_EVENTS_PER_FIELD + j] = Event {\n                    event: split[offset],\n                    actor_id: split[offset + 1],\n                    x: x_parsed,\n                    y: split[offset + 3],\n                    value: split[offset + 4],\n                    subtype: split[offset + 5],\n                    radius: split[offset + 6],\n                };\n            }\n        }\n        (valid, events)\n    }\n    \n    #[export]\n    pub fn serialize_events(events: [Event; MAX_EVENTS]) -> pub SerializedArenaEvents {\n        assert(events.len() == MAX_EVENTS);\n        assert(MAX_EVENTS % SERIALIZED_EVENTS_PER_FIELD == 0);\n        assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n\n        let mut fields: [Field] = &[];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let mut data: [u8; 32] = [0; 32];\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let index = i * SERIALIZED_EVENTS_PER_FIELD + j;\n                let event = events[index];\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                data[offset] = event.event;\n                data[offset + 1] = event.actor_id;\n                data[offset + 2] = event.x;\n                data[offset + 3] = event.y;\n                data[offset + 4] = event.value;\n                data[offset + 5] = event.subtype;\n                data[offset + 6] = event.radius;\n            }\n            fields = fields.push_back(std::field::bytes32_to_field(data));\n        }\n        fields.as_array()\n    }\n    \n#[test]\nfn test_event_serde() {\n    let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 5, NO_EVENT, 1),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 6, NO_EVENT, 2),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 7, NO_EVENT, 3),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 8, NO_EVENT, 4)\n  ];\n\n  let serialized = serialize_events(events);\n  let (result_valid, result) = parse_their_events(serialized);\n  assert(result_valid);\n  assert(result[0].event == events[0].event);\n  assert(result[1].event == events[1].event);\n  assert(result[2].event == events[2].event);\n  assert(result[3].event == events[3].event);\n  assert(result[0].actor_id == events[0].actor_id);\n  assert(result[1].actor_id == events[1].actor_id);\n  assert(result[2].actor_id == events[2].actor_id);\n  assert(result[3].actor_id == events[3].actor_id);\n  assert(result[0].x == events[0].x);\n  assert(result[1].x == events[1].x);\n  assert(result[2].x == events[2].x);\n  assert(result[3].x == events[3].x);\n  assert(result[0].y == events[0].y);\n  assert(result[1].y == events[1].y);\n  assert(result[2].y == events[2].y);\n  assert(result[3].y == events[3].y);\n  assert(result[0].value == events[0].value);\n  assert(result[1].value == events[1].value);\n  assert(result[2].value == events[2].value);\n  assert(result[3].value == events[3].value);\n  assert(result[0].subtype == events[0].subtype);\n  assert(result[1].subtype == events[1].subtype);\n  assert(result[2].subtype == events[2].subtype);\n  assert(result[3].subtype == events[3].subtype);\n  assert(result[0].radius == events[0].radius);\n  assert(result[1].radius == events[1].radius);\n  assert(result[2].radius == events[2].radius);\n  assert(result[3].radius == events[3].radius);\n}\n    // fn affects_my_character(self, x: u8, y: u8) -> bool {\n    //     let distance = get_distance(self.x, self.y, x, y);\n    //     ((self.x == x) & (self.y == y)) | ((self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y))\n    // }\nimpl Event {\n    fn affects_my_obstacle(self, x: u8, y: u8) -> bool {\n        (self.x == x) & (self.y == y)\n    }\n\n    fn may_affect_my_other_characters(self) -> bool {\n        (self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL)\n    }\n\n    fn may_affect_my_obstacles(self) -> bool {\n        self.event == RECEIVE_ATTACK\n    }\n\n    /**\n    * For now we will only take class into account.\n    */\n    pub fn get_applied_damage_to_my_asset(self, x: u8, y: u8, tile: u8) -> u16 {\n        let mut damage = 0;\n        let radius = self.radius as u32;\n        let radius = radius * radius;\n    \n        if self.event == RECEIVE_ATTACK {\n            let distance = get_distance(self.x, self.y, x, y) as u32;\n            debug!(quote {\n                        // let event = self.event;\n                        // let actor = self.actor_id;\n                        // let self_x = self.x;\n                        // let self_y = self.y;\n                        // let val = self.value;\n                        // println(f\"GetAppliedDamageToMyAsset: Event({event}:{val} from {actor}@{self_x}|{self_y})@{x}|{y}: {distance} <= {radius}\");\n                    });\n            if distance <= radius {\n                let damage_raw = get_attack_damage_to_tile(self.subtype, self.value as u32, tile) as u32;\n                damage = damage_raw * (1 + radius - distance) / (radius + 1) as u32;\n                debug!(quote { println(f\"Deal damage: {damage_raw} * (1 + {radius} - {distance}) / ({radius} + 1) = {damage}\"); });\n            }\n            // if (self.x == x) & (self.y == y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile);\n            // } else if (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile) / 2;\n            // }\n        }\n        if self.event == TRIGGERED_TRAP {\n            damage = get_trap_damage_to_tile(self.value as u32, tile);\n        }\n        damage as u16\n    }\n\n    pub fn empty(actor_id: u8) -> Event {\n        Event {\n            event: NO_EVENT,\n            actor_id: actor_id,\n            x: 0,\n            y: 0,\n            value: 0,\n            subtype: 0,radius: 0\n        }\n    }\n\n    pub fn get_dummy_events() -> [Field; MAX_EVENTS] {\n        [0; MAX_EVENTS]\n    }\n\n    pub fn get_test_dummy_events() -> [Event; MAX_EVENTS] {\n        [Event::empty(0); MAX_EVENTS]\n    }\n}\n\npub fn build_std_event(event: u8, actor_id: u8, x: u8, y: u8) -> Event {\n    assert(event < EVENT_COUNT);\n    assert((actor_id as u32) < MAX_CHARACTERS);\n    assert((x < WIDTH) | (x == NOWHERE));\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: 0,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\n#[test]\nfn test_build_std_event() {\n    let event = build_std_event(SEE_MOVE, 1, 2, 3);\n    assert(event.event == SEE_MOVE);\n    assert(event.actor_id == 1);\n    assert(event.x == 2);\n    assert(event.y == 3);\n}\n\n#[test(should_fail)]\nfn test_build_std_event_fail() {\n    let event = build_std_event(EVENT_COUNT, 1, 2, 3);\n    assert(event.event == EVENT_COUNT);\n}\n\npub fn build_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8) -> Event {\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\npub fn build_subtype_value_event(event_type: u8, actor_id: u8, x: u8, y: u8, value: u8, event_subtype: u8, radius: u8) -> Event {\n    Event {\n        event: event_type,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: event_subtype,\n        radius: radius,\n    }\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/event.nr"},"76":{"source":"use arenalib::{ WIDTH, WIDTH_MASK, VIEW_DISTANCE, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES };\nuse crate::obstacle::{ Obstacle, get_obstacle_y, get_obstacle_x, is_obstacle_traversible };\nuse skplg::NOWHERE;\n\n// pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> bool {\n//     // assert(curr_x < WIDTH);\n//     // assert(curr_y < HEIGHT);\n//     // assert(x < WIDTH);\n//     // assert(y < HEIGHT);\n//     // validating coordinates is not the job of this function\n//     // only avoid overflows!\n\n\n//     let shifted_curr_x = std::wrapping_add(curr_x, 1);\n//     let shifted_curr_y = std::wrapping_add(curr_y, 1);\n//     let shifted_x = std::wrapping_add(x, 1);\n//     let shifted_y = std::wrapping_add(y, 1);\n\n//     ((shifted_curr_x == shifted_x) & (std::wrapping_add(shifted_curr_y, 1) >= shifted_y) & (shifted_curr_y <= std::wrapping_add(shifted_y, 1))) |\n//     ((shifted_curr_y == shifted_y) & (std::wrapping_add(shifted_curr_x, 1) >= shifted_x) & (shifted_curr_x <= std::wrapping_add(shifted_x, 1)))\n// }\n\n// global DISTANCE_TABLE_HEIGHT: u32 = HEIGHT as u32;\n// global DISTANCE_TABLE_WIDTH: u32 = WIDTH as u32;\n\n// unconstrained fn distance_sqrt(x: u32) -> u32 {\n//     let mut result: u32 = 0;\n//     for i in 0..DISTANCE_TABLE_WIDTH {\n//         if i * i == x {\n//             result = i;\n//             break;\n//         }\n//     }\n//     result\n// }\n\n// fn d(a: u8, b: u8) -> u8 {\n//     let d = a as i32 - b as i32;\n//     let d2 = d * d;\n//     assert(d2 >= 0);\n//     let d2u = d2 as u32;\n//     let result = unsafe {\n//         let sq = distance_sqrt(d2u);\n//         assert(sq * sq == d2u);\n//         sq\n//     };\n//     assert(result < DISTANCE_TABLE_WIDTH);\n//     comptime { assert(DISTANCE_TABLE_WIDTH <= 256) };\n//     result as u8\n// }\n// global DISTANCE_TABLE: [[u8; DISTANCE_TABLE_WIDTH]; DISTANCE_TABLE_HEIGHT] = [\n//     [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 2,  2,  3,  4,  5,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ],\n//     [ 3,  3,  3,  4,  4,  5,  6,  7,  8,  9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ],\n// ]\n\nglobal MAX_DISTANCE: u32 = 0xff * 0xff;\n\npub fn get_distance(curr_x: u8, curr_y: u8, x: u8, y: u8) -> u16 {\n    // assert(curr_x < WIDTH);\n    // assert(curr_y < HEIGHT);\n    // assert(x < WIDTH);\n    // assert(y < HEIGHT);\n    // validating coordinates is not the job of this function\n    // only avoid overflows!\n\n    // let dx = unsafe {\n    //     let diff_\n    //     distance_sqrt(x)\n    // }\n\n    let dx = if curr_x > x { curr_x - x } else { x - curr_x } as u32;\n    let dy = if curr_y > y { curr_y - y } else { y - curr_y } as u32;\n\n    // let dx = curr_x as i16 - x as i16;\n    // let dy = curr_y as i16 - y as i16;\n\n    let distance = (dx * dx + dy * dy) as u32;\n    if distance > MAX_DISTANCE {\n      MAX_DISTANCE as u16\n    } else {\n      distance as u16\n    }\n}\n\n\npub fn is_visible(enemy_advance: u8, x: u8) -> bool {\n    //(x >= enemy_advance) == (side == 0)\n    x >= enemy_advance\n}\n\n// TODO: This is for the future - fireballs, etc. only if we have line of sight\n// pub fn is_visible(curr_x: u8, curr_y: u8, x: u8, y: u8, map: &Map) -> bool {\n//     assert(curr_x < WIDTH);\n//     assert(curr_y < HEIGHT);\n//     assert(x < WIDTH);\n//     assert(y < HEIGHT);\n\n//     let mut x = curr_x as f32;\n//     let mut y = curr_y as f32;\n//     let x2 = x + 0.5;\n//     let y2 = y + 0.5;\n//     let dx = x2 - x;\n//     let dy = y2 - y;\n//     let mut t = 0.0;\n//     let mut max_t = 1.0;\n//     let mut x = x;\n//     let mut y = y;\n\n//     while t < max_t {\n//         let x = x + dx * t;\n//         let y = y + dy * t;\n//         let x = x as u8;\n//         let y = y as u8;\n\n//         if map.is_wall(x, y) {\n//             return false;\n//         }\n\n//         t += 0.1;\n//     }\n\n//     true\n// }\n\npub fn their_x_to_mine(x: u8) -> (bool, u8) {\n    if x == NOWHERE {\n        (true, NOWHERE)\n    } else {\n        (x < WIDTH, std::wrapping_sub(WIDTH - 1, x) & WIDTH_MASK)\n    }\n}\n\npub fn can_move_to(distance: u16, x: u8, y: u8, obstacles: [Obstacle; MAX_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n    let mut can = distance <= (VIEW_DISTANCE as u16 * VIEW_DISTANCE as u16); //x <= advance;\n\n    for i in 0..MAX_OBSTACLES {\n        if !is_obstacle_traversible(obstacles[i]) & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n            can = false;\n        }\n    }\n    for i in 0..MAX_ENEMY_OBSTACLES {\n        if !is_obstacle_traversible(their_obstacles[i]) & (get_obstacle_x(their_obstacles[i]) == x) & (get_obstacle_y(their_obstacles[i]) == y) {\n            can = false;\n        }\n    }\n    can\n}\n// pub fn their_x_to_mine(side: u1, x: i8) -> i8 {\n//     let mul = side as i8;\n//     mul * 31 + 16 + x\n// }\n\n// x * s -16 + y = 0 if s == 0 => y = 16\n// x * s -16 + y = 31 if s == 1 => x = 31\n// y = 31 * s + 16 + x\n// s = 0:\n// x = -16 => y = 0\n// x = 15 => y = 31\n// s = 1:\n// x = -16 => y = 31\n// x = 15 => y = 0\n\n// pub fn serialize_x(x: i8) -> (bool, u8) {\n//     let valid = (x >= -(WIDTH / 2) as i8) & (x < (WIDTH / 2) as i8);\n//     (valid, (x + (WIDTH / 2) as i8) as u8)\n// }\n\n// pub fn deserialize_x(x: u8) -> (bool, i8) {\n//     let valid = x < WIDTH;\n//     (valid, x as i8 - (WIDTH / 2) as i8)\n// }","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/map.nr"},"96":{"source":"pub global NOWHERE: u8 = 255;\npub global UNREADABLE_BYTES_PER_FIELD: u32 = 1;\npub comptime global DEBUG: bool = true;\npub comptime fn debug(stmt: Quoted) -> Quoted {\n    let debug_result = if DEBUG { stmt } else { quote {} };\n    debug_result\n}\npub comptime fn debugmsg<T>(msg: T) -> Quoted {\n    debug!(quote { println($msg); })\n}\npub comptime fn softassert(varname: Quoted, check: Quoted, msg: Quoted) -> Quoted {\n    let result = if DEBUG {\n        quote {\n            $varname &= $check;\n            if !($check) {\n                println($msg);\n            }\n        }\n    } else {\n        quote {\n            $varname &= $check;\n        }\n    };\n    result\n}\n\n////////////////////\n\n// global WIDTH_MASK: u8 = 31;\n// global CLASS_MASK: u8 = 7;\n// global WIDTH_BITS: u8 = 5;\n// global MAX_CHARACTERS: u32 = 5;\n// struct Character {\n//     pub x: u8, // 5 bit\n//     pub class: u8, // 3 bit\n//     pub actions: [[u8; 32]; 7],\n// }\n// impl Character {\n//     fn is_class_valid(class: u8) -> bool {\n//         class as u32 <= 5\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         let mut valid = true;\n//         let x = self.x;\n//         let class = self.class;\n//         println(x);\n//         valid &= Character::is_class_valid(class);\n//         valid\n//     }\n\n//     fn parse(\n//         id: u8,\n//         data: Field,\n//         actions_data: [Field; 30],\n//         wait_action: [u8; 32],\n//     ) -> (bool, Character) {\n//         let mut is_valid = true;\n\n//         let split: [u8; 32] = data.to_be_bytes::<32>();\n//         assert(split.len() == 32);\n//         let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n\n//         let x = x_packed & WIDTH_MASK;\n//         let mut class = (x_packed >> WIDTH_BITS) & CLASS_MASK;\n//         if !Character::is_class_valid(class) {\n//             class = 0;\n//             is_valid = false;\n//         }\n\n//         let c = Character {\n//             x: x,\n//             class: class,\n//             actions: [\n//                 wait_action,\n//                 actions_data[id * 6 as u8].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 1].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 2].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 3].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 4].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 5].to_be_bytes::<32>(),\n//             ],\n//         };\n//         (is_valid, c)\n//     }\n// }\n\n// fn create_character(x: u8, class: u8) -> Character {\n//     let c = Character { x: x, class: class, actions: [[0 as u8; 32]; 7] };\n//     assert(c.is_valid());\n//     c\n// }\n// fn parse_characters(data: Field, actions_data: [Field; 30]) -> (bool, [Character; MAX_CHARACTERS]) {\n//     let mut is_valid = true;\n\n//     let wait_action = [\n//         0 as u8, 0 as u8, 240 as u8, 0 as u8, 63 as u8, 0 as u8, 0 as u8, 1 as u8, 0 as u8,\n//         32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n//         32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n//         0 as u8, 0 as u8, 0 as u8,\n//     ];\n\n//     // no need to optimize, compiler automatically rolls this out\n//     let mut result: [Character; MAX_CHARACTERS] = [\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//     ];\n//     for i in 0..(MAX_CHARACTERS as u8) {\n//         let (curr_valid, curr_c) = Character::parse(i, data, actions_data, wait_action);\n//         is_valid &= curr_valid;\n//         result[i] = curr_c;\n//     }\n\n//     // let (curr_valid, curr_c) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[0] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[1] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[2] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[3] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[4] = curr_c;\n//     (is_valid, result)\n// }\n\n// #[test]\n// fn test_parse_character_round0() {\n//     let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n\n//     let parsed = parse_characters(\n//         data,\n//         [\n//             0x03f00001300314002000000000100300000020000000002000000000000000,\n//             0x02f0000110071020100a000020100a00000020000000002000000000000000,\n//             0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n//             0x023100081b161118120a010018120a01000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110071008100a000008100a00000020000000002000000000000000,\n//             0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n//             0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300314002000000000100300000020000000002000000000000000,\n//             0x02f0000110071018100a000018100a00000020000000002000000000000000,\n//             0x09f0000130060c002000000000200000000020000000002000000000000000,\n//             0xf00001100610001005000100100500010020000000002000000000000000,\n//             0xf00001301c0100100d000000100d00000020000000002000000000000000,\n//             0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110061028100a000028100a00000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110071010100a000010100a00000020000000002000000000000000,\n//             0xf000071b1611002000000000000705000020000000002000000000000000,\n//             0x6300061b161164150a020164150a02010020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//         ],\n//     );\n//     assert(parsed.0);\n// }\n\n// // #[test]\n// // fn test_create_character_0() {\n// //   let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n// //   let enemy_advance = 0x08;\n// //   let events = [0 as u8, 0 as u8, 0 as u8, 0 as u8];\n// //   println(events);\n\n// //   let actions_data = [\n// //     0x03f00001300314002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071020100a000020100a00000020000000002000000000000000,\n// //     0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n// //     0x023100081b161118120a010018120a01000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071008100a000008100a00000020000000002000000000000000,\n// //     0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n// //     0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300314002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071018100a000018100a00000020000000002000000000000000,\n// //     0x09f0000130060c002000000000200000000020000000002000000000000000,\n// //     0xf00001100610001005000100100500010020000000002000000000000000,\n// //     0xf00001301c0100100d000000100d00000020000000002000000000000000,\n// //     0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110061028100a000028100a00000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071010100a000010100a00000020000000002000000000000000,\n// //     0xf000071b1611002000000000000705000020000000002000000000000000,\n// //     0x6300061b161164150a020164150a02010020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000\n// // ];\n// //   comptime { assert(5 <= 5); }\n\n// //     let enemy_advance = if enemy_advance >= 32 { 0 } else { 32 - enemy_advance - 1 };\n// //     let mut is_valid = true;\n\n// //     let wait_action = [0 as u8, 0 as u8, 240 as u8, 0 as u8, 63 as u8, 0 as u8, 0 as u8, 1 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8];\n\n// // let mut result: [Character; 5] = [create_character(0, 0, 0, 0), create_character(1, 0, 0, 0), create_character(2, 0, 0, 0), create_character(3, 0, 0, 0), create_character(4, 0, 0, 0)];\n// //     //for i in 0..(5 as u8) {\n// //         let (curr_valid, curr_c) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[0] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[1] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[2] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[3] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[4] = curr_c;\n// //    // }\n// //     assert(is_valid);\n// //     // assert(result[0].x == 0);\n// // }\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplg/src/lib.nr"}},"names":["parse_their_events"],"brillig_names":["print_unconstrained","directive_to_radix","directive_invert","directive_integer_quotient"]}