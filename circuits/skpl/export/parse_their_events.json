{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15440616427643061412,"abi":{"parameters":[{"name":"fields","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"array","length":4,"type":{"kind":"struct","path":"event::Event","fields":[{"name":"event","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"subtype","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"radius","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"74":{"source":"use arenalib::{ NO_EVENT, SEE_MOVE, RECEIVE_ATTACK, TRIGGERED_TRAP }; //, SEE_RITUAL, SEE_CAST, SEE_DRAW, SEE_SEARCH_TRAP, FOUND_TRAP\n// use crate::{ EMPTY, WALL };\nuse arenalib::{ EVENT_COUNT };\nuse arenalib::{ ATTACK_FIREBALL };\nuse arenalib::{ SERIALIZED_EVENT_BYTE_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD };\nuse arenalib::{ WIDTH };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS }; //, MAX_TRAPS\nuse arenalib::SerializedArenaEvents;\n// use crate::TRAPS_BUFFER_MASK;\nuse crate::map::get_distance;\n// use crate::character::Character;\nuse crate::character::{ get_attack_damage_to_tile, get_trap_damage_to_tile };\nuse crate::map::their_x_to_mine;\nuse skplg::{ debug, softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD };\n\n// TODO: THIS SHOULD BE GENERATED WITH MACRO!\n// pub global NO_EVENT: u8 = 0 ;\n// pub global DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n// //pub global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n// //pub global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\n// pub global SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n// //pub global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\n// pub global SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\n// pub global SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global RECEIVE_EFFECT: u8 = 9;   //NOTE: NEW: This is to be used for status effecting things! actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\n// pub global RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\n// pub global TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\n// // pub global FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\n// pub global DISARMED_TRAP: u8 = 13;      // actor_id = their-char when receive - need to remove my trap from the map\n// pub global WIN: u8 = 14;\n// // pub global LOSE: u8 = 15;\n// pub global ADD_OBSTACLE: u8 = 4;\n// pub global EVENT_COUNT: u8 = 16;\n\npub global EVENT_SUBTYPE_COUNT: u32 = 16;\npub global EVENT_ARRAY_SIZE: u32 = EVENT_COUNT as u32;\nglobal AFFECTS_HEALTH: u8 = 1;\nglobal AFFECTS_STATUS: u8 = 2;\nglobal AFFECTS_PROGRESS_ADD: u8 = 3;\nglobal AFFECTS_PROGRESS_SUB: u8 = 3;\npub global EVENT_DEFINITIONS: [[u8; EVENT_SUBTYPE_COUNT]; EVENT_ARRAY_SIZE] = [\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  0 NO_EVENT\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  1 DESTROY (not implemented)\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  2 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  3 SEE_MOVE\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  4 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  5 SEE_SEARCH_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  6 SEE_RITUAL\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  7 SEE_CAST\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  8 SEE_DRAW\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  9 RECEIVE_EFFECT\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 10 RECEIVE_ATTACK\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 11 TRIGGERED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 12 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 13 DISARMED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 14 WIN\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  // 15 ?\n];\nglobal EVENT_DEF_SIGN_ADD: u8 = 0;\nglobal EVENT_DEF_SIGN_SUB: u8 = 1;\npub global EVENT_DEFINITION_SIGNS: [[u8; EVENT_SUBTYPE_COUNT]; EVENT_ARRAY_SIZE] = [\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  0 NO_EVENT\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  1 DESTROY (not implemented)\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  2 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  3 SEE_MOVE\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  4 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  5 SEE_SEARCH_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  6 SEE_RITUAL\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  7 SEE_CAST\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  8 SEE_DRAW\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  9 RECEIVE_EFFECT\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 10 RECEIVE_ATTACK\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 11 TRIGGERED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 12 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 13 DISARMED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 14 WIN\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  // 15 ?\n];\n\npub struct Event {\n    pub event: u8,\n    pub actor_id: u8,\n    pub subtype: u8,\n    pub x: u8,\n    pub y: u8,\n    pub value: u8,\n    pub radius: u8,\n}\n\n\n    #[export]\n    pub fn parse_their_events(fields: SerializedArenaEvents) -> pub (bool, [Event; MAX_EVENTS]) {\n        comptime {\n            assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENT_BYTE_SIZE <= 32);\n            assert(SERIALIZED_EVENTS_ARRAY_SIZE * SERIALIZED_EVENTS_PER_FIELD == MAX_EVENTS);\n            assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n        }\n\n        let mut valid = true;\n        let mut events: [Event; MAX_EVENTS] = [Event::empty(0); MAX_EVENTS];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let split: [u8; 32] = fields[i].to_be_bytes::<32>(); //.to_be_bytes<32>();\n            //assert(split.len() == 32);\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                let raw_x = split[offset + 2];\n                let (x_parsed_valid, x_parsed) = their_x_to_mine(raw_x);\n                softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to calculate their_x_to_mine: {raw_x}\" });\n                events[i * SERIALIZED_EVENTS_PER_FIELD + j] = Event {\n                    event: split[offset],\n                    actor_id: split[offset + 1],\n                    x: x_parsed,\n                    y: split[offset + 3],\n                    value: split[offset + 4],\n                    subtype: split[offset + 5],\n                    radius: split[offset + 6],\n                };\n            }\n        }\n        (valid, events)\n    }\n    \n    #[export]\n    pub fn serialize_events(events: [Event; MAX_EVENTS]) -> pub SerializedArenaEvents {\n        assert(events.len() == MAX_EVENTS);\n        assert(MAX_EVENTS % SERIALIZED_EVENTS_PER_FIELD == 0);\n        assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n\n        let mut fields: [Field] = &[];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let mut data: [u8; 32] = [0; 32];\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let index = i * SERIALIZED_EVENTS_PER_FIELD + j;\n                let event = events[index];\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                data[offset] = event.event;\n                data[offset + 1] = event.actor_id;\n                data[offset + 2] = event.x;\n                data[offset + 3] = event.y;\n                data[offset + 4] = event.value;\n                data[offset + 5] = event.subtype;\n                data[offset + 6] = event.radius;\n            }\n            fields = fields.push_back(std::field::bytes32_to_field(data));\n        }\n        fields.as_array()\n    }\n    \n#[test]\nfn test_event_serde() {\n    let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 5, NO_EVENT, 1),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 6, NO_EVENT, 2),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 7, NO_EVENT, 3),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 8, NO_EVENT, 4)\n  ];\n\n  let serialized = serialize_events(events);\n  let (result_valid, result) = parse_their_events(serialized);\n  assert(result_valid);\n  assert(result[0].event == events[0].event);\n  assert(result[1].event == events[1].event);\n  assert(result[2].event == events[2].event);\n  assert(result[3].event == events[3].event);\n  assert(result[0].actor_id == events[0].actor_id);\n  assert(result[1].actor_id == events[1].actor_id);\n  assert(result[2].actor_id == events[2].actor_id);\n  assert(result[3].actor_id == events[3].actor_id);\n  assert(result[0].x == events[0].x);\n  assert(result[1].x == events[1].x);\n  assert(result[2].x == events[2].x);\n  assert(result[3].x == events[3].x);\n  assert(result[0].y == events[0].y);\n  assert(result[1].y == events[1].y);\n  assert(result[2].y == events[2].y);\n  assert(result[3].y == events[3].y);\n  assert(result[0].value == events[0].value);\n  assert(result[1].value == events[1].value);\n  assert(result[2].value == events[2].value);\n  assert(result[3].value == events[3].value);\n  assert(result[0].subtype == events[0].subtype);\n  assert(result[1].subtype == events[1].subtype);\n  assert(result[2].subtype == events[2].subtype);\n  assert(result[3].subtype == events[3].subtype);\n  assert(result[0].radius == events[0].radius);\n  assert(result[1].radius == events[1].radius);\n  assert(result[2].radius == events[2].radius);\n  assert(result[3].radius == events[3].radius);\n}\n    // fn affects_my_character(self, x: u8, y: u8) -> bool {\n    //     let distance = get_distance(self.x, self.y, x, y);\n    //     ((self.x == x) & (self.y == y)) | ((self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y))\n    // }\nimpl Event {\n    fn affects_my_obstacle(self, x: u8, y: u8) -> bool {\n        (self.x == x) & (self.y == y)\n    }\n\n    fn may_affect_my_other_characters(self) -> bool {\n        (self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL)\n    }\n\n    fn may_affect_my_obstacles(self) -> bool {\n        self.event == RECEIVE_ATTACK\n    }\n\n    /**\n    * For now we will only take class into account.\n    */\n    pub fn get_applied_damage_to_my_asset(self, x: u8, y: u8, tile: u8) -> u16 {\n        let mut damage = 0;\n        let radius = self.radius as u32;\n        let radius = radius * radius;\n        let distance = get_distance(self.x, self.y, x, y) as u32;\n    \n        if self.event == RECEIVE_ATTACK {\n            debug!(quote {\n                        // let event = self.event;\n                        // let actor = self.actor_id;\n                        // let self_x = self.x;\n                        // let self_y = self.y;\n                        // let val = self.value;\n                        // println(f\"GetAppliedDamageToMyAsset: Event({event}:{val} from {actor}@{self_x}|{self_y})@{x}|{y}: {distance} <= {radius}\");\n                    });\n            if distance <= radius {\n                let damage_raw = get_attack_damage_to_tile(self.subtype, self.value as u32, tile) as u32;\n                damage = damage_raw * (1 + radius - distance) / (radius + 1) as u32;\n                debug!(quote { println(f\"Deal damage: {damage_raw} * (1 + {radius} - {distance}) / ({radius} + 1) = {damage}\"); });\n            }\n            // if (self.x == x) & (self.y == y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile);\n            // } else if (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile) / 2;\n            // }\n        }\n        if self.event == TRIGGERED_TRAP {\n            damage = get_trap_damage_to_tile(self.value as u32, tile);\n        }\n        damage as u16\n    }\n\n    pub fn empty(actor_id: u8) -> Event {\n        Event {\n            event: NO_EVENT,\n            actor_id: actor_id,\n            x: 0,\n            y: 0,\n            value: 0,\n            subtype: 0,radius: 0\n        }\n    }\n\n    pub fn get_dummy_events() -> [Field; MAX_EVENTS] {\n        [0; MAX_EVENTS]\n    }\n\n    pub fn get_test_dummy_events() -> [Event; MAX_EVENTS] {\n        [Event::empty(0); MAX_EVENTS]\n    }\n}\n\npub fn build_std_event(event: u8, actor_id: u8, x: u8, y: u8) -> Event {\n    assert(event < EVENT_COUNT);\n    assert((actor_id as u32) < MAX_CHARACTERS);\n    assert((x < WIDTH) | (x == NOWHERE));\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: 0,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\n#[test]\nfn test_build_std_event() {\n    let event = build_std_event(SEE_MOVE, 1, 2, 3);\n    assert(event.event == SEE_MOVE);\n    assert(event.actor_id == 1);\n    assert(event.x == 2);\n    assert(event.y == 3);\n}\n\n#[test(should_fail)]\nfn test_build_std_event_fail() {\n    let event = build_std_event(EVENT_COUNT, 1, 2, 3);\n    assert(event.event == EVENT_COUNT);\n}\n\npub fn build_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8) -> Event {\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\npub fn build_subtype_value_event(event_type: u8, actor_id: u8, x: u8, y: u8, value: u8, event_subtype: u8, radius: u8) -> Event {\n    Event {\n        event: event_type,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: event_subtype,\n        radius: radius,\n    }\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/event.nr"},"76":{"source":"use arenalib::{ WIDTH, HEIGHT, WIDTH_MASK, VIEW_DISTANCE, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES };\nuse crate::obstacle::{ Obstacle, get_obstacle_y, get_obstacle_x, is_obstacle_traversible };\nuse skplg::NOWHERE;\nuse std::collections::bounded_vec;\n\n// pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> bool {\n//     // assert(curr_x < WIDTH);\n//     // assert(curr_y < HEIGHT);\n//     // assert(x < WIDTH);\n//     // assert(y < HEIGHT);\n//     // validating coordinates is not the job of this function\n//     // only avoid overflows!\n\n\n//     let shifted_curr_x = std::wrapping_add(curr_x, 1);\n//     let shifted_curr_y = std::wrapping_add(curr_y, 1);\n//     let shifted_x = std::wrapping_add(x, 1);\n//     let shifted_y = std::wrapping_add(y, 1);\n\n//     ((shifted_curr_x == shifted_x) & (std::wrapping_add(shifted_curr_y, 1) >= shifted_y) & (shifted_curr_y <= std::wrapping_add(shifted_y, 1))) |\n//     ((shifted_curr_y == shifted_y) & (std::wrapping_add(shifted_curr_x, 1) >= shifted_x) & (shifted_curr_x <= std::wrapping_add(shifted_x, 1)))\n// }\n\n// global DISTANCE_TABLE_HEIGHT: u32 = HEIGHT as u32;\n// global DISTANCE_TABLE_WIDTH: u32 = WIDTH as u32;\n\n// unconstrained fn distance_sqrt(x: u32) -> u32 {\n//     let mut result: u32 = 0;\n//     for i in 0..DISTANCE_TABLE_WIDTH {\n//         if i * i == x {\n//             result = i;\n//             break;\n//         }\n//     }\n//     result\n// }\n\n// fn d(a: u8, b: u8) -> u8 {\n//     let d = a as i32 - b as i32;\n//     let d2 = d * d;\n//     assert(d2 >= 0);\n//     let d2u = d2 as u32;\n//     let result = unsafe {\n//         let sq = distance_sqrt(d2u);\n//         assert(sq * sq == d2u);\n//         sq\n//     };\n//     assert(result < DISTANCE_TABLE_WIDTH);\n//     comptime { assert(DISTANCE_TABLE_WIDTH <= 256) };\n//     result as u8\n// }\n// global DISTANCE_TABLE: [[u8; DISTANCE_TABLE_WIDTH]; DISTANCE_TABLE_HEIGHT] = [\n//     [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 2,  2,  3,  4,  5,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ],\n//     [ 3,  3,  3,  4,  4,  5,  6,  7,  8,  9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ],\n// ]\n\nglobal MAX_DISTANCE: u32 = 0xff * 0xff;\npub type DISTANCE = u16;\nfn get_distance_part(curr: u8, target: u8) -> DISTANCE_PART_ROLLED_OUT {\n  let d = if curr > target { curr - target } else { target - curr } as u32;\n  d * d\n}\npub fn get_distance(curr_x: u8, curr_y: u8, x: u8, y: u8) -> DISTANCE {\n    // assert(curr_x < WIDTH);\n    // assert(curr_y < HEIGHT);\n    // assert(x < WIDTH);\n    // assert(y < HEIGHT);\n    // validating coordinates is not the job of this function\n    // only avoid overflows!\n\n    // let dx = unsafe {\n    //     let diff_\n    //     distance_sqrt(x)\n    // }\n\n    let dx = get_distance_part(curr_x, x);\n    let dy = get_distance_part(curr_y, y);\n\n    // let dx = curr_x as i16 - x as i16;\n    // let dy = curr_y as i16 - y as i16;\n  get_distance_from_parts(dx, dy)\n}\n// NOTE: Leaving it for now, but no actual performance benefit from splitting this\npub type DISTANCE_PART_ROLLED_OUT = u32;\nfn get_distance_from_parts(x: DISTANCE_PART_ROLLED_OUT, y: DISTANCE_PART_ROLLED_OUT) -> DISTANCE {\n  let distance = x + y;\n  if distance > MAX_DISTANCE {\n    MAX_DISTANCE as u16\n  } else {\n    distance as u16\n  }\n}\n\n\npub fn is_visible(enemy_advance: u8, x: u8) -> bool {\n    //(x >= enemy_advance) == (side == 0)\n    x >= enemy_advance\n}\n\n// TODO: This is for the future - fireballs, etc. only if we have line of sight\n// pub fn is_visible(curr_x: u8, curr_y: u8, x: u8, y: u8, map: &Map) -> bool {\n//     assert(curr_x < WIDTH);\n//     assert(curr_y < HEIGHT);\n//     assert(x < WIDTH);\n//     assert(y < HEIGHT);\n\n//     let mut x = curr_x as f32;\n//     let mut y = curr_y as f32;\n//     let x2 = x + 0.5;\n//     let y2 = y + 0.5;\n//     let dx = x2 - x;\n//     let dy = y2 - y;\n//     let mut t = 0.0;\n//     let mut max_t = 1.0;\n//     let mut x = x;\n//     let mut y = y;\n\n//     while t < max_t {\n//         let x = x + dx * t;\n//         let y = y + dy * t;\n//         let x = x as u8;\n//         let y = y as u8;\n\n//         if map.is_wall(x, y) {\n//             return false;\n//         }\n\n//         t += 0.1;\n//     }\n\n//     true\n// }\n\npub fn their_x_to_mine(x: u8) -> (bool, u8) {\n    if x == NOWHERE {\n        (true, NOWHERE)\n    } else {\n        (x < WIDTH, std::wrapping_sub(WIDTH - 1, x) & WIDTH_MASK)\n    }\n}\n\npub fn is_distance_within_viewing_range(distance: u16) -> bool {\n  distance <= (VIEW_DISTANCE as u16 * VIEW_DISTANCE as u16)\n}\n\npub fn is_tile_free_or_invisible(x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n  let mut can = true;\n  for i in 0..MAX_OBSTACLES {\n      if !is_obstacle_traversible(obstacles[i]) & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n      if !is_obstacle_traversible(their_obstacles[i]) & (get_obstacle_x(their_obstacles[i]) == x) & (get_obstacle_y(their_obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  can\n}\n\nglobal W: u32 = WIDTH as u32;\nglobal H: u32 = HEIGHT as u32;\nunconstrained fn _get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] {\n  let mut map = [[0; H]; W];\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  map\n}\n\nunconstrained fn _to_obstacle_collision_array(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [(u8, u8, bool); MAX_ENEMY_OBSTACLES * 2] {\n  let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i] = (x,y,is_obstacle_traversible(obstacle));\n\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  o\n}\n\npub fn get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] { // missing own chars\n  // Safety: verifying all map elements afterwards\n  let map = unsafe { _get_free_map(obstacles, their_obstacles) };\n  \n  // Safety: verifying all below\n  //let o = unsafe { _to_obstacle_collision_array(obstacles, their_obstacles) };\n   //let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n\n          if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //o[i] = (x,y,is_obstacle_traversible(obstacle));\n          // assert(o[i].0 == x);\n          // assert(o[i].1 == y);\n          // assert(o[i].2 == is_obstacle_traversible(obstacle));\n\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = their_obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //  o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n\n          // assert(o[i + MAX_ENEMY_OBSTACLES].0 == x);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].1 == y);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].2 == is_obstacle_traversible(obstacle));\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        let mut sum: u32 = 0;\n  for x in 0..WIDTH {\n    for y in 0..HEIGHT {\n      sum += map[x][y] as u32;\n      // let val = map[x][y];\n      // if !val {\n      //   let mut found_obstacle = false;\n\n      //   for i in 0..58 {\n      //     if (x == o[i].0) & (y == o[i].1) & o[i].2 {\n      //       found_obstacle = true;\n      //     }\n      //   }\n\n      //   assert(found_obstacle);\n      // }\n    }\n  }\n  let mut obstacle_sum: u32 = 0;\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    obstacle_sum += (!is_obstacle_traversible(obstacles[i])) as u32 + (!is_obstacle_traversible(their_obstacles[i])) as u32;\n  }\n  assert(sum == obstacle_sum);\n\n  map\n}\n\npub fn can_move_to(distance: u16, x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n    let mut can = is_distance_within_viewing_range(distance); //x <= advance;\n    can &= is_tile_free_or_invisible(x, y, obstacles, their_obstacles);\n\n    can\n}\n// pub fn their_x_to_mine(side: u1, x: i8) -> i8 {\n//     let mul = side as i8;\n//     mul * 31 + 16 + x\n// }\n\n// x * s -16 + y = 0 if s == 0 => y = 16\n// x * s -16 + y = 31 if s == 1 => x = 31\n// y = 31 * s + 16 + x\n// s = 0:\n// x = -16 => y = 0\n// x = 15 => y = 31\n// s = 1:\n// x = -16 => y = 31\n// x = 15 => y = 0\n\n// pub fn serialize_x(x: i8) -> (bool, u8) {\n//     let valid = (x >= -(WIDTH / 2) as i8) & (x < (WIDTH / 2) as i8);\n//     (valid, (x + (WIDTH / 2) as i8) as u8)\n// }\n\n// pub fn deserialize_x(x: u8) -> (bool, i8) {\n//     let valid = x < WIDTH;\n//     (valid, x as i8 - (WIDTH / 2) as i8)\n// }","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/map.nr"}},"names":["parse_their_events"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}