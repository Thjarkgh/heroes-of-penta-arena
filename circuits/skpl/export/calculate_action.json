{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13393861656300239421,"abi":{"parameters":[{"name":"action","type":{"kind":"struct","path":"arenalib::skpla::action::Action","fields":[{"name":"action_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}}]},"visibility":"private"},{"name":"my_chars","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"character::Character","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"class","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"progress","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"has_been_seen","type":{"kind":"boolean"}},{"name":"is_hidden","type":{"kind":"integer","sign":"unsigned","width":1}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"damage_mod","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"last_action","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actions","type":{"kind":"array","length":7,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}}]}},"visibility":"private"},{"name":"my_obstacles_parsed","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"},{"name":"enemy_objects_parsed","type":{"kind":"array","length":29,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"},{"name":"enemy_advance_input","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"energy","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"array","length":5,"type":{"kind":"struct","path":"character::Character","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"class","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"progress","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"has_been_seen","type":{"kind":"boolean"}},{"name":"is_hidden","type":{"kind":"integer","sign":"unsigned","width":1}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"damage_mod","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"last_action","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actions","type":{"kind":"array","length":7,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}}]}},{"kind":"array","length":24,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},{"kind":"integer","sign":"unsigned","width":8},{"kind":"struct","path":"event::Event","fields":[{"name":"event","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"subtype","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"radius","type":{"kind":"integer","sign":"unsigned","width":8}}]}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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WJjvaB4DyltAeQooLwHlIaC8A5RngPIKUB4ByhtAeQIoLwDlAaB7/3TPn+710z1+urdP9/TpXj7dw6d793TPnu7V0z16ujdP9+TpXjzdg6d773TPfWe+o/fY6d463VOne+l0D53undM9c7pXTvfI6d443ROne+F0D5zufdM9b7rXTfe46d423dOme9l0D5vuXdM9a7pXTfeo6d403ZOme9F0D5ruPdM9Z7rXTPeY6d4y3VOme8l0D5nuHf99zzj/0XvEdG+Y7gnTvWC6B0z3fumeL93rpXu8dG+X7unSvVy6h0v3bumeLd2rpXu0dG+W7snSvVi6B0v3XumeK91rpXusdG+V7qnSvVS6h0r3TumeKd0rpXukdG+U7onSvVC6B0r3PumeJ93rpHucdG+T7mnSvUy6h0n3LumeJd2rpHuUdG+S7knSvUi6B0n3HumeI91rpHuMdG+R7inSvUS6h0j3DumeId0rpHuEdG+Q7gnSvUC6B0j3/uieH93ro3t8dG+P7unRvTy6h0f37uieHd2ro3t0dG+O7snRvTi6B0f33uieG91ro3tsdG+N7qnRvTS6h0b3zuieGd0ro3tkdG+M7onRvTC6B0b3vuieF93rontcdG+L7mnRvSy6h0X3ruieFd2rontUdG+K7knRvSi6B0X3nuieE91rontMdG+J7inRvSS6h0T3juieEd0rontEdG+I7gnRvSC6B0T3fuieD93roXs8dG+H7unQvRy6h0P3buieDd2roXs0dG+G7snQvRi6B0P3XuieC91roXssdG+F7qnQvRS6h0L3TuieCd0roXskdG+E7onQvRC6B0L3PuieB93roHscdG+D7mnQvQy6h0H3LuieBd2roHsUdG+C7knQvQi6B0H3HuieA91roHsMdG+B7inQvQS6h0D3DuieAd0roHsEdG+A7gnQvQC6B0Dn/umcP53rp3P8dG6fzunTuXw6h0/n7umcPZ2rp3P0dG6ezsnTuXg6B0/n3umcO51rp3PsdG6dzqnTuXQ6h07nzumcOZ0rp3PkdG6czonTuXA6B07nvumcN53rpnPcdG6bzmnTuWw6h03nrumcNZ2rpnPUdG6azknTuWg6B03nnumcMy0A6BwznVumc8p0LpnOIdO547/PGRc4eo6Yzg3TOWE6F0zngOncL53zpXO9dI6Xzu3SOV06l0vncOnc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1DEVaHivJOOIDHOdNh+3TgsteDDNF+D0oACnh7Ammw9ck00DCnB6MpZItKejqOILAheFkNHKF4RncYjRfYpAHyJnDVPAfRh70H05FTxTkqrntJBOzXmJPebtArg2z4C1+djLVjOS5S5b0W7Os8n404jIXaKZEV8dPO3v7KD7ELk79iqwD8NcaSxATfRCvGz1mj/Rez040XuNCci/HsL9jgXAyd9rQFG+nowlF23Y5HheFVj2v5F3l/1HnxAvW83yjXF20BhnMcY4OwRjnAc0xllAY5ydjCUXbYzkeN4QMMY3lZ6fQMw2w75sNcc3xreCxjiHMca3/oe4nJfYc0wnJhqXmwM0xrfA5KLFR47nTQFjfDukZWOi9URy/U7Elzd0KepJAa7nRnwTjrT4jkC75ykdcGYWwp3pYqorMvub7w84C4IDznxmwFkQQhw+vhMTnf3NBzqhBclYciXEN19gRxzHRw8oH+/C+KjixWv8XcFYogKOqiA5eg8X782N5+g9n6Mwl/YwHRgvtIOvC33nvijo3Bcyzn1RCEt7xLtizn0hUKiLcEv7GtRnJMyd/vvqFE9KusiWi22pb0sDWxra0tiWprZcZksLWy635QpbrrTlKlva2tLelmts6WTLtbZ0taW7Lbm29LLleltusOVGW2625RZbbrXlNltut+VOW+6y5W5b7rHlXlvut+UBWx605WFbHrHlUVses+VxW5605SlbnrHlWVues+UFW8bb8qItL9nysi1TbHnFlum2zLTlNVvesGW2LXNseduWubbMt+VdWxbastiWJbZ8YMsyWz62ZbktK21ZZctqW9bast6WjbZstmWrLdtt2WnL57bstuUrW7625RtbvrXle1t+sOVHW36y5WdbfrXlN1v+sOUvW5JKWEdhS0FbTrCliC3FbClhS0lbStuSaku6LZm2ZNtyoi0n23KKLeVsqWDL6bacacvZtlS05VxbzrPFs6WKLdVsqWFLji0X2FLHlotsudiW+rY0sKWhLY1taWrLZba0sOVyW66w5UpbrrKlrS3tbbnGlk62XGtLV1u625JrSy9brrflBltutOVmW26x5VZbbrPldlvutOUuW+625R5b7rXlflsesOVBWx625RFbHrXlMVset+VJW56y5RlbnrXlOVtesGW8LS/a8pItL9syxZZXbJluy0xbXrPlDVtm2zLHlrdt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","debug_symbols":"7Z3bjvXIcWbfRde+YJ4z/SqDwUC25YEAQTJkeYCBMe8+lLv2oU12BCsrdjDjcNe2qjb5rX+TzIhKxvrP3/3LH/7pP/73//rjn//1L//+u3/8H//5uz/95Z9//7c//uXP+//1n78LubT/+v/++7/9/s9//3/8+99+/9e//e4fQw1b/4ff/eHP//Jf/x3r//uH3/3rH//0h9/9Yyv/73/+w99/r0/+3pj7vbpN/l6Y/L04+Xtp8vfy5O+Vyd+rk783+X2pk9+XOvl9aZPflzb5fWmT35c2+X1pk9+XNvl9aZPflzb5fWmT35c2+X3pk9+XPvl96ZPflz75femT35c++X3pk9+XPvl96ZPflz75fRmT35cx+X0Zk9+XMfl9GZPflzH5fRmT35cx+X0Zk9+XMfd9Kds2+Xth8vfi5O+lyd/Lk79XJn+vTv5em/y9Pvl7k9+XMPl9CZPflzD5fQmT35cw+X0Jk9+XMPl9CZPflzD5fQmT35c4+X2Jk9+XOPl9iZPflzj5fYmT35c4+X2Jk9+XOPl9iZPflzT5fUmT35c0+X1Jk9+XNPl9SZPflzT5fUmT35c0+X1Jk9+XPPl9yZPflzz5fcmT35c8+X3Jk9+XPPl9yZPflzz5fcmT35cy+X0pk9+XMvl9KZPflzL5fSmT35cy+X2Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs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sk8/LX768GOL5EXi751+GM+nbozI6af8/OSU28l3v8g+/br46bfHnSeV7eT0m+zT77JPf4g+/bytffolp+fpv40UeJ5+kH36UfbpJ9mnT/HUbSU8Viat5IKcfq2PdUD6lUntcUZluTOqy51RW+6MKJ5grT5OqL9NJBrb1yHGxw9B8mY4cojw+UNEkkM8Zoi965Seh0ifP0T+/CHK5w9Bcu/o/TF9q/VxGI+USV5iRg9CskZtj0fX+0i0J6zx8UPQvDMMHyIw/GvQvNML50ifP0T+/CEKx79G/XyO9vlDfP4KrzRjAsuzkxTGa7U8vv412sZxkMBxkMhxEJIxgWE8WoExvo3GfB4kcxykcBykchyE5mp/rBJri4dLkeatRvgQFFd7Dtvj65vD2w8/UJG8dYgehOJqT6Pl10GO/+gk7wWiB0kkB3n2K3LcTg6SOQ5SOA5SOQ5Csn4f41GI9G07rlFI3n5DDzIYDkLyfhp6kMBxkMhxkMRxkMxxkMJxkMpxEI4rfnBc8YPhii/bxnGQwHGQyHGQxHGQzHGQwnGQynGQxnGQznEQjis+cFzxgeOKDxxXfOC44gPHFR84rvjAccUHjis+cFzxgeOKjxxXfOS44iPHFR85rvjIccVHjis+clzxkeOKjxxXfOS44hPHFZ84rvjEccUnjis+cVzxieOKTxxXfOK44hPHFZ84rvjMccVnjis+c1zxmeOKzxxXfOa44jPHFZ85rvjMccVnjiu+cFzxheOKLxxXfOG44gvHFV84rvjCccUXjiu+cFzxheOKrxxXfOW44ivHFV85rvjKccVXjiu+clzxleOKrxxXfOW44hvHFd84rvjGccU3jiu+cVzxjeOKbxxXfOO44hvHFd84rvjOccV3jiu+c1zxneOK7xxXfOe44jvHFc+x565w7LkrHHvuCseeu8Kx565w7LkrHHvuCseeu8Kx565w7LkrHHvuCseeu8Kx565y7LmrHHvuKseeu8qx565umeMgheMgleMgjeMgneMgHFc8x567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnLsuasce+4qx567yrHnrnHsuWsce+4ax567xrHnrm2Z4yCF4yCV4yCN4yCd4yAcVzzHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeucey5axx77hrHnrvGseeuc+y56xx77jrHnrvOseeub5njIIXjIJXjII3jIJ3jIBxXPMeeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x565z7LnrHHvuOseeu86x525w7LkbHHvuBseeu8Gx525smeMgheMgleMgjeMgneMgHFc8x567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbHnbnDsuRsce+4Gx567wbDnLm0Me+72gwSOg0SOgySOg2SOgxSOg1SOgzSOg3SOg3Bc8YHjig8cV3zguOIDxxUfOK74wHHFB44rPnBc8YHjig8cV3zkuOIjxxUfOa74yHHFR44rPnJc8ZHjio8cV3zkuOIjxxWfOK74xHHFJ44rPnFc8Ynjik8cV3ziuOITxxWfOK74xHHFZ44rPnNc8Znjis8cV3zmuOIzxxWfOa74zHHFZ44rPnNc8YXjii8cV3zhuOILxxVfOK74wnHFF44rvnBc8YXjii8cV3zluOIrxxVfOa74ynHFV44rvnJc8ZXjiq8cV3zluOIrxxXfOK74xnHFN44rvnFc8Y3jim8cV3zjuOIbxxXfOK74xnHFd44rvnNc8Z3jiu8cV3znuOI7xxXfOa74znHFd44rvnNc8YPjih8cV/zguOIHxxU/OK74wXHFD44rfnBc8YPjiufYcxc49twFjj13gWPPXeDYcxe2zHGQwnGQynGQxnGQznEQjiueY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4NhzFzj23AWOPXeBY89d4Nhz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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"56":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"61":{"source":"// use crate::{ HEIGHT, WIDTH };\nuse arenalib::{ NO_EVENT, WAIT, SEE_MOVE, WIDTH, HEIGHT };\nuse arenalib::{ MAX_ACTIONS, MAX_OBSTACLES };\nuse arenalib::{ SERIALIZED_ACTION_BYTE_SIZE, SERIALIZED_ACTIONS_ARRAY_SIZE, SERIALIZED_ACTIONS_PER_FIELD, VIEW_DISTANCE };\nuse skplg::{softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD};\nuse arenalib::{Action, get_action_actor, get_action_target_x, get_action_target_y, get_action_type, new_action};\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\nuse crate::character::Character;\nuse crate::event::Event;\nuse crate::event::{ build_subtype_value_event }; // , build_value_event\nuse crate::map::{ is_visible, get_distance, can_move_to };\nuse crate::obstacle::Obstacle;\nuse crate::obstacle::{ get_default_obstacles };\nuse arenalib::{MAGE};\nuse arenalib::{MAX_ACTIONS_PER_CHARACTER, MAX_ENEMY_OBSTACLES, MAX_CHARACTERS};\n// use crate::ResolvedAction::ResolvedAction;\n// use crate::actionDefinition::{ build_move_action };\nuse arenalib::{apply_action_result_effects, apply_action_pre_calc_effects, validate_action_requirements, build_result_event};\nuse arenalib::arena_action_def_builder;\nuse super::{map::get_distance_from_parts, map::get_distance_part, map::is_distance_within_viewing_range, obstacle::new_obstacle, map::get_free_map};\nuse arenalib::MAX_HEALTH;\n\n// use crate::{ACTION_RESULT_COORDINATES_IDX_SELF, ACTION_RESULT_COORDINATES_IDX_TARGET, ACTION_RESULT_COORDINATES_IDX_INVISIBLE};\n// use crate::{SEE_CAST, SEE_DRAW, SEE_RITUAL, SEE_SEARCH_TRAP, RECEIVE_ATTACK, DISARMED_TRAP, ADD_OBSTACLE, WIN};\n// use crate::action_builder;\n\n\n\n// global ACTION_TYPE: u8 = 0;\n// global ACTION_ACTOR: u8 = 1;\n// global ACTION_TARGET_X: u8 = 2;\n// global ACTION_TARGET_Y: u8 = 3;\n\nglobal SEEN_EVENT_IDX: u32 = 1;\nglobal UNSEEN_EVENT_IDX: u32 = 0;\nglobal WORLD_EVENT_IDX: u32 = 2;\nglobal SELF_EVENT_IDX: u32 = 3;\n\npub fn execute_action(\n    action: Action,\n    enemy_advance: u8,\n    actor: Character,\n    mut energy: u8,\n    my_char_obstacles: [Obstacle; MAX_CHARACTERS],\n    my_obstacles: [Obstacle; MAX_OBSTACLES],\n    their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]\n) -> (bool, Event, Event, Event, Character, u8) /*where T: ResolvedAction */{\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    //let action_def = c.resolve_action(action.register[action.base_index + ACTION_TYPE]);\n        //let mut result_event: Event = build_std_event(NO_EVENT, c.id, 0, 0);\n        //let mut result_char = c;\n        //let mut required_energy = 0;\n        let mut is_valid = true;\n        //let action_def = c.resolve_action(get_action_type(action));\n        // let mut result_valid = true;\n\n        // let need_sneak = get_action_type(action) == SNEAK;\n        //let can_sneak = c.can_sneak();\n        // let need_move = get_action_type(action) == MOVE | get_action_type(action) == SNEAK;\n        // let can_move = can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles);\n        // let need_target_is_neighbor = get_action_type(action) == SNEAK | get_action_type(action) == MOVE | get_action_type(action) == ATTACK | get_action_type(action) == SEARCH | get_action_type(action) == DISARM_TRAP;\n        //let target_is_neighbor = is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        // let need_target_is_not_self = get_action_type(action) == ATTACK | get_action_type(action) == SHOOT;\n        // let target_is_not_self = (c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action));\n        // let need_ritual = get_action_type(action) == RITUAL;\n        //let can_ritual = c.can_ritual();\n        // let need_search = get_action_type(action) == SEARCH;\n        //let can_search = c.can_search();\n        //let can_attack = is_neighbor & not_self;\n        // let need_can_cast_fireball = get_action_type(action) == CAST_FIREBALL;\n        // let min_rounds_to_finish = if get_action_type(action) == CAST_FIREBALL {\n        //     FIREBALL_ROUNDS_FOR_CAST\n        // } else if get_action_type(action) == RITUAL {\n        //     RITUAL_ROUNDS_FOR_WIN\n        // } else if get_action_type(action) == SHOOT {\n        //     MIN_DRAW_ROUNDS_FOR_SHOOT\n        // } else {\n        //     0\n        // };\n        // let max_rounds_to_finish = if get_action_type(action) == CAST_FIREBALL {\n        //     FIREBALL_ROUNDS_FOR_CAST\n        // } else if get_action_type(action) == RITUAL {\n        //     RITUAL_ROUNDS_FOR_WIN\n        // } else if (get_action_type(action) == DRAW) | (get_action_type(action) == SHOOT) {\n        //     MAX_DRAW_ROUNDS_FOR_SHOOT\n        // } else {\n        //     0\n        // };\n        // let need_check_status = get_action_type(action) == CAST_FIREBALL | get_action_type(action) == RITUAL | get_action_type(action) == DRAW | get_action_type(action) == SHOOT;\n        // let can_cast_fireball = c.can_cast_fireball(); // & (result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        // let can_draw = c.can_shoot(); // & (c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        // let can_shoot = c.can_shoot(); // & (c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT);\n        // let can_disarm = c.can_disarm();\n        // let is_valid =\n        //     (get_action_type(action) == WAIT) |\n        //     ((get_action_type(action) == SNEAK) & can_sneak & can_move & target_is_neighbor) |\n        //     ((get_action_type(action) == MOVE) & can_move & target_is_neighbor) |\n        //     ((get_action_type(action) == RITUAL) & can_ritual) |\n        //     ((get_action_type(action) == SEARCH) & can_search & target_is_neighbor) |\n        //     ((get_action_type(action) == ATTACK) & target_is_neighbor & target_is_not_self) |\n        //     ((get_action_type(action) == CAST_FIREBALL) & can_cast_fireball & result_char.status <= max_rounds_to_finish) |\n        //     ((get_action_type(action) == DRAW) & can_draw) |\n        //     ((get_action_type(action) == SHOOT) & can_shoot & target_is_not_self) |\n        //     ((get_action_type(action) == DISARM_TRAP) & can_disarm & target_is_neighbor);\n\n\n\n\n        // need to adapt status first in case of action interruption!\n\n    //let action_type = action.get_action_type(action);\n    //let action_def = c.resolve_action(action_type);\n    let action_type = get_action_type(action);\n\n    let actor_id = actor.get_id();\n    let actor_x = actor.get_x();\n    let actor_y = actor.get_y();\n    let actor_target_x = actor.get_target_x();\n    let actor_target_y = actor.get_target_y();\n    let actor_last_action = actor.get_last_action();\n    let (action_def_valid, action_def) = actor.get_action(action_type);\n    softassert!(quote { is_valid }, quote { action_def_valid }, quote { f\"Failed to fetch action def of {action_type}\" });\n\n    let action_target_x = get_action_target_x(action);\n    let action_target_y = get_action_target_y(action);\n    let distance = get_distance(actor_x, actor_y, action_target_x, action_target_y);\n\n    // let is_continuous = action.get_action_is_continuous();\n    // let is_not_interrupted = (\n    //     ((!is_continuous) & (action.get_action_result_status_multiplier() != 0)) | // that's the ID of the wait action => leave status, but not continuous\n    //     ((is_continuous) & (action.get_action_req_previous_action() == c.last_action) & (action_target_x == c.get_target_x()) & (action_target_y == c.get_target_y()))\n    // );\n\n\n    let mut actor_progress = actor.get_progress();\n    let mut actor_is_hidden = actor.get_is_hidden() == 1;\n    let actor_is_in_view_range = is_visible(enemy_advance, actor_x);\n    // let max_range_part = get_action_req_max_range(action) as u16;\n    // let mut actor_max_range = max_range_part * max_range_part;\n    let mut is_not_interrupted = true;\n    let mut actor_damage_mod = actor.get_damage_mod();\n    let mut actor_status = actor.get_status();\n    // ~200 gates\n    apply_action_pre_calc_effects!(quote { action_def });\n\n    let mut obst = my_obstacles.as_slice();\n    for i in 0..MAX_CHARACTERS {\n      obst = obst.push_back(my_char_obstacles[i]);\n    }\n        let could_move_to_target = can_move_to(distance, action_target_x, action_target_y, obst.as_array(), their_obstacles);\n\n\n///////////////////////////\n    // ~4000 gates\n    validate_action_requirements!(quote { is_valid }, quote { action_def });\n    // // pub global ACTION_NEEDS_TARGET_FREE_SPACE: u8 = 0;  // u1\n    // let target_is_free_space_valid = !action.get_action_req_target_free_space() | can_move_to(distance, action_target_x, action_target_y, my_obstacles, their_obstacles);\n    // softassert!(quote { is_valid }, quote { target_is_free_space_valid }, quote { f\"Target space ({action_target_x},{action_target_y}) cannot be moved to: {VIEW_DISTANCE},{my_obstacles},{their_obstacles}\" });\n    \n    // // pub global ACTION_NEEDS_TARGET_IS_NOT_SELF: u8 = 1; // u1\n    // let target_is_not_self_valid = !action.get_action_req_target_is_not_self() | (c_x != action_target_x) | (c_y != action_target_y);\n    // softassert!(quote { is_valid }, quote { target_is_not_self_valid }, quote { f\"Target cannot be self ({action_target_x},{action_target_y})\" });\n\n    // // pub global ACTION_NEEDS_STATUS_HIDDEN: u8 = 4; // u1\n    // let char_is_hidden = c.is_hidden == 1;\n    // let char_is_hidden_valid = !action.get_action_req_status_hidden() | char_is_hidden;\n    // softassert!(quote { is_valid }, quote { char_is_hidden_valid }, quote { f\"Character needs to be hidden to perform action {action_type}\" });\n    \n    // // pub global ACTION_NEEDS_STATUS_VISIBLE: u8 = 2; // u1\n    // let char_is_in_view_range = is_visible(enemy_advance, c_x);\n    // let char_is_fully_visible = char_is_in_view_range & !char_is_hidden;\n    // let char_is_fully_visible_valid = !action.get_action_req_status_visible() | char_is_fully_visible;\n    // softassert!(quote { is_valid }, quote { char_is_fully_visible_valid }, quote { f\"Character must be fully visible for action {action_type}: in_view_range: {char_is_in_view_range} & !hidden {char_is_hidden} for enemy_advance {enemy_advance} @ {c_x}\" });\n\n    // // pub global ACTION_NEEDS_STATUS_INVISIBLE: u8 = 3; // u1\n    // let char_invisible_valid = !action.get_action_req_status_invisible() | !char_is_in_view_range | char_is_hidden;\n    // softassert!(quote { is_valid }, quote { char_invisible_valid }, quote { f\"Character must not be visible to perform action {action_type}: !in_view_range: {char_is_in_view_range} || hidden: {char_is_hidden} for enemy_advance {enemy_advance} @ {c_x}\" });\n\n    // // pub global ACTION_MAX_RANGE: u8 = 7; // u6 // TODO: max_range!\n    // let max_range_part = action.get_action_req_max_range() as u16;\n    // let max_range = max_range_part * max_range_part;\n    // let max_range_valid  = distance <= max_range;\n    // softassert!(quote { is_valid }, quote { max_range_valid }, quote { f\"Character is out of range! Distance: {distance} > {max_range}: {{{c_x},{c_y}}} - {{{action_target_x},{action_target_y}}} with {max_range_part}\" });\n\n    // // pub global ACTION_NEEDS_MIN_STATUS: u8 = 8; // u4\n    // let min_status = action.get_action_req_min_status();\n    // let min_status_valid = min_status <= status;\n    // softassert!(quote { is_valid }, quote { min_status_valid }, quote { f\"Character needs min status {min_status} to perform action {action_type}, but only has {status}\" });\n\n    // // pub global ACTION_NEEDS_MAX_STATUS: u8 = 9; // u4\n    // let max_status = action.get_action_req_max_status();\n    // let max_status_valid = max_status >= status;\n    // softassert!(quote { is_valid }, quote { max_status_valid }, quote { f\"Character cannot have a higher status than {max_status} to perform action {action_type}: got {status}\" });\n\n    // // pub global ACTION_NEEDED_ENERGY: u8 = 10;    // u4\n    // let required_energy = action.get_action_req_energy();\n    // let energy_valid = required_energy <= energy;\n    // softassert!(quote { is_valid }, quote { energy_valid }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {required_energy}\" });\n    //////////////////////\n    \n\n        let coords = [\n            (actor_x, actor_y),\n            (action_target_x, action_target_y),\n            (NOWHERE, NOWHERE),\n        ];\n\n    // pub global ACTION_RESULT_STATUS_MULTIPLIER: u8 =     ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT;     // u1\n    // pub global ACTION_RESULT_STATUS_FIXED_ADDITION: u8 = ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 1; // u4\n    // pub global ACTION_MOVE_TO_TARGET: u8 =               ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 2; // u1\n    // pub global ACTION_SETS_STATUS_HIDDEN: u8 = 5; // u1\n    // pub global ACTION_REMOVES_STATUS_HIDDEN: u8 = 6; // u1\n\n        // CALCULATE EVENTS\n        comptime {\n          assert(SEEN_EVENT_IDX == 1);\n          assert(UNSEEN_EVENT_IDX == 0);\n        }\n        //let result_event_idx = is_visible as u32;\n        let mut events: BoundedVec<Event, 4> = BoundedVec::new();\n        // 19000 gates\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        build_result_event!(0 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(1 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(2 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(3 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        assert(events.len() == 4);\n\n        // let seen_event_value = status as u32 * action.get_action_result_event_seen_value_status_multiplier() as u32 + action.get_action_result_event_seen_value_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { seen_event_value <= 255 as u32 }, quote { f\"Invalid event value (seen): {seen_event_value} does not fit in u8!\" });\n\n        // let unseen_event_value = status as u32 * action.get_action_result_event_not_seen_value_status_multiplier() as u32 + action.get_action_result_event_not_seen_value_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { unseen_event_value <= 255 as u32 }, quote { f\"Invalid event value (unseen): {unseen_event_value} does not fit in u8!\" });\n\n        // let seen_event_coords_idx = action.get_action_result_event_seen_coord_idx();\n        // softassert!(quote { is_valid }, quote { seen_event_coords_idx < 4 }, quote { f\"Invalid seen event coord idx: {seen_event_coords_idx} > 3\" });\n\n        // let seen_event_coords = coords[seen_event_coords_idx & 3];\n\n        // let unseen_event_coords_idx = action.get_action_result_event_not_seen_coord_idx();\n        // softassert!(quote { is_valid }, quote { unseen_event_coords_idx < 4 }, quote { f\"Invalid unseen event coord idx: {unseen_event_coords_idx} > 3\" });\n\n        // let unseen_event_coords = coords[unseen_event_coords_idx & 3];\n\n        // //let events = [\n        // let dummy_event =    build_subtype_value_event(NO_EVENT, c.get_id(), coords[ACTION_RESULT_COORDINATES_IDX_INVISIBLE].0, coords[ACTION_RESULT_COORDINATES_IDX_INVISIBLE].1, 0 as u8, 0 as u8, 0 as u8);\n        // let unseen_event =    build_subtype_value_event(\n        //         action.get_action_result_event_not_seen_type(),\n        //         c.get_id(), \n        //         unseen_event_coords.0,\n        //         unseen_event_coords.1,\n        //         unseen_event_value as u8,\n        //         action.get_action_result_event_not_seen_subtype(),\n        //         action.get_action_result_event_not_seen_radius()\n        //     );\n        // let seen_event =    build_subtype_value_event(\n        //         action.get_action_result_event_seen_type(),\n        //         c.get_id(), \n        //         seen_event_coords.0,\n        //         seen_event_coords.1,\n        //         seen_event_value as u8,\n        //         action.get_action_result_event_seen_subtype(),\n        //         action.get_action_result_event_seen_radius()\n        //     );\n        //];\n\n\n        // APPLY EFFECTS ON SELF\n        let mut result_energy = energy;\n        let mut result_coords = coords[0];\n        let mut result_progress = actor_progress;\n        let mut result_is_hidden = actor_is_hidden;\n        let mut result_is_visible = actor_is_in_view_range;\n        let mut result_damage_mod = actor_damage_mod;\n        let mut result_health = actor.get_health();\n        let mut result_status = actor_status;\n\n\n        // let energy = std::wrapping_sub(energy, action.get_action_req_energy());\n        // let status = actor_progress as u32 * action.get_action_result_status_multiplier() as u32 + action.get_action_result_status_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { status <= MAX_STATUS as u32 }, quote { f\"Invalid result status: {status} > {MAX_STATUS}\" });\n\n        // let final_coords = coords[action.get_action_move_to_target() as u8];\n        // // debug!(quote { println(f\"final_coords:{final_coords}\"); });\n        // let is_hidden = ((c.is_hidden == 1) & !action.get_action_result_effect_removes_status_hidden()) | action.get_action_result_effect_sets_status_hidden();\n        // let is_visible = !is_hidden & is_visible(enemy_advance, final_coords.0);\n        // 200 gates\n        apply_action_result_effects!(quote { action_def });\n\n// let result_coord_src = action_def[6] as u8;\n// let result_coord_src_fixed = result_coord_src & 4 as u8;\n// let result_coord = result_coord_src_fixed != 0 as u8;\n// let result_coord_cast = result_coord as u8;\n// println(f\"result coords: {result_coord_src} {result_coord_src_fixed} {result_coord} {result_coord_cast}\");\n// result_coords = coords[((action_def[6]as u8 / 4 as u8) == 1 as u8)as u8];\n        // let target_coords = [\n        //     (target_x, target_y),\n        //     (c.get_target_x(), c.get_target_y())\n        // ];\n\n        // actor.x = result_coords.0;\n        // actor.y = result_coords.1;\n        // actor.progress = result_progress;\n        // actor.is_hidden = result_is_hidden as u1;\n        // actor.has_been_seen = result_is_visible;\n        // actor.last_action = is_not_interrupted as u8 * actor.get_last_action() + (!is_not_interrupted) as u8 * action_type;\n        // actor.target_x = is_not_interrupted as u8 * actor.get_target_x() + (!is_not_interrupted) as u8 * action_target_x;\n        // actor.target_y = is_not_interrupted as u8 * actor.get_target_y() + (!is_not_interrupted) as u8 * action_target_y;\n        // actor.damage_mod = result_damage_mod;\n        // actor.health = result_health;\n        // actor.status = result_status;\n\n        (\n            is_valid,\n            if result_is_visible { events.get_unchecked(SEEN_EVENT_IDX) } else { events.get_unchecked(UNSEEN_EVENT_IDX) },//events[1 + (is_visible as u8)],\n            events.get_unchecked(WORLD_EVENT_IDX),\n            events.get_unchecked(SELF_EVENT_IDX),//events[get_action_unseen_event_is_internal(action_def) as u8],\n            Character {\n                id: actor_id,\n                x: result_coords.0,\n                y: result_coords.1,\n                progress: result_progress, // status as u8,\n                is_hidden: result_is_hidden as u1, //is_hidden as u1,\n                has_been_seen: result_is_visible, //is_visible,\n                last_action: is_not_interrupted as u8 * actor.get_last_action() + (!is_not_interrupted) as u8 * action_type,\n                target_x: is_not_interrupted as u8 * actor.get_target_x() + (!is_not_interrupted) as u8 * action_target_x, // if is_not_interrupted { c.get_target_x() } else { get_action_target_x(action) };\n                target_y: is_not_interrupted as u8 * actor.get_target_y() + (!is_not_interrupted) as u8 * action_target_y,\n                class: actor.class,\n                damage_mod: result_damage_mod,\n                health: result_health,\n                status: result_status,\n                actions: actor.actions,\n            },\n            result_energy\n        )\n\n        // if get_action_type(action) == SNEAK {\n        //     //assert(c.can_sneak());\n        //     if !can_sneak { let actor_id = c.id; println(f\"Failed to execute action: Character {actor_id} cannot sneak\"); }\n        //     //assert(can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles));\n        //     //assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_sneak() & can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles) & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.x = get_action_target_x(action);  \n        //     result_char.y = get_action_target_y(action);\n        //     result_char.status = 0;\n        //     required_energy = c.get_energy_per_sneak();\n        // }\n        // if get_action_type(action) == MOVE {\n        //     // assert(can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles));\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles) & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.x = get_action_target_x(action);\n        //     result_char.y = get_action_target_y(action);\n        //     result_char.status = 0;\n        //     required_energy = c.get_energy_per_move();\n        //     result_char.has_been_seen = is_visible(enemy_advance, result_char.x);\n        //     if c.get_has_been_seen() {\n        //         result_event = build_std_event(SEE_MOVE, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     }\n        // }\n        // if get_action_type(action) == RITUAL {\n        //     //assert(c.can_ritual());\n        //     // result_valid = c.can_ritual();\n        //     result_char.status += 1;\n        //     if result_char.status >= RITUAL_ROUNDS_FOR_WIN {\n        //         result_event = build_std_event(WIN, c.id, 0, 0);\n        //     } else {\n        //         result_event = build_std_event(SEE_RITUAL, c.id, 0, 0);\n        //     }\n        //     required_energy = c.get_energy_per_ritual();\n        // }\n        // if get_action_type(action) == SEARCH {\n        //     // assert(c.can_search());\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_search() & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.status = 0;\n        //     result_event = build_std_event(SEE_SEARCH_TRAP, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     required_energy = c.get_energy_per_search();\n        // }\n        // if get_action_type(action) == ATTACK {\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // assert((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     // result_valid = is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)) & ((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     result_char.status = 0;\n        //     result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_MELEE), ATTACK_MELEE);\n        //     required_energy = c.get_energy_per_attack();\n        // }\n        // // TODO: global SET_TRAP = 6 as u8;\n        // if get_action_type(action) == CAST_FIREBALL {\n        //     // assert(c.can_cast_fireball());\n        //     result_char.status += 1;\n        //     // assert(result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        //     // result_valid = c.can_cast_fireball() & (result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        //     if result_char.status >= FIREBALL_ROUNDS_FOR_CAST {\n        //         // TODO: handle friendly fire and destruction of own walls and own traps\n        //         result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_FIREBALL), ATTACK_FIREBALL);\n        //     } else {\n        //         if c.get_has_been_seen() {\n        //             result_event = build_subtype_value_event(SEE_CAST, c.id, get_action_target_x(action), get_action_target_y(action), 0, ATTACK_FIREBALL);\n        //         }\n        //     }\n        //     required_energy = c.get_energy_per_cast();\n        // }\n        // if get_action_type(action) == DRAW {\n        //     // assert(c.can_shoot());\n        //     // assert(c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        //     // result_valid = c.can_shoot() & (c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        //     result_char.status += 1;\n        //     if c.get_has_been_seen() {\n        //         result_event = build_std_event(SEE_DRAW, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     }\n        //     required_energy = c.get_energy_per_draw();\n        // }\n        // if get_action_type(action) == SHOOT {\n        //     // assert(c.can_shoot());\n        //     // assert(c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT);\n        //     // assert((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     // result_valid = c.can_shoot() & (c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT) & ((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     result_char.status = 0;\n        //     // TODO: check distance! abs(c.x - get_action_target_x(action)) + abs(c.y - get_action_target_y(action)) <= c.get_shoot_range()\n        //     result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_RANGED), ATTACK_RANGED);\n        //     required_energy = c.get_energy_per_shoot();\n\n        // }\n        // // TODO: SET_TRAP\n        // if get_action_type(action) == DISARM_TRAP {\n        //     // assert(c.can_disarm());\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_disarm() & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.status = 0;\n        //     result_event = build_std_event(DESTROY, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     required_energy = c.get_energy_per_disarm();\n        // }\n        \n        // // assert(energy >= required_energy);\n        // let result_valid = is_valid & (energy >= required_energy);\n        // if result_valid {\n        //     energy -= required_energy;\n        // }\n        // // energy -= required_energy;\n        // (result_valid, result_event, result_char, energy)\n    }\n//}\n\n//global test_actions: [TestActionDefinition; 1] = [\n    // build_test_action_def!(build_wait_action_def(), quote { 0, 1, 3, 4 }),\n    //TestActionDefinition { register: build_test_action_def!(build_wait_action_def()), action: new_action(0, 1, 3, 4) },\n    // build_move_action(class_energy_per_move[ARCHER]),\n    //     build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n    //     build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n    //     build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n    //     build_wait_action_def(),\n    //     ,\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[RITUALIST]),\n    //     build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n    //     build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n    //     build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[ROGUE]),\n    //     build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n    //     build_sneak_action(class_energy_per_sneak[ROGUE]),\n    //     build_search_action(class_energy_per_search[ROGUE], 1),\n    //     build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n    //     build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[KNIGHT]),\n    //     build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[MAGE]),\n    //     build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n    //     build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n    //     build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, FIREBALL_ROUNDS_FOR_CAST, FIREBALL_ROUNDS_FOR_CAST),\n    //     build_wait_action_def(),\n    //     build_wait_action_def()\n    // ]\n// ]\n\n// pub fn create_test_action(action: Action) -> TestActionDefinition {\n//     TestActionDefinition {\n//         register: \n//     }\n// }\n\n// pub struct TestActionDefinition {\n//     pub register: [u8; ACTION_DEFINITION_SIZE],\n//     pub action: Action,\n// }\n\n// impl ResolvedAction for TestActionDefinition {\n//     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n//     }\n//     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n//     }\n//     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n//     }\n//     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n//     }\n//     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_MAX_RANGE]\n//     }\n//     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_MIN_STATUS]\n//     }\n//     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_MAX_STATUS]\n//     }\n//     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDED_ENERGY]\n//     }\n//     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_EVENT_IS_TRAP] == 1\n//     }\n//     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n//     }\n//     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n//     }\n//     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n//     }\n//     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n//     }\n//     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n//     }\n//     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n//     }\n//     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n//     }\n//     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n//     }\n//     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n//     }\n//     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n//     }\n//     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n//     }\n//     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n//         self.register[ACTION_MOVE_TO_TARGET] as u1\n//     }\n//     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_IS_CONTINUOUS] == 1\n//     }\n//     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n//     }\n\n//     fn get_action_target_x(self) -> u8 {\n//         get_action_target_x(self.action)\n//     }\n//     fn get_action_target_y(self) -> u8 {\n//         get_action_target_y(self.action)\n//     }\n//     fn get_action_type(self) -> u8 {\n//         get_action_type(self.action)\n//     }\n// }\n\n#[test]\nfn test_execute_action() {\n  // global action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// let action_builder = get_arena_action_def_builder();\n    let action_def = arena_action_def_builder.build_move_action(4); //, quote { 1, 2, 3, 4 }; //new_action(1, 2, 3, 4);\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n    let action = new_action(1, 2, 3, 4);\n    let their_advance = 30;\n    let mut actions = [[0; 32]; MAX_ACTIONS_PER_CHARACTER + 1];\n    actions[1] = action_def;\n    let actor = Character {\n        id: 2,\n        x: 2,\n        y: 4,\n        target_x: 0,\n        target_y: 0,\n        health: MAX_HEALTH,\n        damage_mod: 1,\n        last_action: WAIT,\n        class: MAGE,\n        is_hidden: 0 as u1,\n        has_been_seen: true,\n        progress: 0,\n        status: 0,\n        actions: actions\n    };\n    let energy = 15;\n    let my_obstacles = get_default_obstacles(0);\n    let (no_obstacle_valid, no_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, MAX_HEALTH, 0);\n    let mut mco: [Obstacle] = &[];\n    for i in 0..MAX_CHARACTERS {\n      let (co_valid, co) = new_obstacle(i as u8, i as u8, HEIGHT - 1, MAX_HEALTH, i as u8 + 1);\n      assert(co_valid);\n      mco = mco.push_back(co);\n    }\n    assert(no_obstacle_valid);\n    let their_obstacles = get_default_obstacles(1).as_slice().push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle);\n    let (valid, event, _, internal_event, c, result_energy) = execute_action(\n        action,\n        their_advance,\n        actor,\n        energy,\n        mco.as_array(),\n        my_obstacles,\n        their_obstacles.as_array()\n    );\n    assert(valid, \"valid\");\n    assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n    assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n    assert(event.x == get_action_target_x(action), f\"{event}.target_x is not action target x\");\n    assert(event.y == get_action_target_y(action), f\"{event}.target_y is not action target y\");\n    assert(c.x == event.x, f\"{c}.x is not event {event}.x\");\n    assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n    assert(result_energy == 11, f\"{result_energy} != 11\");\n}\n\n\n\npub fn parse_actions(fields: [Field; SERIALIZED_ACTIONS_ARRAY_SIZE]) -> [Action; MAX_ACTIONS] {\n    comptime {\n        assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_ACTIONS_PER_FIELD * SERIALIZED_ACTION_BYTE_SIZE <= 32);\n        assert(SERIALIZED_ACTIONS_ARRAY_SIZE * SERIALIZED_ACTIONS_PER_FIELD == MAX_ACTIONS);\n        assert(SERIALIZED_ACTION_BYTE_SIZE >= 4);\n    }\n\n    let mut actions: [Action] = &[];\n    for i in 0..SERIALIZED_ACTIONS_ARRAY_SIZE {\n        let split: [u8; 32] = fields[i].to_be_bytes::<32>();\n        //assert(split.len() == 32);\n        for j in 0..SERIALIZED_ACTIONS_PER_FIELD {\n            let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_ACTION_BYTE_SIZE;\n            actions = actions.push_back(new_action(\n                split[offset],\n                split[offset + 1],\n                split[offset + 2],\n                split[offset + 3],\n            ));\n            /*Action {\n                action: split[offset],\n                actor: split[offset + 1],\n                target_x: split[offset + 2],\n                target_y: split[offset + 3],\n            }*/\n        }\n    }\n    actions.as_array()\n}\n\nglobal H: u32 = HEIGHT as u32;\nglobal W: u32 = WIDTH as u32;\n/**\n* Warning: This function can throw!!!\n*/\n// pub fn serialize_actions(actions: [Action]) -> [Field; SERIALIZED_ACTIONS_ARRAY_SIZE] {\n//     comptime {\n//         assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_ACTIONS_PER_FIELD * SERIALIZED_ACTION_BYTE_SIZE <= 32);\n//         assert(SERIALIZED_ACTIONS_ARRAY_SIZE * SERIALIZED_ACTIONS_PER_FIELD == MAX_ACTIONS);\n//         assert(SERIALIZED_ACTION_BYTE_SIZE >= 4);\n//     }\n\n//     assert(actions.len() <= MAX_ACTIONS);\n\n//     let mut actions_stuffed: [Action; MAX_ACTIONS] = [new_action(WAIT, 0, 0, 0); MAX_ACTIONS];\n//     for i in 0..actions.len() {\n//         actions_stuffed[i] = actions[i];\n//     }\n\n//     let mut fields: [Field] = &[];\n//     for i in 0..SERIALIZED_ACTIONS_ARRAY_SIZE {\n//         let mut data: [u8; 32] = [0; 32];\n//         for j in 0..SERIALIZED_ACTIONS_PER_FIELD {\n//             let index = i * SERIALIZED_ACTIONS_PER_FIELD + j;\n//             let action = actions_stuffed[index];\n//             let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_ACTION_BYTE_SIZE;\n//             data[offset] = get_action_type(action);\n//             data[offset + 1] = get_action_actor(action);\n//             data[offset + 2] = get_action_target_x(action);\n//             data[offset + 3] = get_action_target_y(action);\n//         }\n//         fields = fields.push_back(std::field::bytes32_to_field(data));\n//     }\n//     fields.as_array()\n// }\n\n#[export]\npub fn get_performable_actions(actor: Character,\n    enemy_advance: u8, energy: u8,\n    my_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES],\n    their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]\n    // action_type: u8\n) -> pub [[Field; H]; MAX_ACTIONS_PER_CHARACTER + 1] {\n  // assert(action_type as u32 <= (MAX_ACTIONS_PER_CHARACTER + 1));\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n  let mut result = [[0; H]; MAX_ACTIONS_PER_CHARACTER + 1];\n\n  let actor_id = actor.get_id();\n  let actor_x = actor.get_x();\n  let actor_y = actor.get_y();\n  let actor_target_x = actor.get_target_x();\n  let actor_target_y = actor.get_target_y();\n  let actor_last_action = actor.get_last_action();\n\n  let actor_is_in_view_range = is_visible(enemy_advance, actor_x);\n  let map = get_free_map(my_obstacles, their_obstacles);\n\n  for action_target_y in 0..HEIGHT {\n    let mut row = [[0 as u8; W]; MAX_ACTIONS_PER_CHARACTER + 1];\n    // let dy = get_distance_part(actor.get_y(), action_target_y);\n    for action_target_x in 0..WIDTH {\n      let distance = get_distance(actor.get_x(), actor.get_y(), action_target_x, action_target_y);\n      // let dx = get_distance_part(actor.get_x(), action_target_x);\n      // let distance = get_distance_from_parts(dx, dy);\n      //let could_move_to_target = can_move_to(distance, action_target_x, action_target_y, my_obstacles, their_obstacles);\n      let could_move_to_target = is_distance_within_viewing_range(distance) & (0 == map[action_target_x][action_target_y]);\n      for action_type in 0..(MAX_ACTIONS_PER_CHARACTER + 1) {\n        let mut is_valid = true;\n        let mut actor_progress = actor.get_progress();\n        let mut actor_is_hidden = actor.get_is_hidden() == 1;\n        let mut is_not_interrupted = true;\n        let mut actor_damage_mod = actor.get_damage_mod();\n        let mut actor_status = actor.get_status();\n        let action_def = actor.actions[action_type];\n        apply_action_pre_calc_effects!(quote { action_def });\n    //        action_def_def(quote { pre_calc_effect_continues_action }, 3, |continued_action|quote { let continues_action: bool = $continued_action as u8 == actor_last_action; }),\n    // action_def_def(quote { pre_calc_effect_is_continuous }, 1, |is_continuous|quote { let is_continuous: bool = $is_continuous as bool; }),\n    // action_def_def(quote { pre_calc_effect_interrupts }, 1, |is_interrupting|quote { let is_interrupting: bool = $is_interrupting as bool; }),\n    // action_def_def(quote { pre_calc_effect_allow_retargeting }, 1, |allows_retargetting|quote { let not_interrupted_through_retargeting: bool = $allows_retargetting as bool | ((action_target_x == actor_target_x) & (action_target_y == actor_target_y)); })\n\n        validate_action_requirements!(quote { is_valid }, quote { action_def });\n        let coords = [\n            (actor_x, actor_y),\n            (action_target_x, action_target_y),\n            (NOWHERE, NOWHERE),\n        ];\n        // let mut result_energy = energy;\n        // let mut result_coords = coords[0];\n        // let mut result_progress = actor_progress;\n        // let mut result_is_hidden = actor_is_hidden;\n        // let mut result_is_visible = actor_is_in_view_range;\n        // let mut result_damage_mod = actor_damage_mod;\n        // let mut result_health = actor.get_health();\n        // let mut result_status = actor_status;\n        //apply_action_result_effects!(quote { action_def });\n        row[action_type][action_target_x] = is_valid as u8;\n      }\n    }\n    for action_type in 0..(MAX_ACTIONS_PER_CHARACTER + 1) {\n      result[action_type][action_target_y] = std::field::bytes32_to_field(row[action_type]);\n    }\n  }\n\n  result\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/action.nr"},"72":{"source":"\nuse arenalib::ARCHER;\nuse arenalib::KNIGHT;\nuse arenalib::MAGE;\nuse arenalib::RITUALIST;\nuse arenalib::ROGUE;\nuse arenalib::WIDTH;\nuse arenalib::HEIGHT;\nuse arenalib::{ CLASS_COUNT, PROGRESS_COUNT };\nuse arenalib::{ WAIT }; //, ATTACK_MELEE, ATTACK_FIREBALL, ATTACK_RANGED, MAX_FIREBALL_ROUNDS_FOR_CAST, MIN_FIREBALL_ROUNDS_FOR_CAST, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS, MAX_OBSTACLES, MAX_ACTIONS_PER_CHARACTER };\nuse arenalib::{ WIDTH_MASK, HEIGHT_MASK, CLASS_MASK, PROGRESS_MASK };\nuse arenalib::{ WIDTH_BITS, HEIGHT_BITS, CLASS_BITS, PROGRESS_BITS };\nuse crate::event::Event;\nuse crate::map::is_visible;\nuse crate::obstacle::Obstacle;\nuse crate::obstacle::new_obstacle;\nuse skplg::{NOWHERE, debug, softassert};\nuse arenalib::{ActionDefinition};\nuse arenalib::{SerializedArenaCharacterRoster, SerializedArenaActionDefinitions, SerializedArenaCharacterActionDefinitions, SerializedArenaCharacterActionDefinition};\n// use arenalib::{TRAP, ADD_OBSTACLE, WIN_BY_RITUAL, RITUAL_ROUNDS_FOR_WIN};\nuse arenalib::get_test_action_register;\nuse crate::event::{build_subtype_value_event, serialize_events};\nuse arenalib::NO_EVENT;\nuse arenalib::get_wait_action_def;\n\n\npub global SERIALIZED_CHARACTER_BYTES: u32 = 6;\npub type SerializedCharacter = [u8; SERIALIZED_CHARACTER_BYTES];\n\n// use skplam::{build_wait_action_def, build_shoot_action, build_draw_action, build_move_action, build_attack_action, build_cast_action, build_evocation_action, build_search_action, build_set_trap_action, build_sneak_action, build_ritual_action, build_disarm_trap_action};\n\n// this should be more efficient: for all the following: order is: UNKNOWN_CLASS, ARCHER, RITUALIST, ROGUE, KNIGHT, MAGE\nglobal class_damage_melee: [u8; 6] = [ 0, 32, 8, 24, 40, 16 ];\nglobal class_damage_ranged: [u8; 6] = [ 0, 24, 40, 16, 32, 8 ];\nglobal class_damage_fireball: [u8; 6] = [ 0, 0, 100, 50, 0, 100 ];\nglobal class_damage: [[u8; 6]; 3] = [ class_damage_melee, class_damage_ranged, class_damage_fireball ];\nglobal class_energy_per_attack: [u8; 6] = [ 0, 7, 7, 7, 6, 7 ];\nglobal class_energy_per_cast: [u8; 6] = [ 0, 255, 12, 255, 255, 6 ];\nglobal class_energy_per_disarm: [u8; 6] = [ 0, 255, 255, 12, 255, 255 ];\nglobal class_energy_per_move: [u8; 6] = [ 0, 3, 4, 3, 4, 4 ];\nglobal class_energy_per_ritual: [u8; 6] = [ 0, 255, 12, 255, 255, 255 ];\nglobal class_energy_per_search: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_sneak: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_draw: [u8; 6] = [ 0, 9, 255, 255, 255, 255 ];\nglobal class_energy_per_shoot: [u8; 6] = [ 0, 6, 255, 255, 255, 255 ];\nglobal resistances: [u16; 8 * 3] = [\n     0,  75, 100, 85,  50, 100, 20,  0, //,  255, 255, 0, 0, 0, 255, 255, 255 ], // Melee vs dummy, archer, ritualist, thief, knight, mage, wall, water, unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n     0,  80, 100, 90,  25, 100,  5,  0, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Ranged vs dummy, archer, ritualist, thief, knight, mage, wall, water\n     0,  80, 100, 90, 100,  90, 60, 50, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Fireball vs dummy, archer, ritualist, thief, knight, mage, wall, water\n];\n\nglobal trap_resistances: [u16; 8] = [ 0,  75, 100, 50,  75, 90, 5, 0]; //,  255, 255, 255, 255, 255, 255, 255, 255 ]; // Trap vs dummy, archer, ritualist, thief, knight, mage\n\n\n//global x: ActionDefinition = build_set_trap_action(1 as u8, 1 as u8);\n// TODO: move to character!\n// global ARCHER: u8 = 1;    WAIT, MOVE, ATTACK, DRAW, SHOOT\n// global RITUALIST: u8 = 2; WAIT, MOVE, ATTACK, CAST, RITUAL\n// global ROGUE: u8 = 3;     WAIT, MOVE, ATTACK, SNEAK, SEARCH, DISARM_TRAP, SET_TRAP\n// global KNIGHT: u8 = 4;    WAIT, MOVE, ATTACK\n// global MAGE: u8 = 5;      WAIT, MOVE, ATTACK, CAST, CAST_FIREBALL\n// global ACTION_DEFINITIONS: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER * CLASS_COUNT] = [\n//     // [[0 as u8; ACTION_DEFINITION_SIZE]; MAX_ACTIONS_PER_CHARACTER], // 0 for no action\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n    \n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ARCHER]),\n//         build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//         build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//         build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[RITUALIST]),\n//         build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//         build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//         build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ROGUE]),\n//         build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//         build_sneak_action(class_energy_per_sneak[ROGUE]),\n//         build_search_action(class_energy_per_search[ROGUE], 1),\n//         build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[KNIGHT]),\n//         build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[MAGE]),\n//         build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//         build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//         build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, FIREBALL_ROUNDS_FOR_CAST, FIREBALL_ROUNDS_FOR_CAST),\n//         WAIT_ACTION,\n//         WAIT_ACTION\n//     // ]\n// ];\n// global \n// pub fn get_test_action_register() -> [u8; ACTION_DEFINITION_REGISTER_SIZE] {\n//     build_action_def_reg!([\n//         [\n//             build_move_action(class_energy_per_move[ARCHER]),\n//             build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//             build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//             build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[RITUALIST]),\n//             build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//             build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//             build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[ROGUE]),\n//             build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//             build_sneak_action(class_energy_per_sneak[ROGUE]),\n//             build_search_action(class_energy_per_search[ROGUE], 1),\n//             build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//             build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[KNIGHT]),\n//             build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[MAGE]),\n//             build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//             build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//             build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST),\n//             build_wait_action_def(),\n//             build_wait_action_def()\n//         ]\n//     ])\n// }\n// pub fn get_test_action_register() -> SerializedArenaActionDefinitions {\n//   let action_builder = arena_action_def_builder;\n//      [\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER)),\n//             std::field::bytes32_to_field(action_builder.build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT)), // arche),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n            \n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST, 255)),\n//             std::field::bytes32_to_field(action_builder.build_ritual_action(3, class_energy_per_ritual[RITUALIST], RITUAL_ROUNDS_FOR_WIN, WIN_BY_RITUAL)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_sneak_action(class_energy_per_sneak[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_search_action(class_energy_per_search[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_set_trap_action(class_energy_per_disarm[ROGUE], 1, ADD_OBSTACLE, TRAP)),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[KNIGHT])),\n//            std::field::bytes32_to_field( action_builder.build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT])),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[MAGE], MAGE, 7)),\n//             std::field::bytes32_to_field(action_builder.build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def())\n//         ]\n// }\n\n// struct CharacterClass {\n//     class: u8,\n//     damage: u8,\n//     energy_per_attack: u8,\n//     energy_per_cast: u8,\n//     energy_per_disarm: u8,\n//     energy_per_move: u8,\n//     energy_per_ritual: u8,\n//     energy_per_search: u8,\n//     energy_per_sneak: u8,\n// }\n\npub struct Character {\n    pub id: u8,\n    pub x: u8, // 5 bit\n    pub y: u8, // 4 bit\n    pub class: u8, // 3 bit\n    pub progress: u8, // 0 = idle, 1-15 = continuing action => 4 bit\n    pub health: u8,\n    pub has_been_seen: bool,\n    pub is_hidden: u1,\n    pub target_x: u8,\n    pub target_y: u8,\n    pub damage_mod: u8,\n    pub last_action: u8,\n    pub status: u8,\n    // pub wait_action: ActionDefinition,\n    pub actions: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1], // BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER>,\n}\n\n// pub fn resolve_action(action: u8, class: u8) -> ActionDefinition {\n//     let mut idx = class as u32 * MAX_ACTIONS_PER_CHARACTER + action as u32;\n//     if idx >= (ACTION_DEFINITIONS.len()) {\n//         idx = 0;\n//     }\n//     // assert(action as u32 < MAX_ACTIONS_PER_CHARACTER);\n//     // assert(class as u32 < CLASS_COUNT);\n//     ACTION_DEFINITIONS[idx]\n// }\n//     pub fn resolve_action(action: Action) -> ActionDefinition {\n//         // let idx = get_action_base_index(self.get_id(), action);\n//         ActionDefinition::new(action, ACTION_DEFINITIONS)\n// //        (idx, ACTION_DEFINITIONS)\n//         //resolve_action(action, self.class)\n//         // let mut a = action as u32;\n//         // if a >= self.actions.len() { a = 0; }\n//         // self.actions[a] //.get_unchecked(a)\n//     }\n//global wait_action: ActionDefinition = buld_wait_action_def();\n\n// global wait_action: ActionDefinition = action_builder.build_wait_action_def();\n\nimpl Character {\n    // pub fn new(id: u8 x: u8, y: u8, class: u8, status: u8, health: u8, has_been_seen: u8)\n    /// May throw\n\n\n    pub fn get_id(self) -> u8 {\n        self.id\n    }\n\n    pub fn get_x(self) -> u8 {\n        self.x\n    }\n\n    pub fn get_y(self) -> u8 {\n        self.y\n    }\n\n    pub fn get_class(self) -> u8 {\n        self.class\n    }\n\n    pub fn get_progress(self) -> u8 {\n        self.progress\n    }\n\n    pub fn get_status(self) -> u8 {\n        self.status\n    }\n\n    pub fn get_health(self) -> u8 {\n        self.health\n    }\n\n    pub fn get_has_been_seen(self) -> bool {\n        self.has_been_seen\n    }\n\n    pub fn get_target_x(self) -> u8 {\n        self.target_x\n    }\n\n    pub fn get_target_y(self) -> u8 {\n        self.target_y\n    }\n\n    pub fn get_is_hidden(self) -> u1 {\n      self.is_hidden\n    }\n\n    pub fn get_damage_mod(self) -> u8 {\n      self.damage_mod\n    }\n\n    pub fn get_action(self, action_idx: u8) -> (bool, ActionDefinition) {\n      /*if action_idx == 0 {\n        (true, self.wait_action)\n      } else */if action_idx <= MAX_ACTIONS_PER_CHARACTER as u8 {\n        (true, self.actions[action_idx])\n      } else {\n        (false, self.actions[0])\n      }\n    }\n\n    // pub fn get_energy_per_attack(self) -> u8 {\n    //     class_energy_per_attack[self.class]\n    // }\n\n    // pub fn get_energy_per_cast(self) -> u8 {\n    //     class_energy_per_cast[self.class]\n    // }\n\n    // pub fn get_energy_per_disarm(self) -> u8 {\n    //     class_energy_per_disarm[self.class]\n    // }\n\n    // pub fn get_energy_per_move(self) -> u8 {\n    //     class_energy_per_move[self.class]\n    // }\n\n    // pub fn get_energy_per_ritual(self) -> u8 {\n    //     class_energy_per_ritual[self.class]\n    // }\n\n    // pub fn get_energy_per_search(self) -> u8 {\n    //     class_energy_per_search[self.class]\n    // }\n\n    // pub fn get_energy_per_sneak(self) -> u8 {\n    //     class_energy_per_sneak[self.class]\n    // }\n\n    // pub fn get_energy_per_draw(self) -> u8 {\n    //     class_energy_per_draw[self.class]\n    // }\n\n    // pub fn get_energy_per_shoot(self) -> u8 {\n    //     class_energy_per_shoot[self.class]\n    // }\n\n    // pub fn get_damage(self, attack_type: u8) -> u8 {\n    //     self.damage_mod + class_damage[attack_type][self.class]\n    // }\n\n    pub fn get_last_action(self) -> u8 {\n      self.last_action\n    }\n\n    // pub fn can_sneak(self) -> bool {\n    //     class_energy_per_sneak[self.class] != 255\n    // }\n\n    // pub fn can_ritual(self) -> bool {\n    //     class_energy_per_ritual[self.class] != 255\n    // }\n\n    // pub fn can_cast_fireball(self) -> bool {\n    //     class_energy_per_cast[self.class] != 255\n    // }\n\n    pub fn can_shoot(self) -> bool {\n        self.class == ARCHER\n    }\n    // pub fn can_disarm(self) -> bool {\n    //     class_energy_per_disarm[self.class] != 255\n    // }\n\n    // pub fn can_search(self) -> bool {\n    //     class_energy_per_search[self.class] != 255\n    // }\n\n    fn is_pos_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_target_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_class_valid(class: u8) -> bool { class as u32 <= CLASS_COUNT }\n    fn is_status_valid(status: u8) -> bool { status < PROGRESS_COUNT }\n\n    pub fn is_valid(self) -> bool {\n        Character::is_pos_valid(self.x, self.y) &\n        Character::is_target_valid(self.target_x, self.target_y) &\n        Character::is_class_valid(self.class) &\n        Character::is_status_valid(self.progress)\n    }\n\n    pub fn serialize(self) -> (SerializedCharacter, SerializedArenaCharacterActionDefinitions) {\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n        assert(self.is_valid());\n        let packed_x = self.x + (self.class << WIDTH_BITS);\n        let packed_y = self.y + (self.progress << HEIGHT_BITS);\n        let packed_target_x = (self.target_x & WIDTH_MASK) + ((self.is_hidden as u8) << WIDTH_BITS);\n        let packed_target_y = (self.target_y & HEIGHT_MASK) + ((self.last_action as u8) << HEIGHT_BITS);\n\n        // let serialized_action_defs = self.actions.map(|a|std::field::bytes32_to_field(a));\n        let serialized_action_defs = [\n          std::field::bytes32_to_field(self.actions[1]),\n          std::field::bytes32_to_field(self.actions[2]),\n          std::field::bytes32_to_field(self.actions[3]),\n          std::field::bytes32_to_field(self.actions[4]),\n          std::field::bytes32_to_field(self.actions[5]),\n          std::field::bytes32_to_field(self.actions[6])\n        ];\n        \n        ([packed_x, packed_y, self.health, packed_target_x, packed_target_y, self.damage_mod], serialized_action_defs)\n    }\n\n    pub fn to_obstacle(self) -> (bool, Obstacle) {\n        comptime {\n            assert(MAX_CHARACTERS < (255 - MAX_OBSTACLES));\n        }\n        assert(self.is_valid());\n        new_obstacle(self.id + (MAX_OBSTACLES as u8), self.x, self.y, self.health, self.class)\n        // Obstacle {\n        //     id: self.id + (MAX_CHARACTERS as u8),\n        //     x: self.x,\n        //     y: self.y,\n        //     obstacle_type: self.class,\n        //     health: self.health,\n        //     //was_alive: \n        // }\n    }\n\n    pub fn move(self, x: u8, y: u8) -> Character {\n        let mut c = self;\n        c.x = x;\n        c.y = y;\n        c\n    }\n\n    pub fn take_damage(self, attack_type: u8, dmg: u8) -> Character {\n        let damage_after_resistances = get_attack_damage_to_tile(attack_type, dmg as u32, self.class);\n        let mut c = self;\n        if damage_after_resistances > (c.health as u32) {\n            c.health = 0;\n        } else {\n            c.health -= (damage_after_resistances as u8);\n        }\n        c\n    }\n\n    pub fn set_status(self, status: u8) -> Character {\n        assert(status < PROGRESS_COUNT);\n        let mut c = self;\n        c.progress = status;\n        c\n    }\n\n    pub fn create_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n        // let mut actions: BoundedVec<ActionDefinition, 6> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..6 {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions.push(ACTION_DEFINITIONS[idx + i]);\n        //     }\n        // }\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: 0,\n            health: 0,\n            has_been_seen: false,\n            is_hidden: 0,\n            target_x: 255,\n            target_y: 255,\n            damage_mod: 0,//: class_damage[class],\n            last_action: WAIT,\n            status: 0, // TODO: status\n            actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1]// BoundedVec::new()\n        };\n        assert(c.is_valid());\n        c\n    }\n\n    pub fn parse(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool, Character) {\n        // these asserts could be disabled for production\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n\n      let (is_valid, c) = parse_unconstrained(id, data, actions_data, wait_action, events, enemy_advance);\n      // assert(c.)\n\n        assert(c.is_valid());\n        (is_valid, c)\n    }\n}\n\nfn parse_unconstrained(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool,Character) {\n          let mut is_valid = true;\n\n        let split: [u8; 32] = data.to_be_bytes::<32>();\n        assert(split.len() == 32);\n        let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n        let y_packed = split[2 + id * 6 + 1]; // 4 bit y, 4 bit status\n        let mut health = split[2 + id * 6 + 2] as u16;\n        let target_x_packed = split[2 + id * 6 + 3]; // 5 bit target x, 1 bit hidden, 1 bit has target, 1 bit unused\n        let target_y_packed = split[2 + id * 6 + 4]; // 4 bit target y, 4 bit last action\n        let damage_mod = split[2 + id * 6 + 5]; // last byte: for the moment, use to save damage_mod (buffs, etc)\n\n        let x = x_packed & WIDTH_MASK;\n        let y = y_packed & HEIGHT_MASK;\n        let mut class = (x_packed >> WIDTH_BITS) & CLASS_MASK;\n        if !Character::is_class_valid(class) {\n            debug!(quote { println(f\"Invalid class {class}\"); });\n            class = 0;\n            is_valid = false;\n        }\n\n        let progress = (y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n        softassert!(quote { is_valid }, quote { Character::is_status_valid(progress) }, quote { f\"Invalid status {progress} during character parsing {id}\" });\n\n        let target_x = target_x_packed & WIDTH_MASK;\n        let target_y = target_y_packed & HEIGHT_MASK;\n        let last_action = (target_y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n\n        let is_visible = is_visible(enemy_advance, x); //((target_x_packed >> 5) & 1) as u1;\n        let is_hidden = ((target_x_packed >> WIDTH_BITS) & 1) as u1;\n\n        let mut damage: u16 = 0;\n        for i in 0..MAX_EVENTS {\n            let event = events[i];\n            damage += event.get_applied_damage_to_my_asset(x, y, class);\n            // if events[i].actor_id == id {\n            //     let event = events[i];\n            //     if event.actor_id == id {\n            //         damage += event.get_applied_damage_to_my_asset(x, y, class);\n            //     }\n            // }\n        }\n        if damage > health {\n            health = 0;\n        } else {\n            health -= damage;\n        }\n\n        // let mut actions = [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]; //: BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..MAX_ACTIONS_PER_CHARACTER {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions[i] = ACTION_DEFINITIONS[idx + i];\n        //     }\n        // }\n\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: progress,\n            health: health as u8,\n            has_been_seen: is_visible, // TODO \n            is_hidden: is_hidden,\n            target_x: target_x,\n            target_y: target_y,\n            damage_mod: damage_mod,\n            last_action: last_action,\n            actions: [\n              wait_action,\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 1].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 2].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 3].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 4].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 5].to_be_bytes::<32>()\n            ],\n            status: 0 // TODO: status\n        };\n        (is_valid, c)\n}\n\n// unconstrained fn create_character_unconstrained(\n//   id: u8,\n//   x: u8,\n//   y: u8,\n//   class: u8,\n//   progress: u8,\n//   health: u8,\n//   has_been_seen: u8\n// )\n\nfn select_action_defs_of_character(actions: SerializedArenaActionDefinitions, char_id: u32) -> [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1] {\n  let mut result: [SerializedArenaCharacterActionDefinition] = &[std::field::bytes32_to_field(get_wait_action_def())];\n  let offset = char_id * MAX_ACTIONS_PER_CHARACTER;\n  for i in 0..MAX_ACTIONS_PER_CHARACTER {\n    result = result.push_back(actions[offset + i]);\n  }\n  result.as_array().map(|f|f.to_be_bytes())\n}\n\npub fn get_default_characters(side: u8) -> [Character; MAX_CHARACTERS] {\n    assert(side < 2, f\"Side is too large {side}\");\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n    let default_actions = get_test_action_register();\n\n    let x = |x| x * ((side + 1) % 2) + (WIDTH - 1 - x) * side;\n    [\n        Character { id: 0, x: x(2), y: 2, class: ARCHER, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 1), status: 0 },\n        Character { id: 1, x: x(2), y: 3, class: RITUALIST, health: 60, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 2), status: 0 },\n        Character { id: 2, x: x(2), y: 4, class: ROGUE, health: 80, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 3), status: 0 },\n        Character { id: 3, x: x(2), y: 5, class: KNIGHT, health: 120, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 4), status: 0 },\n        Character { id: 4, x: x(2), y: 6, class: MAGE, health: 40, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 5), status: 0 },\n    ]\n}\n\n#[export]\npub fn parse_characters(data: SerializedArenaCharacterRoster, actions_data: SerializedArenaActionDefinitions, events: [Event; MAX_EVENTS], enemy_advance: u8) -> pub (bool, [Character; MAX_CHARACTERS]) {\n    comptime { assert(MAX_CHARACTERS == 5); }\n\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut is_valid = true;\n\n    let wait_action = get_wait_action_def();\n\n    // no need to optimize, compiler automatically rolls this out\n    // let mut result: [Character; MAX_CHARACTERS] = [Character::create_character(0, 0, 0, 0), Character::create_character(1, 0, 0, 0), Character::create_character(2, 0, 0, 0), Character::create_character(3, 0, 0, 0), Character::create_character(4, 0, 0, 0)];\n    // for i in 0..(MAX_CHARACTERS as u8) {\n    //     let (curr_valid, curr_c) = Character::parse(i, data, actions_data, wait_action, events, enemy_advance);\n    //     is_valid &= curr_valid;\n    //     result[i] = curr_c;\n    // }\n\n        let (curr_valid, curr_c0) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[0] = curr_c0;\n        let (curr_valid, curr_c1) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[1] = curr_c1;\n        let (curr_valid, curr_c2) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[2] = curr_c2;\n        let (curr_valid, curr_c3) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[3] = curr_c3;\n        let (curr_valid, curr_c4) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[4] = curr_c4;\n    let result = [curr_c0, curr_c1, curr_c2, curr_c3, curr_c4];\n    (is_valid, result)\n}\n\npub fn get_test_my_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 100,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\npub fn get_test_their_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 255,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\n#[test]\nfn test_serialize_character() {\n    let mut character = Character {\n        id: 4,\n        x: 21,\n        y: 9,\n        class: 5,\n        progress: 9,\n        health: 129,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 31,\n        target_y: 9,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    };\n    let (field, _) = character.serialize();\n    assert(field[0] == (21 | (5 << 5)));\n    assert(field[1] == (9 | (9 << 4)));\n    assert(field[2] == 129);\n    assert(field[3] == 31); // TODO: why?\n    assert(field[4] == 9);\n    assert(field[5] == 0);\n}\n\n#[test]\nfn test_parse_character() {\n    let dummy_events = Event::get_test_dummy_events();\n    let data_array: [u8; 32] = [\n        0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        191 as u8, 249 as u8, 255 as u8, 255 as u8, 9 as u8, 255 as u8,\n        181 as u8, 153 as u8, 129 as u8, 127 as u8, 9 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n    ];\n    let data: Field = std::field::bytes32_to_field(data_array);\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    println(data);\n    assert(data == 0xbff9ffff09ffb599817f0900000000000000, f\"Failed assumption: data: {data} != 0xbff9ffff09ffb599817f0900000000000000\");\n    let (character_valid, character) = Character::parse(3, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_valid);\n    assert(character.get_id() == 3);\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 9);\n    assert(character.get_class() == 5);\n    assert(character.get_progress() == 9);\n    assert(character.get_health() == 129);\n    assert(character.get_has_been_seen());\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n\n    let (character_max_valid, character_max) = Character::parse(2, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_max_valid);\n    assert(character_max.get_id() == 2);\n    assert(character_max.get_x() == 31);\n    assert(character_max.get_y() == 9);\n    assert(character_max.get_class() == 5);\n    assert(character_max.get_progress() == 15);\n    assert(character_max.get_health() == 255);\n    assert(character_max.get_has_been_seen());\n    assert(character_max.get_target_x() == 31);\n    assert(character_max.get_target_y() == 9);\n\n    let (character_min_valid, character_min) = Character::parse(0, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_min_valid);\n    assert(character_min.get_id() == 0);\n    assert(character_min.get_x() == 0);\n    assert(character_min.get_y() == 0);\n    assert(character_min.get_class() == 0);\n    assert(character_min.get_progress() == 0);\n    assert(character_min.get_health() == 0);\n    assert(character_min.get_has_been_seen() == false);\n    assert(character_min.get_target_x() == 0);\n    assert(character_min.get_target_y() == 0);\n}\n\n#[test]\nfn test_parse_character_as_in_game() {\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    let data: Field = 0x1602ff1f09001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00;\n    let (character_valid, character) = Character::parse(0, data, dummy_actions, wait_action, Event::get_test_dummy_events(), 20);\n    assert(character_valid);\n    assert(character.get_id() == 0);\n    assert(character.get_x() == 22, character.get_x());\n    assert(character.get_y() == 2, character.get_y());\n    assert(character.get_class() == 0, character.get_class());\n    assert(character.get_progress() == 0, character.get_progress());\n    assert(character.get_health() == 255);\n    assert(character.get_has_been_seen() == true);\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n}\n\n#[export]\npub fn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> pub (Field, SerializedArenaActionDefinitions) {\n    let mut result: [u8; 32] = [0; 32];\n    let mut actions: SerializedArenaActionDefinitions = [0; 30]; //&[].as_array();\n    for i in 0..MAX_CHARACTERS {\n        let (serialized_char_bytes, serialized_actions) = chars[i].serialize();\n        for j in 0..6 {\n            result[2 + i * 6 + j] = serialized_char_bytes[j];\n        }\n        for k in 0..MAX_ACTIONS_PER_CHARACTER {\n          actions[i * MAX_ACTIONS_PER_CHARACTER + k] = serialized_actions[k];\n        }\n    }\n    \n    (std::field::bytes32_to_field(result), actions)\n}\n\n/**\n* For now we will only take class into account.\n*/\npub fn get_attack_damage_to_tile(attack_type: u8, damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * resistances[attack_type * 8 + (class & 7)] as u32 / 100) as u32\n}\n\npub fn get_trap_damage_to_tile(damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * trap_resistances[class & 7] as u32 / 100) as u32\n}\n\n#[test]\nfn test_parse_character_round0() {\n  // let actions_data = .map(|f|f.to_be_bytes::<32>()).map(|f|std::field::bytes32_to_field(f));\n  let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let enemy_advance = 0x00;\n  let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0)\n  ];\n  let serialized_events = serialize_events(events);\n   println(f\"events: {serialized_events}\");\n\n  let parsed = parse_characters(data, [\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071020100a000020100a00000020000000002000000000000000,\n    0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n    0x023100081b161118120a010018120a01000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071008100a000008100a00000020000000002000000000000000,\n    0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n    0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071018100a000018100a00000020000000002000000000000000,\n    0x09f0000130060c002000000000200000000020000000002000000000000000,\n    0xf00001100610001005000100100500010020000000002000000000000000,\n    0xf00001301c0100100d000000100d00000020000000002000000000000000,\n    0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110061028100a000028100a00000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071010100a000010100a00000020000000002000000000000000,\n    0xf000071b1611002000000000000705000020000000002000000000000000,\n    0x6300061b161164150a020164150a02010020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000\n], events, enemy_advance);\n\n  assert(parsed.0);\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/character.nr"},"74":{"source":"use arenalib::{ NO_EVENT, SEE_MOVE, RECEIVE_ATTACK, TRIGGERED_TRAP }; //, SEE_RITUAL, SEE_CAST, SEE_DRAW, SEE_SEARCH_TRAP, FOUND_TRAP\n// use crate::{ EMPTY, WALL };\nuse arenalib::{ EVENT_COUNT };\nuse arenalib::{ ATTACK_FIREBALL };\nuse arenalib::{ SERIALIZED_EVENT_BYTE_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD };\nuse arenalib::{ WIDTH };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS }; //, MAX_TRAPS\nuse arenalib::SerializedArenaEvents;\n// use crate::TRAPS_BUFFER_MASK;\nuse crate::map::get_distance;\n// use crate::character::Character;\nuse crate::character::{ get_attack_damage_to_tile, get_trap_damage_to_tile };\nuse crate::map::their_x_to_mine;\nuse skplg::{ debug, softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD };\n\n// TODO: THIS SHOULD BE GENERATED WITH MACRO!\n// pub global NO_EVENT: u8 = 0 ;\n// pub global DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n// //pub global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n// //pub global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\n// pub global SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n// //pub global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\n// pub global SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\n// pub global SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// pub global RECEIVE_EFFECT: u8 = 9;   //NOTE: NEW: This is to be used for status effecting things! actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\n// pub global RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\n// pub global TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\n// // pub global FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\n// pub global DISARMED_TRAP: u8 = 13;      // actor_id = their-char when receive - need to remove my trap from the map\n// pub global WIN: u8 = 14;\n// // pub global LOSE: u8 = 15;\n// pub global ADD_OBSTACLE: u8 = 4;\n// pub global EVENT_COUNT: u8 = 16;\n\npub global EVENT_SUBTYPE_COUNT: u32 = 16;\npub global EVENT_ARRAY_SIZE: u32 = EVENT_COUNT as u32;\nglobal AFFECTS_HEALTH: u8 = 1;\nglobal AFFECTS_STATUS: u8 = 2;\nglobal AFFECTS_PROGRESS_ADD: u8 = 3;\nglobal AFFECTS_PROGRESS_SUB: u8 = 3;\npub global EVENT_DEFINITIONS: [[u8; EVENT_SUBTYPE_COUNT]; EVENT_ARRAY_SIZE] = [\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  0 NO_EVENT\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  1 DESTROY (not implemented)\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  2 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  3 SEE_MOVE\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  4 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  5 SEE_SEARCH_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  6 SEE_RITUAL\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  7 SEE_CAST\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  8 SEE_DRAW\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  9 RECEIVE_EFFECT\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 10 RECEIVE_ATTACK\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 11 TRIGGERED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 12 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 13 DISARMED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 14 WIN\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  // 15 ?\n];\nglobal EVENT_DEF_SIGN_ADD: u8 = 0;\nglobal EVENT_DEF_SIGN_SUB: u8 = 1;\npub global EVENT_DEFINITION_SIGNS: [[u8; EVENT_SUBTYPE_COUNT]; EVENT_ARRAY_SIZE] = [\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  0 NO_EVENT\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  1 DESTROY (not implemented)\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  2 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  3 SEE_MOVE\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  4 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  5 SEE_SEARCH_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  6 SEE_RITUAL\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  7 SEE_CAST\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  8 SEE_DRAW\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], //  9 RECEIVE_EFFECT\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 10 RECEIVE_ATTACK\n  [ AFFECTS_HEALTH, AFFECTS_HEALTH, AFFECTS_HEALTH, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 11 TRIGGERED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 12 ?\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 13 DISARMED_TRAP\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 14 WIN\n  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  // 15 ?\n];\n\npub struct Event {\n    pub event: u8,\n    pub actor_id: u8,\n    pub subtype: u8,\n    pub x: u8,\n    pub y: u8,\n    pub value: u8,\n    pub radius: u8,\n}\n\n\n    #[export]\n    pub fn parse_their_events(fields: SerializedArenaEvents) -> pub (bool, [Event; MAX_EVENTS]) {\n        comptime {\n            assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENT_BYTE_SIZE <= 32);\n            assert(SERIALIZED_EVENTS_ARRAY_SIZE * SERIALIZED_EVENTS_PER_FIELD == MAX_EVENTS);\n            assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n        }\n\n        let mut valid = true;\n        let mut events: [Event; MAX_EVENTS] = [Event::empty(0); MAX_EVENTS];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let split: [u8; 32] = fields[i].to_be_bytes::<32>(); //.to_be_bytes<32>();\n            //assert(split.len() == 32);\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                let raw_x = split[offset + 2];\n                let (x_parsed_valid, x_parsed) = their_x_to_mine(raw_x);\n                softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to calculate their_x_to_mine: {raw_x}\" });\n                events[i * SERIALIZED_EVENTS_PER_FIELD + j] = Event {\n                    event: split[offset],\n                    actor_id: split[offset + 1],\n                    x: x_parsed,\n                    y: split[offset + 3],\n                    value: split[offset + 4],\n                    subtype: split[offset + 5],\n                    radius: split[offset + 6],\n                };\n            }\n        }\n        (valid, events)\n    }\n    \n    #[export]\n    pub fn serialize_events(events: [Event; MAX_EVENTS]) -> pub SerializedArenaEvents {\n        assert(events.len() == MAX_EVENTS);\n        assert(MAX_EVENTS % SERIALIZED_EVENTS_PER_FIELD == 0);\n        assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n\n        let mut fields: [Field] = &[];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let mut data: [u8; 32] = [0; 32];\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let index = i * SERIALIZED_EVENTS_PER_FIELD + j;\n                let event = events[index];\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                data[offset] = event.event;\n                data[offset + 1] = event.actor_id;\n                data[offset + 2] = event.x;\n                data[offset + 3] = event.y;\n                data[offset + 4] = event.value;\n                data[offset + 5] = event.subtype;\n                data[offset + 6] = event.radius;\n            }\n            fields = fields.push_back(std::field::bytes32_to_field(data));\n        }\n        fields.as_array()\n    }\n    \n#[test]\nfn test_event_serde() {\n    let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 5, NO_EVENT, 1),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 6, NO_EVENT, 2),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 7, NO_EVENT, 3),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 8, NO_EVENT, 4)\n  ];\n\n  let serialized = serialize_events(events);\n  let (result_valid, result) = parse_their_events(serialized);\n  assert(result_valid);\n  assert(result[0].event == events[0].event);\n  assert(result[1].event == events[1].event);\n  assert(result[2].event == events[2].event);\n  assert(result[3].event == events[3].event);\n  assert(result[0].actor_id == events[0].actor_id);\n  assert(result[1].actor_id == events[1].actor_id);\n  assert(result[2].actor_id == events[2].actor_id);\n  assert(result[3].actor_id == events[3].actor_id);\n  assert(result[0].x == events[0].x);\n  assert(result[1].x == events[1].x);\n  assert(result[2].x == events[2].x);\n  assert(result[3].x == events[3].x);\n  assert(result[0].y == events[0].y);\n  assert(result[1].y == events[1].y);\n  assert(result[2].y == events[2].y);\n  assert(result[3].y == events[3].y);\n  assert(result[0].value == events[0].value);\n  assert(result[1].value == events[1].value);\n  assert(result[2].value == events[2].value);\n  assert(result[3].value == events[3].value);\n  assert(result[0].subtype == events[0].subtype);\n  assert(result[1].subtype == events[1].subtype);\n  assert(result[2].subtype == events[2].subtype);\n  assert(result[3].subtype == events[3].subtype);\n  assert(result[0].radius == events[0].radius);\n  assert(result[1].radius == events[1].radius);\n  assert(result[2].radius == events[2].radius);\n  assert(result[3].radius == events[3].radius);\n}\n    // fn affects_my_character(self, x: u8, y: u8) -> bool {\n    //     let distance = get_distance(self.x, self.y, x, y);\n    //     ((self.x == x) & (self.y == y)) | ((self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y))\n    // }\nimpl Event {\n    fn affects_my_obstacle(self, x: u8, y: u8) -> bool {\n        (self.x == x) & (self.y == y)\n    }\n\n    fn may_affect_my_other_characters(self) -> bool {\n        (self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL)\n    }\n\n    fn may_affect_my_obstacles(self) -> bool {\n        self.event == RECEIVE_ATTACK\n    }\n\n    /**\n    * For now we will only take class into account.\n    */\n    pub fn get_applied_damage_to_my_asset(self, x: u8, y: u8, tile: u8) -> u16 {\n        let mut damage = 0;\n        let radius = self.radius as u32;\n        let radius = radius * radius;\n        let distance = get_distance(self.x, self.y, x, y) as u32;\n    \n        if self.event == RECEIVE_ATTACK {\n            debug!(quote {\n                        // let event = self.event;\n                        // let actor = self.actor_id;\n                        // let self_x = self.x;\n                        // let self_y = self.y;\n                        // let val = self.value;\n                        // println(f\"GetAppliedDamageToMyAsset: Event({event}:{val} from {actor}@{self_x}|{self_y})@{x}|{y}: {distance} <= {radius}\");\n                    });\n            if distance <= radius {\n                let damage_raw = get_attack_damage_to_tile(self.subtype, self.value as u32, tile) as u32;\n                damage = damage_raw * (1 + radius - distance) / (radius + 1) as u32;\n                debug!(quote { println(f\"Deal damage: {damage_raw} * (1 + {radius} - {distance}) / ({radius} + 1) = {damage}\"); });\n            }\n            // if (self.x == x) & (self.y == y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile);\n            // } else if (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile) / 2;\n            // }\n        }\n        if self.event == TRIGGERED_TRAP {\n            damage = get_trap_damage_to_tile(self.value as u32, tile);\n        }\n        damage as u16\n    }\n\n    pub fn empty(actor_id: u8) -> Event {\n        Event {\n            event: NO_EVENT,\n            actor_id: actor_id,\n            x: 0,\n            y: 0,\n            value: 0,\n            subtype: 0,radius: 0\n        }\n    }\n\n    pub fn get_dummy_events() -> [Field; MAX_EVENTS] {\n        [0; MAX_EVENTS]\n    }\n\n    pub fn get_test_dummy_events() -> [Event; MAX_EVENTS] {\n        [Event::empty(0); MAX_EVENTS]\n    }\n}\n\npub fn build_std_event(event: u8, actor_id: u8, x: u8, y: u8) -> Event {\n    assert(event < EVENT_COUNT);\n    assert((actor_id as u32) < MAX_CHARACTERS);\n    assert((x < WIDTH) | (x == NOWHERE));\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: 0,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\n#[test]\nfn test_build_std_event() {\n    let event = build_std_event(SEE_MOVE, 1, 2, 3);\n    assert(event.event == SEE_MOVE);\n    assert(event.actor_id == 1);\n    assert(event.x == 2);\n    assert(event.y == 3);\n}\n\n#[test(should_fail)]\nfn test_build_std_event_fail() {\n    let event = build_std_event(EVENT_COUNT, 1, 2, 3);\n    assert(event.event == EVENT_COUNT);\n}\n\npub fn build_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8) -> Event {\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\npub fn build_subtype_value_event(event_type: u8, actor_id: u8, x: u8, y: u8, value: u8, event_subtype: u8, radius: u8) -> Event {\n    Event {\n        event: event_type,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: event_subtype,\n        radius: radius,\n    }\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/event.nr"},"75":{"source":"mod common;\n// mod actionPreCalcEffect;\n// mod actionResultEvent;\n// mod actionResultEffect;\n// mod actionRequirements;\nmod action;\n// mod actionDefinitionRegister;\nmod bugs;\nuse arenalib::{ new_action };\npub use action::execute_action;\n// mod actionDefinition;\nmod character;\nuse character::{ Character };\nuse character::parse_characters;\nmod event;\nuse event::Event;\npub use event::{serialize_events, parse_their_events};\nmod obstacle;\nuse obstacle::Obstacle;\npub use obstacle::{ new_obstacle, parse_my_obstacles, parse_their_obstacles, get_obstacle_x, get_obstacle_y, get_obstacle_id, get_obstacle_type, get_obstacle_health, serialize_my_obstacles, get_default_obstacles };\nmod map;\nuse dep::std;\nuse obstacle::serialize_obstacle;\nuse obstacle::serialize_their_obstacles;\n// use action::ACTION_TARGET_X;\n// use action::ACTION_TARGET_Y;\n// use action::ACTION_TYPE;\nuse arenalib::{get_action_target_y, get_action_target_x, get_action_type};\nuse obstacle::serialize_my_obstacles_for_me;\nuse map::is_visible;\npub use arenalib::{SerializedArenaActionDefinitions, SerializedArenaActions, SerializedArenaCharacterRoster, SerializedArenaEnemyObstacles, SerializedArenaEvents, SerializedArenaObstacles};\nuse arenalib::arena_test_action_def_register;\nuse character::serialize_chars;\nuse skplg::{softassert, debug};\nuse arenalib::{serialize_actions, parse_actions};\n\nuse arenalib::{SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLE_BYTE_SIZE};\nuse arenalib::{WIDTH};\nuse arenalib::{MAX_ACTIONS, MAX_CHARACTERS, MAX_EVENTS, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES};\nuse arenalib::{VIEW_DISTANCE};\nuse arenalib::{ARCHER, KNIGHT, ROGUE, MAGE, RITUALIST};\nuse arenalib::{MIN_FIREBALL_ROUNDS_FOR_CAST};\nuse arenalib::{SEE_MOVE, RECEIVE_ATTACK, NO_EVENT};\nuse arenalib::{ATTACK_FIREBALL, ATTACK_RANGED};\nuse arenalib::{WAIT};\nuse arenalib::get_wait_action_def;\nuse arenalib::get_test_action_register;\npub use action::get_performable_actions;\nuse arenalib::Action;\nuse arenalib::get_action_actor;\n\n// mod ResolvedAction;\n\n\n\n// #[export]\n// pub fn ext_can_move_to(x: u8, y: u8, obstacles: [Obstacle; MAX_OBSTACLES], their_obstacles: [Obstacle]) -> bool {\n//     assert(MAX_OBSTACLES == 24);\n//     let mut my_obstacles_parsed = Obstacle::parse_my_obstacles(my_obstacles, events).as_array();\n//     // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n//     // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n//     let enemy_objects_parsed = Obstacle::parse_their_obstacles(enemy_objects);\n\n//     let mut can = true;\n//     for i in 0..MAX_OBSTACLES {\n//         if !obstacles[i].is_traversible() & (obstacles[i].x == x) & (obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     for i in 0..their_obstacles.len() {\n//         if !their_obstacles[i].is_traversible() & (their_obstacles[i].x == x) & (their_obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     can\n// }\n\n// pub comptime global DEBUG: bool = false;\n// pub comptime fn debug(stmt: Quoted) -> Quoted {\n//     let debug_result = if DEBUG {\n//         stmt\n//     } else { quote {} };\n//     debug_result\n// }\n// pub comptime fn debugmsg<T>(msg: T) -> Quoted {\n//     debug!(quote { println($msg); })\n// }\n// pub comptime fn softassert(varname: Quoted, check: Quoted, msg: Quoted) -> Quoted {\n//     let result = if DEBUG {\n//         quote {\n//             $varname &= $check;\n//             if !($check) {\n//                 println($msg);\n//             }\n//         }\n//     } else {\n//         quote {\n//             $varname &= $check;\n//         }\n//     };\n//     result\n// }\n\n// // MAP\n// global WIDTH_BITS: u8 = 5;\n// global WIDTH_MASK: u8 = (1 << WIDTH_BITS) - 1;\n// global WIDTH: u8 = 1 << WIDTH_BITS;\n// global HEIGHT_BITS: u8 = 4;\n// global HEIGHT_MASK: u8 = (1 << HEIGHT_BITS) - 1;\n// global HEIGHT: u8 = 10;\n// // global NOWHERE: u8 = 255;\n\n// // CLASSES\n// //global UNKNOWN_CLASS: u8 = 0;\n// global ARCHER: u8 = 1;\n// global RITUALIST: u8 = 2;\n// global ROGUE: u8 = 3;\n// global KNIGHT: u8 = 4;\n// global MAGE: u8 = 5;\n// global CLASS_BITS: u8 = 3;\n// global CLASS_MASK: u8 = (1 << CLASS_BITS) - 1;\n// global CLASS_COUNT: u32 = 6;\n// global MAX_ACTIONS_PER_CHARACTER: u32 = 6;\n\n// // ACTIONS\n// global WAIT: u8 = 0;\n// //global SNEAK: u8 = 1;\n// //global MOVE: u8 = 2;          // => SEE_COLUMN (depr: MOVE)\n// //global RITUAL: u8 = 3;        // => SEE_RITUAL | WIN\n// //global SEARCH: u8 = 4;        // => SEE_SEARCH_TRAP\n// //global ATTACK: u8 = 5;        // => RECEIVE_ATTACK | DESTROY // affects my obstacles; TODO: with more attack types might also affect other own characters\n// //global CAST: u8 = 6;          // => SEE_CAST // affects my obstacles; TODO: with more attack types might also affect other own characters\n// //global CAST_FIREBALL: u8 = 7; // => RECEIVE_ATTACK // affects other characters if status == FIREBALL_ROUNDS_FOR_CAST\n// //global DRAW: u8 = 8;          // => SEE_DRAW\n// //global SHOOT: u8 = 9;         // => RECEIVE_ATTACK\n// //global TRIGGER_TRAP = 9;  // => TRIGGERED_TRAP ?????????\n// //global DISARM_TRAP: u8 = 10;  // => DESTROY\n// //global SET_TRAP: u8 = 11;\n// global ACTION_COUNT: u32 = 12;\n// pub global ACTION_RESULT_EVENT_COUNT: u32 = 4;\n// global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0;\n// global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1;\n// global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2;\n\n// // EVENTS\n// global NO_EVENT: u8 = 0 ;\n// // global DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n// //global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n// //global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\n// global SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n// //global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\n// global SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\n// global SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// global SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// global SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// //global RECEIVE_DAMAGE = 9;   // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\n// global RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\n// global TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\n// // global FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\n// global DISARMED_TRAP: u8 = 13;      // actor_id = their-char when receive - need to remove my trap from the map\n// global WIN: u8 = 14;\n// // global LOSE: u8 = 15;\n// global ADD_OBSTACLE: u8 = 4;\n// global EVENT_COUNT: u8 = 16;\n\n// // SUBTYPES:\n// global WIN_BY_RITUAL: u8 = 1;\n\n// // ATTACKS\n// global ATTACK_MELEE: u8 = 0;\n// global ATTACK_RANGED: u8 = 1;\n// global ATTACK_FIREBALL: u8 = 2;\n// // global ATTACK_COUNT: u8 = 3;\n// // TODO: instead of enum, use a global array of structs with damage, range, etc.\n\n\n// // TILES\n// global EMPTY: u8 = 0;\n// global WALL: u8 = 6;\n// global WATER: u8 = 7;\n// // global UNKNOWN_CLASS_TILE: u8 = 8;\n// global NON_EMPTY_WALKABLE_TILE_MIN: u8 = 9;\n// // global FLAG: u8 = 9;\n// global TRAP: u8 = 10;\n// // global TRAP_USED: u8 = 11;\n// // global TRAP_FOUND: u8 = 12;\n// // global BODY: u8 = 13;\n// // global BODY_LOOTED: u8 = 14;\n// // global FOG: u8 = 15;\n// global MAX_OBSTACLE_TYPE: u8 = 0x0f;\n// // global TILE_COUNT: u8 = 16;\n// // unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n// // STATUS\n// global RITUAL_ROUNDS_FOR_WIN: u8 = 15;\n// global MIN_FIREBALL_ROUNDS_FOR_CAST: u8 = 3;\n// global MAX_FIREBALL_ROUNDS_FOR_CAST: u8 = 6;\n// // global DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\n// global MIN_DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\n// global MAX_DRAW_ROUNDS_FOR_SHOOT: u8 = 3;\n// global PROGRESS_BITS: u8 = 4;\n// global PROGRESS_MASK: u8 = (1 << PROGRESS_BITS) - 1;\n// global PROGRESS_COUNT: u8 = 16 ; // just to be more in line with the other constants, actually used as a counter\n// global MAX_HEALTH: u8 = 255;\n\n// // GAMEPLAY\n// global VIEW_DISTANCE: u8 = 6;\n// // global MAX_TRAPS: u32 = 8; // note: only lowest bit of first byte of field is usable! => ! Field = 1 bit + 31 bytes!\n// // global TRAPS_BUFFER_SIZE: Field = 16;\n// // global TRAPS_BUFFER_MASK: Field = 15; // has to be 2^n - 1\n// global MAX_ACTIONS: u32 = 4;\n// global MAX_EVENTS: u32 = 4; // = MAX_ACTIONS // NO! handle traps in a different way (by passing as argument!)+ 4 (2 FOUND_TRAP + WIN/LOSE + 1 reserved)\n// global MAX_OBSTACLES: u32 = 24; // leave traps for now + MAX_TRAPS; // 24 + 8 player placeables\n// pub global MAX_CHARACTERS: u32 = 5;\n// global MIN_PROGRESS: u8 = 0;\n// pub global MAX_PROGRESS: u8 = PROGRESS_COUNT - 1;\n// global SERIALIZED_OBSTACLE_BYTE_SIZE: u32 = 3;//3\n// pub global SERIALIZED_OBSTACLES_ARRAY_SIZE: u32 = 3;//3 // TODO: we take 3 because 3 x 8 = MAX_OBSTACLES ... should assert on this (MAX_OBSTACLES + MAX_CHARACTERS + 7) / 8;\n// pub global SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE: u32 = SERIALIZED_OBSTACLES_ARRAY_SIZE + 1; // +1 because enemy characters are also serialized as obstacles\n// global SERIALIZED_OBSTACLES_PER_FIELD: u32 = 8;//8 // TODO: need to verify that SERIALIZED_OBSTACLES_ARRAY_SIZE * SERIALIZED_OBSTACLES_PER_FIELD = MAX_OBSTACLES!\n// global SERIALIZED_EVENT_BYTE_SIZE: u32 = 7;\n// pub global SERIALIZED_EVENTS_ARRAY_SIZE: u32 = 1; // MAX_EVENTS / SERIALIZED_EVENTS_PER_FIELD => 4 / 4 = 1\n// global SERIALIZED_EVENTS_PER_FIELD: u32 = 4; // 31 / 7 = 4\n// global SERIALIZED_ACTION_BYTE_SIZE: u32 = 5;\n// pub global SERIALIZED_ACTIONS_ARRAY_SIZE: u32 = 1;\n// global SERIALIZED_ACTIONS_PER_FIELD: u32 = 4; // could be up to 6, but we only use 4\n\n\n// pub type SerializedArenaActionDefinitions = SerializedRosterActionDefinitions<MAX_ACTIONS_PER_CHARACTER, MAX_CHARACTERS>;\n// pub type SerializedArenaCharacterActionDefinitions = SerializedCharacterActionDefinitions<MAX_ACTIONS_PER_CHARACTER>;\n// pub type SerializedArenaCharacterActionDefinition = SerializedCharacterActionDefinition;\n// #[export]\n// fn tf(x: Field) -> (u32, [u8;32]) {\n//     let mut result: [u8;32] = [0;32];\n//     let bts = x.to_be_bytes::<32>();\n//     for j in 0..31 {\n//         result[j] = 2*j;//bts[j];\n//     }\n//     (32 , result)\n// }\n// i,\n// 20, 0 -> 25,\n// 25 -> 0, \n// x, 0, 0, d0,\n// x, 0, 0, 9d, 1, 0,\n// x, 0, 0, 1, 0, b4, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 91, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 23, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, d4, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, 66, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 50, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b9, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, c5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 55, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b2, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, e8, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2a, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, cb, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 9b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 5c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, a6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 86, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, d5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 38, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8e, 1, 0, 0, 1,\n// 0, 32, 1, 0, 1, 1, x, 0, 0, 1,\n// x, 0, 0, 1, x, 0, 0, 1, 0, 1, 1\n\n// i,\n// 20, 0, 1e -> 0, 0 -> 1e, 0\n// x, 0, 0, d0,\n// x, 0, 0, ba, 1, 0,\n// x, 0, 0, 1, 0, cf, 1, 0, 1, 1,\n\nfn get_actor_from_move(mut move: u32) -> u8 {\n    if (move % 2) == 1 {\n        move -= 1; //((move % 10) - 1) >> 1 // actually not needed ... but clearer this way\n    }\n    let single_digit: u32 = (move % 10 as u32) >> 1;\n    single_digit as u8\n}\n// 3, 1, 1, 1, 0, 1, 2, 0, 2, 8, 1, 0, 0, 1\n// 4, 2, 2, 0, x, 0, 0, 0, 4, a, 2, 0, 0, 2\n\n#[export]\npub fn hash_serialized_private_state(my_chars: SerializedArenaCharacterRoster, my_char_actions: SerializedArenaActionDefinitions, my_obstacles: SerializedArenaObstacles, secret: Field) -> pub Field {\n    // let my_chars_be_bytes: [u8; 32] = my_chars.to_be_bytes::<32>();\n    // assert(my_chars_be_bytes.len() == 32);\n    let gamestate_before_hash_calculated = get_data_hash(secret, my_chars, my_char_actions, my_obstacles);\n    //let gamestate_before_hash_calculated_field = std::field::bytes32_to_field(gamestate_before_hash_calculated);\n    gamestate_before_hash_calculated\n}\n\n#[test]\nfn test_hash_match() {\n  let my_chars = 12345678901234567890;\n  let my_char_actions = [\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890\n  ];\n  let my_obstacles = [\n    12345678901234567890, 12345678901234567890, 12345678901234567890\n  ];\n  let secret = 12345678901234567890;\n\n  let hash1 = get_data_hash(secret, my_chars, my_char_actions, my_obstacles);\n  let valid = hash_serialized_private_state(my_chars, my_char_actions, my_obstacles, secret);\n\n  assert(hash1 == valid, f\"{hash1} != {valid}\");\n}\n\n#[export]\nfn get_serialized_obstacle(id: u8, x: u8, y: u8, obstacle_type: u8) -> pub Field {\n    let mut result: [u8; 32] = [0; 32];\n    result[0] = id;\n    result[1] = x;\n    result[2] = y;\n    result[3] = obstacle_type;\n    std::field::bytes32_to_field(result)\n}\n\n// global action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// global action_builder: ActionDefinitionBuilder = ActionDefinitionBuilder::new(\n//   WAIT,\n//   MIN_PROGRESS,\n//   MAX_PROGRESS,\n//   ACTION_RESULT_COORDINATES_IDX_SELF,\n//   ACTION_RESULT_COORDINATES_IDX_TARGET,\n//   ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//   NO_EVENT,\n//   RECEIVE_ATTACK,\n//   SEE_CAST,\n//   SEE_DRAW,\n//   SEE_MOVE,\n//   SEE_RITUAL,\n//   SEE_SEARCH_TRAP,\n//   DISARMED_TRAP,\n//   ADD_OBSTACLE,\n//   WIN\n// );\n\n#[export]\npub fn calculate_action(\n  action: Action,\n  mut my_chars: [Character; MAX_CHARACTERS],\n  mut my_obstacles_parsed: [Obstacle; MAX_OBSTACLES],\n  enemy_objects_parsed: [Obstacle; MAX_ENEMY_OBSTACLES],\n  enemy_advance_input: u8,\n  mut energy: u8\n) -> (bool, [Character; MAX_CHARACTERS], [Obstacle; MAX_OBSTACLES], u8, Event) {\n  let mut success = true;\n  let actor_id = get_action_actor(action);\n  let mut actor = my_chars[actor_id];\n  let (my_chars_as_obstacles_valid, my_chars_as_obstacles) = chars_to_obstacles(my_chars);\n  softassert!(quote { success }, quote { my_chars_as_obstacles_valid }, quote { f\"Failed to convert my chars to obstacles: {my_chars}\" });\n  let result = execute_action(action, enemy_advance_input, actor, energy, my_chars_as_obstacles, my_obstacles_parsed, enemy_objects_parsed);\n  //assert(result.0);\n  success &= result.0;\n  let result_event = result.1;\n  let internal_event = result.2;\n  let self_event = result.3;\n  actor = result.4;\n  energy = result.5;\n  \n  // 4461 / 5 = 892,2\n  my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n  // 16800 / 24 = 700\n  my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| {\n      let (updated_obstacle_valid, updated_obstacle) = update_my_obstacle(obstacle, result_event);\n      //success = success & updated_obstacle_valid;\n      softassert!(quote { success }, quote { updated_obstacle_valid }, quote { f\"Failed to update my obstacle {obstacle}, {result_event}\" });\n      updated_obstacle\n  });\n\n  (success, my_chars, my_obstacles_parsed, energy, result_event)\n}\n\n#[export]\npub fn calculate_turn(\n    my_chars_input: SerializedArenaCharacterRoster,\n    my_char_actions_input: SerializedArenaActionDefinitions,\n    my_obstacles_input: SerializedArenaObstacles,\n    //mut my_obstacles_parsed: [[u8; 5]; 24],\n    actions_input: SerializedArenaActions,\n    // Common Inputs\n    move_input: u32, //pub\n    // Enemy Inputs\n    enemy_advance_input: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects_input: SerializedArenaEnemyObstacles, // pub\n    enemy_events_input: SerializedArenaEvents, // pub //MAX_EVENTS],\n\n) -> pub (bool, SerializedArenaCharacterRoster, SerializedArenaActionDefinitions, [Obstacle; 24], u8, SerializedArenaEvents, SerializedArenaEnemyObstacles) {\n    let mut success = true;\n    \n// let action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// let action_builder: ActionDefinitionBuilder = ActionDefinitionBuilder::new(\n//   WAIT,\n//   MIN_PROGRESS,\n//   MAX_PROGRESS,\n//   ACTION_RESULT_COORDINATES_IDX_SELF,\n//   ACTION_RESULT_COORDINATES_IDX_TARGET,\n//   ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//   NO_EVENT,\n//   RECEIVE_ATTACK,\n//   SEE_CAST,\n//   SEE_DRAW,\n//   SEE_MOVE,\n//   SEE_RITUAL,\n//   SEE_SEARCH_TRAP,\n//   DISARMED_TRAP,\n//   ADD_OBSTACLE,\n//   WIN\n// );\n    //let actionRegister = ActionDefinitionRegister::new(my_char_actions_input);\n    // calculate enemy advance in our coordinates and shadow\n    // let (enemy_advance_valid, enemy_advance) = their_x_to_mine(enemy_advance);\n\n    // // more efficient to do this here, BUT leads to bad side effects for frontend (and it is not THAT costly)\n    // let enemy_advance = if enemy_advance_input >= WIDTH { 0 } else { WIDTH - enemy_advance_input - 1 };\n\n\n    // TODO: Validate map => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    let (events_valid, events) = parse_their_events(enemy_events_input);\n    softassert!(quote { success }, quote { events_valid }, quote { f\"Failed to parse their events {events}\" });\n\n    // let side = move as u1;\n    let (my_chars_valid, mut my_chars) = parse_characters(my_chars_input, my_char_actions_input, events, enemy_advance_input);\n    softassert!(quote { success }, quote { my_chars_valid }, quote { f\"Failed to parse my characters {my_chars}\" });\n\n    let actor_id = get_actor_from_move(move_input);\n    // let mut actor = my_chars[actor_id]; //Character::parse(actor_id, my_chars, events);\n    \n    comptime {\n        assert(MAX_OBSTACLES == 24);\n    }\n\n    let (valid, my_obstacles_parsed) = parse_my_obstacles(my_obstacles_input, events);\n    softassert!(quote { success }, quote { valid }, quote { f\"Failed to parse my obstacles {my_obstacles_input}\" });\n    let mut my_obstacles_parsed: [Obstacle; MAX_OBSTACLES] = my_obstacles_parsed;\n\n    let (actions_valid, actions) = parse_actions(MAX_CHARACTERS as u8, actions_input); // actions.map(|action| Action::from_field(action));\n    softassert!(quote { success }, quote { actions_valid }, quote { f\"Failed to parse actions {actions_input}\" });\n    // let mut my_obstacles_parsed = my_obstacles_parsed.as_array();\n//    let (valid, mut my_obstacles_parsed) = parse_my_obstacles(my_obstacles, events).as_array();\n    // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n    let (enemy_objects_parsed_valid, enemy_objects_parsed) = parse_their_obstacles(enemy_objects_input);\n    softassert!(quote { success }, quote { enemy_objects_parsed_valid }, quote { f\"Failed to parse their obstacles {enemy_objects_input}\" });\n\n    let mut energy: u8 = 12;\n    let mut result_events_calculated: [Event] = &[];\n    for i in 0..MAX_ACTIONS {\n        // TODO: ensure that if actor committed suicide, it is not allowed to do any more actions\n        let action = actions[i];\n        //let resolved_action = actionRegister.resolve_action(action); //resolve_action(action);\n\n        let (\n          turn_action_result_action_valid,\n          turn_action_result_my_chars,\n          turn_action_result_my_obstacles_parsed,\n          turn_action_result_energy,\n          turn_action_result_result_event\n        ) = calculate_action(\n          action,\n          my_chars,\n          my_obstacles_parsed,\n          enemy_objects_parsed,\n          enemy_advance_input,\n          energy\n        );\n        softassert!(quote { success }, quote { turn_action_result_action_valid }, quote { f\"Failed to execute turn action {i}\" });\n\n        my_chars = turn_action_result_my_chars;\n        my_obstacles_parsed = turn_action_result_my_obstacles_parsed;\n        energy = turn_action_result_energy;\n\n        // let result = execute_action(action, enemy_advance_input, actor, energy, my_obstacles_parsed, enemy_objects_parsed);\n        // //assert(result.0);\n        // success &= result.0;\n        // let result_event = result.1;\n        // let internal_event = result.2;\n        // let self_event = result.3;\n        // actor = result.4;\n        // energy = result.5;\n        \n        // // 4461 / 5 = 892,2\n        // my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n        // // 16800 / 24 = 700\n        // my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| {\n        //     let (updated_obstacle_valid, updated_obstacle) = update_my_obstacle(obstacle, result_event);\n        //     //success = success & updated_obstacle_valid;\n        //     softassert!(quote { success }, quote { updated_obstacle_valid }, quote { f\"Failed to update my obstacle {obstacle}, {result_event}\" });\n        //     updated_obstacle\n        // });\n\n        result_events_calculated = result_events_calculated.push_back(turn_action_result_result_event);\n    }\n    let result_events_calculated = serialize_events(result_events_calculated.as_array());\n    assert(result_events_calculated.len() == SERIALIZED_EVENTS_ARRAY_SIZE);\n\n    // send death events => no need\n\n    // determine view range\n    let mut my_advance_calculated = 0;\n    for i in 0..MAX_CHARACTERS {\n        if my_chars[i].x > my_advance_calculated {\n            my_advance_calculated = my_chars[i].x;\n        }\n    }\n    my_advance_calculated += VIEW_DISTANCE;\n\n    let (serialized_characters, serialized_action_defs) = serialize_chars(my_chars);\n    let serialized_obstacles: [Field] = serialize_my_obstacles(enemy_advance_input, my_obstacles_parsed);\n    let (serialized_chars_as_obstacles_valid, serialized_chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance_input, my_chars);\n    // success = success & serialized_chars_as_obstacles_valid;\n    softassert!(quote { success }, quote { serialized_chars_as_obstacles_valid }, quote { f\"Failed to serialize chars as obstacles: {my_chars}\" });\n    let serialized_obstacles_for_enemy: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE] = serialized_obstacles.push_back(serialized_chars_as_obstacles).as_array();\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles_parsed);\n\n    (success, serialized_characters, serialized_action_defs, my_obstacles_parsed, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy)\n}\n\n\n\n#[export]\npub fn turn(\n    // verification_key: pub [Field; 114],\n    // proof: pub [Field; 93],\n    // public_inputs: pub [Field; 1 ],//+ 2 * SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE + 2 * SERIALIZED_EVENTS_ARRAY_SIZE],\n    // key_hash: pub Field,\n    // last_move: pub u32,\n    // last_enemy_advance: pub u8,\n    // last_enemy_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // last_events: pub [Field, SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_advance: pub u8,\n    // last_my_result_events: pub [Field; SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_result_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // Gamestate Hashes\n    // gamestate_before_hash: pub Field,\n    // gamestate_after_hash: pub Field,\n    // My Secret State\n    secret: Field,\n    my_chars_input: SerializedArenaCharacterRoster,\n    my_char_actions: SerializedArenaActionDefinitions,\n    my_obstacles_input: SerializedArenaObstacles,\n    //my_obstacles: [[u8; 5]; 24],\n    actions: SerializedArenaActions,\n    // Common Inputs\n    move: u32, //pub\n    // Enemy Inputs\n    enemy_advance: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects: SerializedArenaEnemyObstacles, // pub\n    enemy_events: SerializedArenaEvents, // pub //MAX_EVENTS],\n    // My Results\n    my_result_advance: u8, // pub // 1 bit win, 1 bit lose, 1 bit reserved, 5 bits advance\n    my_result_events: SerializedArenaEvents, // pub\n    my_result_objects: SerializedArenaEnemyObstacles, // pub\n    // Gamestate Hashes\n    gamestate_before_hash: Field, // pub\n    gamestate_after_hash: Field, // pub\n) -> pub bool {\n    // Validate global constants (to make sure one didn't change one without updating dependet ones)\n    comptime {\n        assert((SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLE_BYTE_SIZE) < 32);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE >= MAX_OBSTACLES);\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        // assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    //let my_char_actions = arena_test_action_def_register;// get_test_action_register();\n\n    let mut success = true;\n    // let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    // assert(secret_be_bytes.len() == 32);\n\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles);\n    let gamestate_before_hash_calculated_field = hash_serialized_private_state(my_chars_input, my_char_actions, my_obstacles_input, secret);\n    // assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    softassert!(quote { success }, quote { gamestate_before_hash == gamestate_before_hash_calculated_field }, quote { f\"Invalid pre-hash: {gamestate_before_hash} != {gamestate_before_hash_calculated_field}\" });\n    // std::verify_proof(verification_key, proof, public_inputs, key_hash);\n\n    let  (turn_calc_valid, serialized_characters, my_char_actions_after, serialized_obstacles, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy) = calculate_turn(\n        my_chars_input,\n        my_char_actions,\n        my_obstacles_input,\n        actions,\n        move,\n        enemy_advance,\n        enemy_objects,\n        enemy_events\n    );\n    softassert!(quote { success }, quote { turn_calc_valid }, quote { f\"Tun calculation failed\" });\n\n    // if side == 0 {\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x > my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated += VIEW_DISTANCE;\n    // } else {\n    //     my_advance_calculated = WIDTH - 1;\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x < my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated -= VIEW_DISTANCE;\n    // }\n    softassert!(quote { success }, quote { my_result_advance == my_advance_calculated }, quote { f\"Invalid result advance: {my_result_advance} != {my_advance_calculated}\" });\n\n    // validate result\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        softassert!(quote { success }, quote { result_event_should == result_event_calculated }, quote { f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\" });\n    }\n    // assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    // let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes::<32>();\n    // assert(serialized_characters_be_bytes.len() == 32);\n    debug!(quote {\n        println(f\"serialized_obstacles: {serialized_obstacles}\");\n        println(f\"serialized_obstacles_for_enemy: {serialized_obstacles_for_enemy}\");\n        println(f\"serialized_characters: {serialized_characters}\");\n        // println(f\"serialized_characters_be_bytes: {serialized_characters_be_bytes}\");\n    });\n    // let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    assert(my_result_objects.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE {\n        let my_result_object = my_result_objects[i];\n        let serialized_obstacle = serialized_obstacles_for_enemy[i];\n        softassert!(quote { success }, quote { my_result_object == serialized_obstacle }, quote { f\"Invalid result obstacle row {i}: {my_result_object} != {serialized_obstacle}\" });\n    }\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(serialized_obstacles);\n    let new_hash_bytes = get_data_hash(secret, serialized_characters, my_char_actions_after, my_obstacles_serialized_for_me);\n    softassert!(quote { success }, quote { new_hash_bytes == gamestate_after_hash }, quote { f\"Invalid result hash: {new_hash_bytes} != {gamestate_after_hash}\" });\n    success\n}\n\nfn wb_apply_damage_to_char(mut c: Character, event: Event, actor: Character) -> Character {\n    if c.id == actor.id {\n        c = actor;\n    }\n    apply_damage_to_char(c, event)\n}\n\nfn apply_damage_to_char(c: Character, event: Event) -> Character {\n    let dmg = event.get_applied_damage_to_my_asset(c.x, c.y, c.class);\n    Character {\n        id: c.id,\n        x: c.x,\n        y: c.y,\n        class: c.class,\n        health: safe_subtract_dmg(c.health, dmg),\n        progress: c.progress,\n        target_x: c.target_x,\n        target_y: c.target_y,\n        has_been_seen: c.has_been_seen,\n        is_hidden: c.is_hidden,\n        damage_mod: c.damage_mod,\n        last_action: c.last_action,\n        actions: c.actions,\n        status: 0\n    }\n}\nfn update_my_obstacle(obstacle: Obstacle, event: Event) -> (bool, Obstacle) {\n    let dmg =\n        // event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle)) +\n        event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle));\n    new_obstacle(get_obstacle_id(obstacle), get_obstacle_x(obstacle), get_obstacle_y(obstacle), safe_subtract_dmg(get_obstacle_health(obstacle), dmg), get_obstacle_type(obstacle))\n    // Obstacle {\n    //     health: safe_subtract_dmg(obstacle.health, dmg),\n    //     id: obstacle.id,\n    //     x: obstacle.x,\n    //     y: obstacle.y,\n    //     obstacle_type: obstacle.obstacle_type,\n    // }\n}\n\nfn get_data_hash(secret: Field, characters: Field, character_actions: SerializedArenaActionDefinitions, obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> Field {\n  assert(character_actions.len() == 30);\n  assert(obstacles.len() == 3);\n  std::hash::poseidon2::Poseidon2::hash([\n    secret,\n    characters,\n    character_actions[0],\n    character_actions[1],\n    character_actions[2],\n    character_actions[3],\n    character_actions[4],\n    character_actions[5],\n    character_actions[6],\n    character_actions[7],\n    character_actions[8],\n    character_actions[9],\n    character_actions[10],\n    character_actions[11],\n    character_actions[12],\n    character_actions[13],\n    character_actions[14],\n    character_actions[15],\n    character_actions[16],\n    character_actions[17],\n    character_actions[18],\n    character_actions[19],\n    character_actions[20],\n    character_actions[21],\n    character_actions[22],\n    character_actions[23],\n    character_actions[24],\n    character_actions[25],\n    character_actions[26],\n    character_actions[27],\n    character_actions[28],\n    character_actions[29],\n    obstacles[0],\n    obstacles[1],\n    obstacles[2]\n  ], 2 + 30 + 3)\n}\n// fn get_data_hash(secret: [u8], characters: [u8], character_actions: [u8; ACTION_DEFINITION_REGISTER_SIZE], obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> [u8; 32] {\n//     assert(secret.len() == 32);\n//     assert(characters.len() == 32);\n\n//     let mut data: [u8; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE] = [0; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE];\n//     for i in 0..32 {\n//         data[i] = secret[i];\n//         data[i + 32] = characters[i];\n//     }\n//     let offset = 32 + 32;\n//     for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//         let obstacle: [u8; 32] = obstacles[i].to_be_bytes::<32>();\n//         assert(obstacle.len() == 32);\n//         for j in 0..32 {\n//             data[offset + i * 32 + j] = obstacle[j];\n//         }\n//     }\n//     let offset = 32 + 32 + 32 * SERIALIZED_OBSTACLES_ARRAY_SIZE;\n//     for i in 0..ACTION_DEFINITION_REGISTER_SIZE {\n//         data[offset + i] = character_actions[i];\n//     }\n//     // let offset = WIDTH * HEIGHT + 32 * 3;\n//     // for i in 0..10 {\n//     //     data[offset + i * 4] = (searched_traps[i] & 255) as u8;\n//     //     data[offset + i * 4 + 1] = ((searched_traps[i] >> 8) & 255) as u8;\n//     //     data[offset + i * 4 + 2] = ((searched_traps[i] >> 16) & 255) as u8;\n//     //     data[offset + i * 4 + 3] = ((searched_traps[i] >> 24) & 255) as u8;\n//     // }\n//     std::hash::blake3(data)\n// }\n\n// fn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> Field {\n//     comptime {\n//         assert(MAX_CHARACTERS <= 5);\n//     }\n//     let mut result: [u8; 32] = [0; 32];\n//     for i in 0..MAX_CHARACTERS {\n//         let serialized = chars[i].serialize();\n//         for j in 0..6 {\n//             result[2 + i * 6 + j] = serialized[j];\n//         }\n//     }\n//     std::field::bytes32_to_field(result)\n// }\n\n#[export]\npub fn chars_to_obstacles(chars: [Character; MAX_CHARACTERS]) -> pub (bool, [Obstacle; MAX_CHARACTERS]) {\n  let mut result: BoundedVec<Obstacle, MAX_CHARACTERS> = BoundedVec::new();\n  let mut valid_result = true;\n  for i in 0..MAX_CHARACTERS {\n    let (valid, char_as_obstacle) = chars[i].to_obstacle();\n    result.push(char_as_obstacle);\n    valid_result &= valid;\n  }\n  assert(result.len() == MAX_CHARACTERS);\n  (valid_result, result.storage())\n}\n\nfn serialize_chars_as_obstacles(enemy_advance: u8, chars: [Character; MAX_CHARACTERS]) -> (bool, Field) {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut result: [u8; 32] = [0; 32];\n    let mut valid_result = true;\n    for i in 0..MAX_CHARACTERS {\n        if (chars[i].is_hidden == 0) & is_visible(enemy_advance, chars[i].get_x()) {\n            let (valid, char_as_obstacle) = chars[i].to_obstacle();\n            let serialized = serialize_obstacle(char_as_obstacle);\n            valid_result = valid_result & valid;\n            result[2 + i * 3] = serialized[0];\n            result[2 + i * 3 + 1] = serialized[1];\n            result[2 + i * 3 + 2] = serialized[2];\n        }\n    }\n    (valid_result, std::field::bytes32_to_field(result))\n}\n\nfn safe_subtract_dmg(a: u8, b: u16) -> u8 {\n    let mut result = 0;\n    if (a as u16) > b {\n        result = a - (b as u8);\n    }\n    result\n}\n\nfn test_result_object_builder(enemy_advance: u8, chars: [Character; MAX_CHARACTERS], obs: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1]) {\n    let mut result: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        result[i] = obs[i];\n    }\n    let (valid, chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance, chars);\n    result[SERIALIZED_OBSTACLES_ARRAY_SIZE] = chars_as_obstacles;\n    (valid, result)\n}\n\n// fn test_helper_roster(actor: Character, mut chars: [Character; MAX_CHARACTERS]) -> [Character; MAX_CHARACTERS] {\n//     chars[actor.id] = actor;\n//     chars\n// }\n\n// fn test_helper_execute_move(move: u32, actor: Character, advances: [u8; 2], secret: [Field; 2], last_hashes: [Field; 2], chars: [[Character; MAX_CHARACTERS]; 2], obs: [[Obstacle; MAX_OBSTACLES]; 2], actions: [Action], my_events: [Event], their_events: [Event]) -> (u32, [Character; MAX_CHARACTERS], Field) {\n//     let side = move as u1;\n//     let other_side = (side as u8 + 1) as u1;\n//     let chars_after = test_helper_roster(actor, chars[side]);\n//     let my_obstacles_serialized = serialize_obstacles(advances[other_side], obs[side]);\n//     let secret_be_bytes: [u8; 32] = secret[side].to_be_bytes();\n//     assert(secret_be_bytes.len() == 32);\n//     let serialized_chars_after = serialize_chars(chars_after);\n//     let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes();\n//     assert(serialized_chars_after_be_bytes.len() == 32);\n//     let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, my_obstacles_serialized)); \n\n//     let (enemy_objects_valid, enemy_objects) = test_result_object_builder(chars[other_side], serialize_obstacles(other_side, advances[side], obs[other_side]));\n//     assert(enemy_objects_valid, \"Invalid enemy objects\");\n//     let (my_result_objects_valid, my_result_objects) = test_result_object_builder(chars_after, my_obstacles_serialized);\n//     assert(my_result_objects_valid, \"Invalid my result objects\");\n\n//     let result = turn(\n//         secret[side],\n//         character::serialize_chars(chars[side]),\n//         my_obstacles_serialized,\n//         serialize_actions(actions),\n//         move,\n//         advances[other_side],\n//         enemy_objects,\n//         Event::serialize_events(their_events).as_array(),\n//         advances[side],\n//         Event::serialize_events(my_events).as_array(),\n//         my_result_objects,\n//         last_hashes[side],\n//         current_hash\n//     );\n//     assert(result, \"Invalid result\");\n\n//     (move + 1, chars_after, current_hash)\n// }\n\n// #[test]\n// fn test_main() {\n//     let secrets = [123456789, 9876543210];\n//     let mut chars = [ character::get_default_characters(0), character::get_default_characters(1) ];\n//     let mut obs = [ Obstacle::get_default_obstacles(0), Obstacle::get_default_obstacles(1) ];\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 2, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 3, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 4, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 5, target_y: 1 },\n//     ];\n//     let their_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let mut move = 0;\n//     let mut actor = chars[0][0].move(5, 1);\n//     let mut last_hashes = [ 0x12b8f97907a05ec6a77da3f70368fa3b02e166c74edab8ea0695d6f406146559, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n//     let mut advances = [2 + VIEW_DISTANCE, 29 - VIEW_DISTANCE];\n//     advances[0] = 5 + VIEW_DISTANCE;\n\n//     let mut side = move % 2;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 0 },\n//         Action { action: MOVE, actor: 0, target_x: 27, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(27, 0);\n//     advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 1, target_y: 3 },\n//         Action { action: MOVE, actor: 1, target_x: 0, target_y: 3 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(0, 3);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 2 },\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 1, target_x: 28, target_y: 1 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(28, 1);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n// }\n\n#[test]\nfn test_main_fireball_ff() {\n  // let action_serde = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n  let wait_action = get_wait_action_def();\n    let secrets = [123456789, 9876543210];\n    let test_actions = arena_test_action_def_register.map(|a|a.to_be_bytes());\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, progress: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0, },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, progress: MIN_FIREBALL_ROUNDS_FOR_CAST + 1, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10, last_action: 3, actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, progress: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0,  },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT,actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ]\n    ];\n// x, y & type, health\n// 0x091264 0b2300 0c3400 0a442d 095764 000000000000000000000000000000 // direct\n// 0x091264 0b2319 0c3414 0a4464 095764 000000000000000000000000000000 // turn\n    let mut obs = [ get_default_obstacles(0), get_default_obstacles(1) ];\n    let actions = &[\n        new_action(4, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(1, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 20, y: 3, subtype: ATTACK_RANGED, value: 50, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    let my_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 0x78, radius: 1 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    // event actor x y value subt rad\n    // 0x091264 0b2300 0c3400 0a4428 0b5464 000000000000000000000000000000\n    // 0x0a040b04780201 03040907000000 0004000000000000040000000000000000\n    // 0x0a040b04780201 03040907000000 0004ffff0000000004ffff000000000000\n    // 0x091264 0b2300 0c3400 0a4428 095764000000000000000000000000000000\n    let mut move = 8;\n    let mut actor = Character { //chars[0][4].move(9, 7).set_status(0);\n        id: chars[0][4].id,\n        class: chars[0][4].class,\n        x: get_action_target_x(actions[1]),\n        y: get_action_target_y(actions[1]),\n        target_x: get_action_target_x(actions[1]), // TODO\n        target_y: get_action_target_y(actions[1]),\n        has_been_seen: chars[0][4].has_been_seen,\n        is_hidden: 0 as u1,\n        health: chars[0][4].health,\n        damage_mod: chars[0][4].damage_mod,\n        last_action: get_action_type(actions[1]),\n        progress: 0,\n        status: 0,\n        actions: chars[0][4].actions\n    };\n    //let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut last_hashes = [ 0x2cb6bffa42e22e89cbd87e4ac9ae7a82214febcab9c7b68e33fb1b7b8263ce7d, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 18 + VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 60), chars[side][2].take_damage(ATTACK_FIREBALL, 54), chars[side][3].take_damage(ATTACK_FIREBALL, 60), actor ];\n    let my_obstacles_serialized_for_enemy = serialize_my_obstacles(advances[other_side], obs[side]);\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n    let (serialized_chars_after, serialized_char_actions_after) = serialize_chars(chars_after);\n    // let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes::<32>();\n    // assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = get_data_hash(secrets[side], serialized_chars_after, serialized_char_actions_after, my_obstacles_serialized_for_me);\n\n    // turn:  0x2912640000004b03000000006c04002000008a0428000000a9076400000a\n    // calc:  0x2912640000004b03000000006c04002000008a0428000000a907640b340a\n    let (test_result_object_chars_after_valid, test_result_object_chars_after) = test_result_object_builder(advances[other_side], chars_after, my_obstacles_serialized_for_enemy);\n    let test_result_object_other_side_result = serialize_their_obstacles(advances[side], obs[other_side]);\n    let test_result_object_other_side = test_result_object_other_side_result.1;\n    let (test_result_object_other_chars_valid, test_result_object_other_chars) = test_result_object_builder(advances[side], chars[other_side], test_result_object_other_side);\n    println(\"Test-Inputs:\");\n    println(secrets[side]);\n    println(character::serialize_chars(chars[side]));\n    // println(get_test_action_register());\n    println(my_obstacles_serialized_for_me);\n    println(serialize_actions(actor.id, actions));\n    println(move);\n    println(advances[other_side]);\n    println(test_result_object_other_chars);\n    println(serialize_events(their_events));\n    println(advances[side]);\n    println(serialize_events(my_events));\n    println(test_result_object_chars_after);\n    println(last_hashes[side]);\n    println(current_hash);\n    println(\"Test-Inputs done\");\n    assert(test_result_object_chars_after_valid, \"Invalid test result object chars after\");\n    assert(test_result_object_other_chars_valid, \"Invalid test result object other chars\");\n\n    let (serialized_chars_input, serialized_char_actions_input) = serialize_chars(chars[side]);\n    // let (serialized_actions_valid, serialized_actions_input) = ;\n    let result = turn(\n        secrets[side],\n        serialized_chars_input,\n        serialized_char_actions_input,\n        my_obstacles_serialized_for_me, //obs[side],\n        serialize_actions(actor.id, actions),\n        move,\n        advances[other_side],\n        test_result_object_other_chars,\n        serialize_events(their_events),\n        advances[side],\n        serialize_events(my_events),\n        test_result_object_chars_after,\n        last_hashes[side],\n        current_hash\n    );\n    assert(result, \"Turn failed\");\n}\n\n\n#[test]\nfn test_calc_fireball_ff() {\n  // let action_serde = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n  let wait_action = get_wait_action_def();\n    let secrets = [123456789, 9876543210];\n    let test_actions_raw = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000];\n    let test_actions = test_actions_raw.map(|a|a.to_be_bytes());\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, progress: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0, },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, progress: MIN_FIREBALL_ROUNDS_FOR_CAST + 1, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10, last_action: 3, actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, progress: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0,  },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT,actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ]\n    ];\n// x, y & type, health\n// 0x091264 0b2300 0c3400 0a442d 095764 000000000000000000000000000000 // direct\n// 0x091264 0b2319 0c3414 0a4464 095764 000000000000000000000000000000 // turn\n    let mut obs = [ get_default_obstacles(0), get_default_obstacles(1) ];\n    let actions = &[\n        new_action(4, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(1, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 20, y: 3, subtype: ATTACK_RANGED, value: 50, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    let my_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 0x78, radius: 1 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    // event actor x y value subt rad\n    // 0x091264 0b2300 0c3400 0a4428 0b5464 000000000000000000000000000000\n    // 0x0a040b04780201 03040907000000 0004000000000000040000000000000000\n    // 0x0a040b04780201 03040907000000 0004ffff0000000004ffff000000000000\n    // 0x091264 0b2300 0c3400 0a4428 095764000000000000000000000000000000\n    let mut move = 8;\n    let mut actor = Character { //chars[0][4].move(9, 7).set_status(0);\n        id: chars[0][4].id,\n        class: chars[0][4].class,\n        x: get_action_target_x(actions[1]),\n        y: get_action_target_y(actions[1]),\n        target_x: get_action_target_x(actions[1]), // TODO\n        target_y: get_action_target_y(actions[1]),\n        has_been_seen: chars[0][4].has_been_seen,\n        is_hidden: 0 as u1,\n        health: chars[0][4].health,\n        damage_mod: chars[0][4].damage_mod,\n        last_action: get_action_type(actions[1]),\n        progress: 0,\n        status: 0,\n        actions: chars[0][4].actions\n    };\n    //let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut last_hashes = [ 0x2cb6bffa42e22e89cbd87e4ac9ae7a82214febcab9c7b68e33fb1b7b8263ce7d, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 18 + VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 60), chars[side][2].take_damage(ATTACK_FIREBALL, 54), chars[side][3].take_damage(ATTACK_FIREBALL, 60), actor ];\n    let my_obstacles_serialized_for_enemy = serialize_my_obstacles(advances[other_side], obs[side]);\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n    let (serialized_chars_after, serialized_char_actions_after) = serialize_chars(chars_after);\n    // let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes::<32>();\n    // assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = get_data_hash(secrets[side], serialized_chars_after, serialized_char_actions_after, my_obstacles_serialized_for_me);\n\n    // turn:  0x2912640000004b03000000006c04002000008a0428000000a9076400000a\n    // calc:  0x2912640000004b03000000006c04002000008a0428000000a907640b340a\n    let (test_result_object_chars_after_valid, test_result_object_chars_after) = test_result_object_builder(advances[other_side], chars_after, my_obstacles_serialized_for_enemy);\n    let test_result_object_other_side_result = serialize_their_obstacles(advances[side], obs[other_side]);\n    let test_result_object_other_side = test_result_object_other_side_result.1;\n    let (test_result_object_other_chars_valid, test_result_object_other_chars) = test_result_object_builder(advances[side], chars[other_side], test_result_object_other_side);\n    println(\"Test-Inputs:\");\n    // println(secrets[side]);\n    // println(character::serialize_chars(chars[side]));\n    // println(get_test_action_register());\n    // println(my_obstacles_serialized_for_me);\n    // println(serialize_actions(actor.id, actions));\n    // println(move);\n    // println(advances[other_side]);\n    // println(test_result_object_other_chars);\n    // println(serialize_events(their_events));\n    // println(advances[side]);\n    // println(serialize_events(my_events));\n    // println(test_result_object_chars_after);\n    println(last_hashes[side]);\n    println(current_hash);\n    println(\"Test-Inputs done\");\n    assert(test_result_object_chars_after_valid, \"Invalid test result object chars after\");\n    assert(test_result_object_other_chars_valid, \"Invalid test result object other chars\");\n\n    let (serialized_chars_input, serialized_char_actions_input) = serialize_chars(chars[side]);\n\n\n\n    comptime {\n        assert((SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLE_BYTE_SIZE) < 32);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE >= MAX_OBSTACLES);\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        // assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    let my_char_actions = arena_test_action_def_register; //get_test_action_register();\n    println(\"my_char_actions\");\n    println(my_char_actions);\n    println(\"serialized_char_actions_input\");\n    println(serialized_char_actions_input);\n    // [0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071020100a000020100a0000002000000000200000000000000000, 0x02f0000a3b190100200000000000080100002000000000200000000000000000, 0x023100081b161118120a010018120a0100002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071008100a000008100a0000002000000000200000000000000000, 0xf0003f1b1c1100200000000000070200002000000000200000000000000000, 0xff003f1b1c1100200e013f00000e013f002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071018100a000018100a0000002000000000200000000000000000, 0x09f0000130060c00200000000020000000002000000000200000000000000000, 0xf0000110061000100500010010050001002000000000200000000000000000, 0xf00001301c0100100d000000100d0000002000000000200000000000000000, 0x0bf00001100c00002000000000200000000010040a0000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110061028100a000028100a0000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071010100a000010100a0000002000000000200000000000000000, 0xf000071b161100200000000000070500002000000000200000000000000000, 0x6300061b161164150a020164150a0201002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000]\n    // [0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071020100a000020100a0000002000000000200000000000000000, 0x02f0000a3b190100200000000000080100002000000000200000000000000000, 0x023100081b161118120a010018120a0100002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071008100a000008100a0000002000000000200000000000000000, 0xf0003f1b1c1100200000000000070200002000000000200000000000000000, 0xff003f1b1c1100200e013f00000e013f002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071018100a000018100a0000002000000000200000000000000000, 0x09f0000130060c00200000000020000000002000000000200000000000000000, 0xf0000110061000100500010010050001002000000000200000000000000000, 0xf00001301c0100100d000000100d0000002000000000200000000000000000, 0x0bf00001100c00002000000000200000000010040a0000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110061028100a000028100a0000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071010100a000010100a0000002000000000200000000000000000, 0xf000071b161100200000000000070500002000000000200000000000000000, 0x6300061b161164150a020164150a0201002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000]\n\n    let mut success = true;\n    // let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    // assert(secret_be_bytes.len() == 32);\n\n    let gamestate_before_hash = last_hashes[side];\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles);\n    let gamestate_before_hash_calculated_field = hash_serialized_private_state(serialized_chars_input, my_char_actions, my_obstacles_serialized_for_me, secrets[side]);\n    // assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"Invalid pre-hash: {gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    // std::verify_proof(verification_key, proof, public_inputs, key_hash);\n    // let (serialized_actions_valid, serialized_actions_input) = ;\n    let  (turn_calc_valid, serialized_characters, my_char_actions_after, serialized_obstacles, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy) = calculate_turn(\n        serialized_chars_input,\n        arena_test_action_def_register, //serialized_char_actions_input,\n        // get_test_action_register(),\n        my_obstacles_serialized_for_me, //obs[side],\n        serialize_actions(actor.id, actions),\n        move,\n        advances[other_side],\n        test_result_object_other_chars,\n        serialize_events(their_events)\n    );\n    assert(turn_calc_valid, f\"Tun calculation failed\");\n    assert(advances[side] == my_advance_calculated, f\"Invalid result advance:  != {my_advance_calculated}\");\n\nlet my_result_events: [Field; SERIALIZED_EVENTS_ARRAY_SIZE] = serialize_events(my_events);\n    // validate result\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        assert(result_event_should == result_event_calculated, f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\");\n    }\n    // assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    // let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes::<32>();\n    // assert(serialized_characters_be_bytes.len() == 32);\n    debug!(quote {\n        println(f\"serialized_obstacles: {serialized_obstacles}\");\n        println(f\"serialized_obstacles_for_enemy: {serialized_obstacles_for_enemy}\");\n        println(f\"serialized_characters: {serialized_characters}\");\n        // println(f\"serialized_characters_be_bytes: {serialized_characters_be_bytes}\");\n    });\n    // let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    for i in 0..test_result_object_chars_after.len() {\n        let my_result_object = test_result_object_chars_after[i];\n        let serialized_obstacle = serialized_obstacles_for_enemy[i];\n        assert(my_result_object == serialized_obstacle, f\"Invalid result obstacle row {i}: {my_result_object} != {serialized_obstacle}\");\n    }\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(serialized_obstacles);\n    let new_hash_bytes = get_data_hash(secrets[side], serialized_characters, my_char_actions_after, my_obstacles_serialized_for_me);\n    assert(new_hash_bytes == current_hash, f\"Invalid result hash: {new_hash_bytes} != {current_hash}\");\n}\n\n// #[export]\n// pub fn setup_obstacles(\n    \n// )\n\n#[test]\nfn test_calc_turn_0() {\n  let my_chars = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let test_actions = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000]; //.map(|a|a.to_be_bytes());\n  let my_obstacles = [0x62c80162c80362c80462c80563c80564c80565c80567c8000000000000,0x0467c80367c80167c80067c80760c80761c80762c80763c8000000000000,0x0764c80765c80678ff0778ff0579ff0679ff0779ff0879ff000000000000];\n  let my_actions = [0x01000a02030010030000ffff0000ffff000000000000000000000000000000];\n  let move = 0;\n  let enemy_advance = 0;\n  let enemy_objects = [0, 0, 0, 0];\n  let enemy_events = [0x04ffff0000000004ffff0000000004ffff0000000004ffff000000000000];\n\n  let result = calculate_turn(my_chars, test_actions, my_obstacles, my_actions, move, enemy_advance, enemy_objects, enemy_events);\n\n  assert(result.0);\n}\n\nfn test_turn_0() {\n  let secret = 0x075bcd15;\n  let my_chars_input = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let test_actions = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000]; //.map(|a|a.to_be_bytes());\n  let my_obstacles = [0x62c80162c80362c80462c80563c80564c80565c80567c8000000000000,0x0467c80367c80167c80067c80760c80761c80762c80763c8000000000000,0x0764c80765c80678ff0778ff0579ff0679ff0779ff0879ff000000000000];\n  let my_actions = [0x01000a02030010030000ffff0000ffff000000000000000000000000000000];\n  let move = 0;\n  let enemy_advance = 0;\n  let enemy_objects = [0,0,0,0];\n  let enemy_events = [0x04ffff0000000004ffff0000000004ffff0000000004ffff000000000000];\n  let my_result_advance = 0x12;\n  let my_result_objects = [0,0,0,0];\n  let my_result_events = [0xffff0000000000ffff0000000000ffff0000000000ffff000000000000];\n  let initial_hash = 0x07a86579c9d2236bd1c02ced0660e9280e1d9a73146a0c9c8e4d8e27d64d6565;\n  let final_hash = 0x2c7492b9fc2adae465ec974b512f12b29b486e7c268cca2c304330eac57dd680;\n\n  let result = turn(secret, my_chars_input, test_actions, my_obstacles, my_actions, move, enemy_advance, enemy_objects, enemy_events, my_result_advance, my_result_events, my_result_objects, initial_hash, final_hash);\n\n  assert(result);\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/lib.nr"},"76":{"source":"use arenalib::{ WIDTH, HEIGHT, WIDTH_MASK, VIEW_DISTANCE, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES };\nuse crate::obstacle::{ Obstacle, get_obstacle_y, get_obstacle_x, is_obstacle_traversible };\nuse skplg::NOWHERE;\nuse std::collections::bounded_vec;\n\n// pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> bool {\n//     // assert(curr_x < WIDTH);\n//     // assert(curr_y < HEIGHT);\n//     // assert(x < WIDTH);\n//     // assert(y < HEIGHT);\n//     // validating coordinates is not the job of this function\n//     // only avoid overflows!\n\n\n//     let shifted_curr_x = std::wrapping_add(curr_x, 1);\n//     let shifted_curr_y = std::wrapping_add(curr_y, 1);\n//     let shifted_x = std::wrapping_add(x, 1);\n//     let shifted_y = std::wrapping_add(y, 1);\n\n//     ((shifted_curr_x == shifted_x) & (std::wrapping_add(shifted_curr_y, 1) >= shifted_y) & (shifted_curr_y <= std::wrapping_add(shifted_y, 1))) |\n//     ((shifted_curr_y == shifted_y) & (std::wrapping_add(shifted_curr_x, 1) >= shifted_x) & (shifted_curr_x <= std::wrapping_add(shifted_x, 1)))\n// }\n\n// global DISTANCE_TABLE_HEIGHT: u32 = HEIGHT as u32;\n// global DISTANCE_TABLE_WIDTH: u32 = WIDTH as u32;\n\n// unconstrained fn distance_sqrt(x: u32) -> u32 {\n//     let mut result: u32 = 0;\n//     for i in 0..DISTANCE_TABLE_WIDTH {\n//         if i * i == x {\n//             result = i;\n//             break;\n//         }\n//     }\n//     result\n// }\n\n// fn d(a: u8, b: u8) -> u8 {\n//     let d = a as i32 - b as i32;\n//     let d2 = d * d;\n//     assert(d2 >= 0);\n//     let d2u = d2 as u32;\n//     let result = unsafe {\n//         let sq = distance_sqrt(d2u);\n//         assert(sq * sq == d2u);\n//         sq\n//     };\n//     assert(result < DISTANCE_TABLE_WIDTH);\n//     comptime { assert(DISTANCE_TABLE_WIDTH <= 256) };\n//     result as u8\n// }\n// global DISTANCE_TABLE: [[u8; DISTANCE_TABLE_WIDTH]; DISTANCE_TABLE_HEIGHT] = [\n//     [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 2,  2,  3,  4,  5,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ],\n//     [ 3,  3,  3,  4,  4,  5,  6,  7,  8,  9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ],\n// ]\n\nglobal MAX_DISTANCE: u32 = 0xff * 0xff;\npub type DISTANCE = u16;\nfn get_distance_part(curr: u8, target: u8) -> DISTANCE_PART_ROLLED_OUT {\n  let d = if curr > target { curr - target } else { target - curr } as u32;\n  d * d\n}\npub fn get_distance(curr_x: u8, curr_y: u8, x: u8, y: u8) -> DISTANCE {\n    // assert(curr_x < WIDTH);\n    // assert(curr_y < HEIGHT);\n    // assert(x < WIDTH);\n    // assert(y < HEIGHT);\n    // validating coordinates is not the job of this function\n    // only avoid overflows!\n\n    // let dx = unsafe {\n    //     let diff_\n    //     distance_sqrt(x)\n    // }\n\n    let dx = get_distance_part(curr_x, x);\n    let dy = get_distance_part(curr_y, y);\n\n    // let dx = curr_x as i16 - x as i16;\n    // let dy = curr_y as i16 - y as i16;\n  get_distance_from_parts(dx, dy)\n}\n// NOTE: Leaving it for now, but no actual performance benefit from splitting this\npub type DISTANCE_PART_ROLLED_OUT = u32;\nfn get_distance_from_parts(x: DISTANCE_PART_ROLLED_OUT, y: DISTANCE_PART_ROLLED_OUT) -> DISTANCE {\n  let distance = x + y;\n  if distance > MAX_DISTANCE {\n    MAX_DISTANCE as u16\n  } else {\n    distance as u16\n  }\n}\n\n\npub fn is_visible(enemy_advance: u8, x: u8) -> bool {\n    //(x >= enemy_advance) == (side == 0)\n    x >= enemy_advance\n}\n\n// TODO: This is for the future - fireballs, etc. only if we have line of sight\n// pub fn is_visible(curr_x: u8, curr_y: u8, x: u8, y: u8, map: &Map) -> bool {\n//     assert(curr_x < WIDTH);\n//     assert(curr_y < HEIGHT);\n//     assert(x < WIDTH);\n//     assert(y < HEIGHT);\n\n//     let mut x = curr_x as f32;\n//     let mut y = curr_y as f32;\n//     let x2 = x + 0.5;\n//     let y2 = y + 0.5;\n//     let dx = x2 - x;\n//     let dy = y2 - y;\n//     let mut t = 0.0;\n//     let mut max_t = 1.0;\n//     let mut x = x;\n//     let mut y = y;\n\n//     while t < max_t {\n//         let x = x + dx * t;\n//         let y = y + dy * t;\n//         let x = x as u8;\n//         let y = y as u8;\n\n//         if map.is_wall(x, y) {\n//             return false;\n//         }\n\n//         t += 0.1;\n//     }\n\n//     true\n// }\n\npub fn their_x_to_mine(x: u8) -> (bool, u8) {\n    if x == NOWHERE {\n        (true, NOWHERE)\n    } else {\n        (x < WIDTH, std::wrapping_sub(WIDTH - 1, x) & WIDTH_MASK)\n    }\n}\n\npub fn is_distance_within_viewing_range(distance: u16) -> bool {\n  distance <= (VIEW_DISTANCE as u16 * VIEW_DISTANCE as u16)\n}\n\npub fn is_tile_free_or_invisible(x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n  let mut can = true;\n  for i in 0..MAX_OBSTACLES {\n      if !is_obstacle_traversible(obstacles[i]) & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n      if !is_obstacle_traversible(their_obstacles[i]) & (get_obstacle_x(their_obstacles[i]) == x) & (get_obstacle_y(their_obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  can\n}\n\nglobal W: u32 = WIDTH as u32;\nglobal H: u32 = HEIGHT as u32;\nunconstrained fn _get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] {\n  let mut map = [[0; H]; W];\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  map\n}\n\nunconstrained fn _to_obstacle_collision_array(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [(u8, u8, bool); MAX_ENEMY_OBSTACLES * 2] {\n  let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i] = (x,y,is_obstacle_traversible(obstacle));\n\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  o\n}\n\npub fn get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] { // missing own chars\n  // Safety: verifying all map elements afterwards\n  let map = unsafe { _get_free_map(obstacles, their_obstacles) };\n  \n  // Safety: verifying all below\n  //let o = unsafe { _to_obstacle_collision_array(obstacles, their_obstacles) };\n   //let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n\n          if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //o[i] = (x,y,is_obstacle_traversible(obstacle));\n          // assert(o[i].0 == x);\n          // assert(o[i].1 == y);\n          // assert(o[i].2 == is_obstacle_traversible(obstacle));\n\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = their_obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //  o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n\n          // assert(o[i + MAX_ENEMY_OBSTACLES].0 == x);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].1 == y);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].2 == is_obstacle_traversible(obstacle));\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        let mut sum: u32 = 0;\n  for x in 0..WIDTH {\n    for y in 0..HEIGHT {\n      sum += map[x][y] as u32;\n      // let val = map[x][y];\n      // if !val {\n      //   let mut found_obstacle = false;\n\n      //   for i in 0..58 {\n      //     if (x == o[i].0) & (y == o[i].1) & o[i].2 {\n      //       found_obstacle = true;\n      //     }\n      //   }\n\n      //   assert(found_obstacle);\n      // }\n    }\n  }\n  let mut obstacle_sum: u32 = 0;\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    obstacle_sum += (!is_obstacle_traversible(obstacles[i])) as u32 + (!is_obstacle_traversible(their_obstacles[i])) as u32;\n  }\n  assert(sum == obstacle_sum);\n\n  map\n}\n\npub fn can_move_to(distance: u16, x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n    let mut can = is_distance_within_viewing_range(distance); //x <= advance;\n    can &= is_tile_free_or_invisible(x, y, obstacles, their_obstacles);\n\n    can\n}\n// pub fn their_x_to_mine(side: u1, x: i8) -> i8 {\n//     let mul = side as i8;\n//     mul * 31 + 16 + x\n// }\n\n// x * s -16 + y = 0 if s == 0 => y = 16\n// x * s -16 + y = 31 if s == 1 => x = 31\n// y = 31 * s + 16 + x\n// s = 0:\n// x = -16 => y = 0\n// x = 15 => y = 31\n// s = 1:\n// x = -16 => y = 31\n// x = 15 => y = 0\n\n// pub fn serialize_x(x: i8) -> (bool, u8) {\n//     let valid = (x >= -(WIDTH / 2) as i8) & (x < (WIDTH / 2) as i8);\n//     (valid, (x + (WIDTH / 2) as i8) as u8)\n// }\n\n// pub fn deserialize_x(x: u8) -> (bool, i8) {\n//     let valid = x < WIDTH;\n//     (valid, x as i8 - (WIDTH / 2) as i8)\n// }","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/map.nr"},"77":{"source":"// use crate::MAX_OBSTACLES;\n// use crate::{ HEIGHT, WIDTH };\n// use crate::{ EMPTY, WALL, WATER };\n// use crate::{ MAX_EVENTS }; // MAX_CHARACTERS\n// // use crate::{ RECEIVE_ATTACK };\n// // use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\n// use crate::{ SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\n// use crate::event::Event;\n// use crate::map::{ is_visible }; //is_neighbor\n// use dep::std;\n\n// pub struct Obstacle {\n//     pub id: u8,\n//     pub x: u8,             // 5 bit\n//     pub y: u8,             // 4 bit\n//     pub health: u8,        // 8 bit\n//     pub obstacle_type: u8, // 4 bit\n// }\n\n// pub impl Obstacle {\n//     pub fn serialize(self) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         assert(self.y < 0x10, f\"Obstacle y is too large\");\n//         assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n\n//         let packed_y = self.obstacle_type * 0x10 + self.y;\n//         [ self.x, packed_y, self.health]\n//     }\n\n//     pub fn is_obstacle_traversible(self) -> bool {\n//         (self.obstacle_type >= NON_EMPTY_WALKABLE_TILE_MIN) | (self.obstacle_type == EMPTY)\n//     }\n\n//     pub fn parse_their_obstacles(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let health = field[2];\n//         let o = Obstacle {\n//             id: id,\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn parse_obstacle(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let mut health = field[2];\n//         if (obstacle_type == WALL) | (obstacle_type == WATER) {\n//             let mut damage = 0;\n//             for i in 0..MAX_EVENTS {\n//                 damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n//             }\n//             if damage > (health as u16) {\n//                 health = 0;\n//             } else {\n//                 health -= (damage as u8);\n//             }\n//         }\n//         let o = Obstacle {\n//             id: id, // + (MAX_CHARACTERS as u8),\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//             //was_alive: was_alive,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         (self.x < WIDTH) & (self.y < HEIGHT)\n//     }\n\n//     pub fn parse_their_obstacles(serialized_obstacles: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_their_obstacles(id, serialized_obstacle));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn parse_my_obstacles(serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], events: [Event; MAX_EVENTS]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_obstacle(id, serialized_obstacle, events));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn serialize_obstacles(side: u1, enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n//         let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n//         for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//             let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n//                 if is_visible(side, enemy_advance, obstacle.x) {\n//                     let serialized_obstacle = obstacle.serialize();\n//                     for k in 0..3 {\n//                         serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n//                     }\n//                 }\n//             }\n//             serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n//         }\n//         serialized_obstacles\n//     }\n\n//     pub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n//         // assert(side < 2, f\"Side is too large {side}\");\n//         let x = |x| x * (((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n//         [\n//             new_obstacle( 0, x(0), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 1, x(1), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 2, x(3), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 3, x(4), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 4, x(5), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle( 5, x(5), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle( 6, x(5), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle( 7, x(5), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 8, x(4), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 9, x(3), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(10, x(1), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(11, x(0), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(12, x(7), y: 0, obstacle_type: 200, WALL),\n//             new_obstacle(13, x(7), y: 1, obstacle_type: 200, WALL),\n//             new_obstacle(14, x(7), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle(15, x(7), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle(16, x(7), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle(17, x(7), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle(18, x(6), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(19, x(7), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(20, x(5), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(21, x(6), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(22, x(7), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(23, x(8), y: 9, obstacle_type: 255, WATER),\n//         ]\n//     }\n// }\n\n\nuse arenalib::MAX_OBSTACLES;\nuse arenalib::{ HEIGHT, WIDTH };\nuse arenalib::{ EMPTY, WALL, WATER };\nuse arenalib::{ MAX_EVENTS, MAX_HEALTH, MAX_OBSTACLE_TYPE, MAX_ENEMY_OBSTACLES }; // MAX_CHARACTERS\n// use crate::{ RECEIVE_ATTACK };\n// use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\nuse arenalib::{ SerializedArenaEnemyObstacles, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\nuse arenalib::NON_EMPTY_WALKABLE_TILE_MIN;\nuse arenalib::SerializedArenaObstacles;\nuse crate::event::Event;\nuse crate::map::{ is_visible, their_x_to_mine }; //is_neighbor\nuse dep::std;\nuse skplg::{softassert, NOWHERE};\nuse arenalib::SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE;\nuse arenalib::MAX_CHARACTERS;\n\n// pub type Obstacle = [u8; 5];\npub struct Obstacle {\n    pub id: u8,\n    pub x: u8,             // 5 bit\n    pub y: u8,             // 4 bit\n    pub health: u8,        // 8 bit\n    pub obstacle_type: u8, // 4 bit\n}\npub fn get_obstacle_id(obstacle: Obstacle) -> u8 {\n    obstacle.id //obstacle[0]\n}\npub fn get_obstacle_x(obstacle: Obstacle) -> u8 {\n    obstacle.x //[1]\n}\npub fn get_obstacle_y(obstacle: Obstacle) -> u8 {\n    obstacle.y //[2]\n}\npub fn get_obstacle_health(obstacle: Obstacle) -> u8 {\n    obstacle.health //[3]\n}\npub fn get_obstacle_type(obstacle: Obstacle) -> u8 {\n    obstacle.obstacle_type //[4]\n}\n\n#[export]\npub fn new_obstacle(id: u8, x: u8, y: u8, health: u8, obstacle_type: u8) -> pub (bool, Obstacle) {\n  let valid = ((x < WIDTH) | (x == NOWHERE)) & ((y < HEIGHT) | (y == NOWHERE)) & (health <= MAX_HEALTH) & (obstacle_type <= MAX_OBSTACLE_TYPE) & (id as u32 < (MAX_OBSTACLES + MAX_CHARACTERS));\n    // let mut valid = true;\n    // softassert!(quote { valid }, quote { (x < WIDTH) | (x == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid x: {x} >= {WIDTH}\" });\n    // softassert!(quote { valid }, quote { (y < HEIGHT) | (y == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid y: {y} >= {HEIGHT}\" });\n    // softassert!(quote { valid }, quote { health <= MAX_HEALTH }, quote { f\"Cannot create Obstacle: Invalid health: {health} > {MAX_HEALTH}\" });\n    // softassert!(quote { valid }, quote { obstacle_type <= MAX_OBSTACLE_TYPE }, quote { f\"Cannot create Obstacle: Invalid obstacle type: {obstacle_type} > {MAX_OBSTACLE_TYPE}\" }); //TODO: not sure if this or is_valid???\n    // (valid, [ id, x, y, health, obstacle_type ])\n    (valid, Obstacle { id: id, x: x, y: y, health: health, obstacle_type: obstacle_type })\n}\n\n#[test]\nfn test_new_obstacle() {\n  let (val, o) = new_obstacle(0, 0, 2, 0xc8, 0x06);\n  assert(val);\n  assert(o.id == 0);\n}\n\n// #[export]\n// pub struct FrontendObstacle {\n//   pub id: u8,\n//   pub x: u8,\n//   pub y: u8,\n\n// }\n\npub fn serialize_obstacle(obstacle: Obstacle) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n    // we could assert here, since obstacles can only be create with new_obstacle?!\n    // assert(self.y < 0x10, f\"Obstacle y is too large\");\n    // assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n    comptime {\n        let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let packed_y = get_obstacle_type(obstacle) * 0x10 + get_obstacle_y(obstacle);\n                [ get_obstacle_x(obstacle), packed_y, get_obstacle_health(obstacle)]\n            }\n        } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n                [ get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_health(obstacle), get_obstacle_type(obstacle)]\n            }\n        } else {\n            quote {\n                assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n            }\n        };\n        q\n    }\n}\n\npub fn is_obstacle_traversible(obstacle: Obstacle) -> bool {\n    (get_obstacle_type(obstacle) >= NON_EMPTY_WALKABLE_TILE_MIN) | (get_obstacle_type(obstacle) == EMPTY)\n}\n\npub fn parse_their_obstacle(id: u8, fld: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> (bool, Obstacle) {\n    comptime {\n        assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n    }\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let mut valid = true;\n    let x_raw = fld[0];\n    let (x_parsed_valid, x_parsed) = their_x_to_mine(x_raw);\n    softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to convert their x to mine of their obstacle {id}: {x_raw}\" });\n    let y = fld[1] & 0x0F;\n    let obstacle_type = (fld[1]) / 0x10;\n    let health = fld[2];\n    let (obstacle_valid, obstacle) = new_obstacle(id, x_parsed, y, health, obstacle_type);\n    softassert!(quote { valid }, quote { obstacle_valid }, quote { f\"Failed to create new obstacle {id}, {x_parsed}, {y}, {health}, {obstacle_type}\" });\n    (valid, obstacle)\n    // let o = Obstacle {\n    //     id: id,\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn parse_obstacle(id: u8, f: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> (bool, Obstacle) {\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let x = f[0];\n    // let mut y = f[1];\n    // let mut obstacle_type = f[1];\n    // comptime {\n    //     let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n    //         quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let y = f[1] & 0x0F;\n                let obstacle_type = (f[1]) / 0x10;\n    //         }\n    //     } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n    //         quote {\n    //             assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n    //             y = f[1];\n    //             obstacle_type = f[3];\n    //         }\n    //     } else {\n    //         quote {\n    //             assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n    //         }\n    //     };\n    //     q\n    // }\n    // let y = f[1]; // & 0x0F;\n    // let obstacle_type = f[3]; //f[1] / 0x10;// (f[1] & 0xF0) / 0x10;\n    let mut health = f[2];\n    //if (obstacle_type == WALL) | (obstacle_type == WATER) {\n        let mut damage = 0;\n        for i in 0..MAX_EVENTS {\n            damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n        }\n        if damage > (health as u16) {\n            health = 0;\n        } else {\n            health -= (damage as u8);\n        }\n    //}\n    new_obstacle(id, x, y, health, obstacle_type)\n    // let o = Obstacle {\n    //     id: id, // + (MAX_CHARACTERS as u8),\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    //     //was_alive: was_alive,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn is_obstacle_valid(obstacle: Obstacle) -> bool {\n    (get_obstacle_x(obstacle) < WIDTH) & (get_obstacle_y(obstacle) < HEIGHT)\n}\n\n#[export]\npub fn parse_their_obstacles(serialized_obstacles: SerializedArenaEnemyObstacles) -> (bool, [Obstacle; MAX_ENEMY_OBSTACLES]) {\n  let (dummy_obstacle_valid, dummy_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, 255, 0);\n  assert(dummy_obstacle_valid);\n    let mut obstacles: [Obstacle; MAX_ENEMY_OBSTACLES] = [dummy_obstacle; MAX_ENEMY_OBSTACLES];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n            obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j] = obstacle; //s.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    let serialized_obstacle_field = serialized_obstacles[SERIALIZED_OBSTACLES_ARRAY_SIZE].to_be_bytes::<32>();\n    assert(serialized_obstacle_field.len() == 32);\n    for j in 0..MAX_CHARACTERS {\n      let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n      // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n      let id = (MAX_OBSTACLES + j) as u8;\n      let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n      obstacles[MAX_OBSTACLES + j] = obstacle; //s.push_back(obstacle);\n      valid_result = valid_result & valid;\n    }\n    (valid_result, obstacles)\n}\n\npub fn parse_my_obstacles(serialized_obstacles: SerializedArenaObstacles, events: [Event; MAX_EVENTS]) -> (bool, [Obstacle; MAX_OBSTACLES]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            //let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_obstacle(id, serialized_obstacle, events);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles.as_array())\n}\n\n#[export]\npub fn serialize_my_obstacles_for_me(obstacles: [Obstacle; MAX_OBSTACLES]) -> pub [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            let serialized_obstacle = serialize_obstacle(obstacle);\n            for k in 0..3 {\n                serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\n\npub fn serialize_my_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let serialized_obstacle = serialize_obstacle(obstacle);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\npub fn serialize_their_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) {\n    let mut valid_result = true;\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let parsed_x = their_x_to_mine(get_obstacle_x(obstacle));\n                valid_result = valid_result & parsed_x.0;\n                let mirrored_obstacle = new_obstacle(\n                    get_obstacle_id(obstacle),\n                    parsed_x.1,\n                    get_obstacle_y(obstacle),\n                    get_obstacle_health(obstacle),\n                    get_obstacle_type(obstacle)\n                );\n                valid_result = valid_result & mirrored_obstacle.0;\n                let serialized_obstacle = serialize_obstacle(mirrored_obstacle.1);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    (valid_result, serialized_obstacles)\n}\n\nfn get_x_of_side(side: u1, x: u8) -> u8 {\n    x * ((side as u8 + 1) as u1) as u8 + side as u8 * (WIDTH - 1 - x)\n}\n\n#[test]\nfn test_x() {\n    let x8s0 = get_x_of_side(0, 8);\n    assert(x8s0 == 8, f\"{x8s0} != 8\");\n    let x8s1 = get_x_of_side(1, 8);\n    assert(x8s1 == 23, f\"{x8s1} != 23\");\n}\n\npub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n    // assert(side < 2, f\"Side is too large {side}\");\n    let x = |x| get_x_of_side(side, x); //(((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n    [\n        new_obstacle( 0, x(0), 2, 200, WALL).1,\n        new_obstacle( 1, x(1), 2, 200, WALL).1,\n        new_obstacle( 2, x(3), 2, 200, WALL).1,\n        new_obstacle( 3, x(4), 2, 200, WALL).1,\n        new_obstacle( 4, x(5), 3, 200, WALL).1,\n        new_obstacle( 5, x(5), 4, 200, WALL).1,\n        new_obstacle( 6, x(5), 5, 200, WALL).1,\n        new_obstacle( 7, x(5), 7, 200, WALL).1,\n        new_obstacle( 8, x(4), 7, 200, WALL).1,\n        new_obstacle( 9, x(3), 7, 200, WALL).1,\n        new_obstacle(10, x(1), 7, 200, WALL).1,\n        new_obstacle(11, x(0), 7, 200, WALL).1,\n        new_obstacle(12, x(7), 0, 200, WALL).1,\n        new_obstacle(13, x(7), 1, 200, WALL).1,\n        new_obstacle(14, x(7), 2, 200, WALL).1,\n        new_obstacle(15, x(7), 3, 200, WALL).1,\n        new_obstacle(16, x(7), 4, 200, WALL).1,\n        new_obstacle(17, x(7), 5, 200, WALL).1,\n        new_obstacle(18, x(6), 8, 255, WATER).1,\n        new_obstacle(19, x(7), 8, 255, WATER).1,\n        new_obstacle(20, x(5), 9, 255, WATER).1,\n        new_obstacle(21, x(6), 9, 255, WATER).1,\n        new_obstacle(22, x(7), 9, 255, WATER).1,\n        new_obstacle(23, x(8), 9, 255, WATER).1,\n        // new_obstacle(24, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(25, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(26, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(27, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(28, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(29, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(30, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(31, x(0), 0, 255, EMPTY).1,\n    ]\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/obstacle.nr"},"90":{"source":"use dep::std::{append::Append};\nuse skplg::UNREADABLE_BYTES_PER_FIELD;\n\npub trait ActionDefinitionPartBuilder<T> { fn new() -> T; }\npub type DEF_ROW<T> = (Quoted, u8, T);\npub comptime fn get_def_register_value(register: Quoted, bytes: u32, bits: u8, bitsize: u8) -> Quoted {\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    if bitsize == 8 {\n      quote { $register[$bytes] }\n      // quote { ($register / $multiplier) as u8 }\n    } else {\n      let divisor = 1 << bits;\n      let mask = std::wrapping_sub(1 << bitsize, 1);\n      if bitsize == 1 {\n        // quote { (($register / $multiplier) as u1) == 1 }\n        quote { (($register[$bytes] as u8 & $divisor as u8) != 0 as u8) }\n      } else {\n        quote { (($register[$bytes] as u8 / $divisor as u8) & $mask as u8) }\n        // quote { (($register / $multiplier) as u8) & $mask as u8 }\n      }\n    }\n}\npub comptime fn build_over_def_array<Env, T>(array: [DEF_ROW<T>], base_index: u32, builder: fn[Env] (u32, u8, Quoted, u8, T) -> Quoted) -> Quoted {\n  let mut result = quote {};\n  \n  let mut bits: u8 = 0;\n  let mut bytes: u32 = base_index;\n\n  for i in 0..array.len() {\n    let (varname, bitsize, args) = array[i];\n    assert(bitsize <= 8, f\"Invalid bit size: {bitsize}\");\n    if (bits + bitsize) > 8 {\n      bytes += 1;\n      bits = 0;\n    }\n    assert(bits < 8, f\"bits must not reach 8 or higher: {bits}\");\n\n    let new_result = builder(bytes, bits, varname, bitsize, args);\n    result = quote { $result $new_result };\n\n    bits += bitsize;\n  }\n  result\n}\npub comptime fn derive_action_def_def_builder<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let mut params: [(Quoted, Type)] = &[];\n  let mut last_byte: u32 = 0;\n  let mut result: Quoted = build_over_def_array(array, 0, |bytes, bits, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { u8 }.as_type() } else { quote { u8 }.as_type() };\n    params = params.push_back((varname, t));\n    let mut r = quote {};\n    if bytes != last_byte {\n      r = r.append(quote { , });\n    } else if (bytes + bits as u32) != 0 {\n      r = r.append(quote { + });\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = r.append(quote { $varname  });\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = r.append(quote { $varname as u8 * $multiplier });\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = r.append(quote { (( $varname & $mask ) * $multiplier) });\n      }\n    }\n    last_byte = bytes;\n    r\n  });\n  f.set_parameters(params);\n\n  let return_type = f.return_type();\n\n  f.set_body(quote { $return_type { register: [ $result ] } }.as_expr().unwrap());\n  // println(f.body());\n}\npub comptime fn get_action_def_def_register_size<T>(array: [DEF_ROW<T>]) -> u32 {\n  let mut size = 0;\n  let _ = build_over_def_array(array, 0, |bytes, _, _, _, _|{\n    size = bytes;\n    quote {}\n  });\n  size + 1\n}\npub comptime fn get_action_def_def_register_element_type() -> Type {\n  quote { u8 }.as_type()\n}\npub comptime fn get_action_def_def_register_type<T>(array: [DEF_ROW<T>]) -> Type {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  quote { [$et; $size] }.as_type()\n}\npub comptime fn derive_action_def_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  // let size = get_action_def_requirements_register_size();\n  let fields = s.fields([]);\n  assert(fields.len() == 1);\n  s.set_fields([(fields[0].0, get_action_def_def_register_type(array))]);\n}\npub comptime fn derive_action_def_def_struct_new<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  let t = get_action_def_def_register_type(array);\n  f.set_return_type(t);\n  f.set_body(quote { ActionRequirement { [0 as $et; $size] } }.as_expr().unwrap());\n}\npub comptime fn derive_frontend_action_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  let mut fields: [(Quoted, Type)] = &[];\n  let _ = build_over_def_array(array, UNREADABLE_BYTES_PER_FIELD, |_, _, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    fields = fields.push_back((varname, t));\n    quote {}\n  });\n  s.set_fields(fields);\n}\npub comptime fn derive_frontend_action_def_struct_builder<T>(param_name: Quoted, base_index: u32, array: [DEF_ROW<T>]) -> Quoted {\n  // let mut params: [(Quoted, Type)] = &[];\n  let mut first = true;\n  let mut result: Quoted = build_over_def_array(array, base_index, |bytes, bits, varname, bitsize, _|{\n    // let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    // params = params.push_back((varname, t));\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    let mut r = quote {};\n    if !first {\n      r = quote { , };\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = quote { $r $varname: $param_name[$bytes] };\n      // r = quote { $r $varname: ($param_name / $multiplier) as u8 };\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = quote { $r $varname: ($param_name[$bytes] & $multiplier) != 0 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u1) == 1 };\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = quote { $r $varname: (( $param_name[$bytes] / $multiplier) & $mask ) as u8 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u8) & $mask as u8 };\n      }\n    }\n    first = false;\n    r\n  });\n  // f.set_parameters(params);\n\n  // let return_type = f.return_type();\n  // // f.set_return_type(return_type.as_type());\n  // f.set_return_data();\n  // f.set_return_public(true);\n  // // println(result);\n  // f.\nresult\n  // quote {  $result } };\n}\n\n// pub global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2; // u2\n\n// global YES: u8 = 1;\n// global NO: u8 = 0;\n// global MIN_STATUS: u8 = 0;\n// global MAX_STATUS: u8 = 15;\n\n// // pub type ActionDefinitionRegister = \n// pub fn build_action_def_requirements_none() -> ActionRequirement {\n//   build_action_def_requirements(\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     MIN_STATUS,\n//     MAX_STATUS,\n//     0 as u8,\n//     255 as u8)\n// }\n// pub fn build_action_def_pre_calc_effects_idle() -> ActionPreCalcEffect {\n//   build_action_def_pre_calc_effect(\n//     WAIT,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1)\n// }\n// // comptime fn no_requirements() -> CtString {\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1, \n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         0 as u8,\n// //         NO as u1)\n// // }\n// pub fn build_action_def_result_event_none() -> ActionResultEvent {\n//   build_action_def_result_event(\n//     0,\n//     0,\n//     ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//     NO_EVENT,\n//     NO_EVENT,\n//     0 as u8\n//   )\n// }\n// // comptime fn no_event() -> CtString {\n// //     build_action_event_def(NO_EVENT, NO_EVENT, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 0 as u8)\n// // }\n// pub fn build_wait_action_def() -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements_none(),\n//     build_action_def_pre_calc_effects_idle(),\n//     build_action_def_result_effects(\n//       0 as u8,\n//       0 as u8,\n//       1 as u8,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_wait_action_def() -> CtString {\n// //     build_action_def(\n// //         no_requirements(),\n// //         no_event(),\n// //         no_event(),\n// //         1 as u8,\n// //         0 as u8,\n// //         ACTION_RESULT_COORDINATES_IDX_SELF,\n// //         NO as u1,\n// //         WAIT\n// //     )\n// // }\n// // pub global WAIT_ACTION: ActionDefinition = comptime { let x = build_wait_action_def(); f\"[{x}]\".quoted_contents() };\n// pub fn build_sneak_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0 as u8,\n//       1 as u8),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0 as u8,\n//       0 as u8,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       YES as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_sneak_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     no_event(), // TODO: not sure if on-seen we should not send a move event instead - that way one could sneak and stay hidden, but not sneak while visible\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_move_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       1),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_MOVE,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_move_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_MOVE, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_cast_action(this_action_id: u8, energy: u8, class: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_CAST,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_cast_action(this_action_id: u8, energy: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_CAST, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_ritual_action(cast_action_id: u8, energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       RITUAL_ROUNDS_FOR_WIN,\n//       MAX_STATUS,\n//       0,\n//       255),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_ritual_action(this_action_id: u8, energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         RITUAL_ROUNDS_FOR_WIN,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 255 as u8),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 255 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1), // TODO: Maybe set this to handle friendly fire???\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     cast_action_id)\n// // }\n// pub fn build_search_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_search_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS, // should be max of shoot\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_DRAW,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_DRAW, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       draw_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     draw_action_id)\n// // }\n// pub fn build_disarm_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_disarm_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_set_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         ADD_OBSTACLE,\n//         TRAP,\n//         0),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_set_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         YES as u1),\n// //     no_event(),\n// //     build_action_event_def(ADD_OBSTACLE, TRAP, 0 as u8, 50 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n\n// // pub fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // fn get_action_needs_target_free_space(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// // }\n// // fn get_action_needs_target_is_not_self(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// // }\n// // fn get_action_needs_status_visible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// // }\n// // fn get_action_needs_status_invisible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// // }\n// // fn get_action_needs_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_sets_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_removes_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_max_range(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_MAX_RANGE]\n// // }\n// // fn get_action_needs_min_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MIN_STATUS]\n// // }\n// // fn get_action_needs_max_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MAX_STATUS]\n// // }\n// // fn get_action_needed_energy(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDED_ENERGY]\n// // }\n// // fn get_action_unseen_event_is_internal(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_EVENT_IS_TRAP] == 1\n// // }\n// // fn get_action_result_event_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_event_not_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_not_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_not_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_not_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_not_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_not_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_status_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// // }\n// // fn get_action_move_to_target(action: ActionDefinition) -> u1 {\n// //     action.register[action.base_index + ACTION_MOVE_TO_TARGET] as u1\n// // }\n// // fn get_action_is_continuous(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_IS_CONTINUOUS] == 1\n// // }\n// // fn get_action_needs_previous_action(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_PREVIOUS_ACTION] as u8\n// // }\n\n// // pub global ACTION_DEFINITION_SIZE: u32 = (ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 5) as u32; // 2 bytes for move_to_target and status_multiplier\n// // pub global ACTION_DEFINITION_REGISTER_SIZE: u32 = ACTION_DEFINITION_SIZE * (1 + (MAX_ACTIONS_PER_CHARACTER - 1) * (CLASS_COUNT - 1));\n\n// // fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // pub struct ActionDefinitionRegister {\n// //   register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinitionRegister {\n// //   pub fn new(register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinitionRegister {\n// //     ActionDefinitionRegister {\n// //       register: register\n// //     }\n// //   }\n\n// //   pub fn resolve_action(self, action: Action) -> ActionDefinition {\n// //     ActionDefinition {\n// //       base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //       action: action,\n// //       register: self.register\n// //     }\n// //   }\n// // }\n\n// // pub struct ActionDefinition {\n// //     base_index: u16,\n// //     action: Action,\n// //     register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinition {\n// //     pub fn new(action: Action, register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinition {\n// //         ActionDefinition {\n// //             base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //             action: action,\n// //             register: register\n// //         }\n// //     }\n// // }\n\n// // impl ResolvedAction for ActionDefinition {\n// //     fn get_action_needs_target_free_space(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: ActionDefinition) -> u1 {\n// //         self.register[self.base_index + ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n\n// // pub struct TestActionDefinition {\n// //     pub register: [u8; ACTION_DEFINITION_SIZE],\n// //     pub action: Action,\n// // }\n\n// // impl ResolvedAction for TestActionDefinition {\n// //     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n// //         self.register[ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n// // #[test]\n// // fn test_execute_action() {\n// //     let action = build_test_action_def!(build_move_action(4), quote { 1, 2, 3, 4 }); //new_action(1, 2, 3, 4);\n// //     let my_advance = 10;\n// //     let their_advance = 1;\n// //     let actor = Character {\n// //         id: 2,\n// //         x: 2,\n// //         y: 4,\n// //         target_x: 0,\n// //         target_y: 0,\n// //         health: 255,\n// //         damage_mod: 1,\n// //         last_action: WAIT,\n// //         class: MAGE,\n// //         is_hidden: 0 as u1,\n// //         has_been_seen: true,\n// //         status: 0,\n// //         actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]\n// //     };\n// //     let energy = 15;\n// //     let my_obstacles = get_default_obstacles(0);\n// //     let their_obstacles = get_default_obstacles(1);\n// //     let (valid, event, internal_event, c, result_energy) = execute_action(\n// //         action,\n// //         my_advance,\n// //         their_advance,\n// //         actor,\n// //         energy,\n// //         my_obstacles,\n// //         their_obstacles\n// //     );\n// //     assert(valid, \"valid\");\n// //     assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n// //     assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n// //     assert(event.x == action.get_action_target_x(), f\"{event}.target_x is not action target x\");\n// //     assert(event.y == action.get_action_target_y(), f\"{event}.target_y is not action target y\");\n// //     assert(c.x == event.x, f\"{c}.x is not action target x\");\n// //     assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n// //     assert(result_energy == 11, f\"{result_energy} != 11\");\n// // }\n\n// // #[export]\n// // pub fn build_action_register(actions: [])\n\npub type CharacterActionDefinition = [u8; 32];\npub type CharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [CharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedCharacterActionDefinition = Field;\npub type SerializedCharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedRosterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32, let MAX_CHARACTERS: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS];","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionDefinition.nr"},"91":{"source":"// pub type ActionResultEffects = (bool, bool, bool, bool);\n// pub comptime fn to_action_result_effect(set_hidden: bool, remove_hidden: bool, move_to_target: bool, continuous: bool) -> Quoted {\n//     quote { ($set_hidden, $remove_hidden, $move_to_target, $continuous ) }\n// }\n\n// pub comptime fn get_sets_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_removes_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_move_to_target_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_is_continuous_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse crate::actionRequirements::{get_action_def_requirements_base_index, get_action_def_requirements_byte_size};\nuse std::append::Append;\n\n\npub type ActionDefDefPreCalcEffect = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefPreCalcEffect> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_PRE_CALC_EFFECTS: [DEF_ROW<ActionDefDefPreCalcEffect>] = [\n    action_def_def(quote { pre_calc_effect_continues_action }, 3, |continued_action|quote { let continues_action: bool = $continued_action as u8 == actor_last_action; }),\n    action_def_def(quote { pre_calc_effect_is_continuous }, 1, |is_continuous|quote { let is_continuous: bool = $is_continuous as bool; }),\n    action_def_def(quote { pre_calc_effect_interrupts }, 1, |is_interrupting|quote { let is_interrupting: bool = $is_interrupting as bool; }),\n    action_def_def(quote { pre_calc_effect_allow_retargeting }, 1, |allows_retargetting|quote { let not_interrupted_through_retargeting: bool = $allows_retargetting as bool | ((action_target_x == actor_target_x) & (action_target_y == actor_target_y)); })\n];\npub comptime fn get_action_def_pre_calc_base_index() -> u32 {\n  get_action_def_requirements_byte_size()+get_action_def_requirements_base_index()\n}\n\npub comptime fn get_action_def_pre_calc_effects_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_PRE_CALC_EFFECTS)\n}\n\ncomptime fn derive_action_def_def_pre_calc_event_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n// }\n#[derive_action_def_def_pre_calc_event_struct]\npub struct ActionPreCalcEffect {\n  pub register: [u8; 32]\n}\nimpl ActionPreCalcEffect {\n  #[derive_action_def_pre_calc_effect_struct_new]\n  pub fn new() -> ActionPreCalcEffect {\n    ActionPreCalcEffect { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_pre_calc_effect_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n#[export]\n#[derive_action_def_def_pre_calc_effect_builder]\npub fn build_action_def_pre_calc_effect() -> pub ActionPreCalcEffect { ActionPreCalcEffect::new() }\n\npub comptime fn apply_action_pre_calc_effects(register: Quoted) -> Quoted {\n  let base_index = get_action_def_pre_calc_base_index();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_PRE_CALC_EFFECTS, base_index, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n  quote {\n    $result\n    is_not_interrupted = (\n      ((!is_continuous) as u8 * (!is_interrupting) as u8) + // that's the ID of the wait action => leave status, but not continuous\n      ((is_continuous) as u8 * continues_action as u8 * not_interrupted_through_retargeting as u8)\n    ) > 0;\n\n    actor_progress *= is_not_interrupted as u8;\n  }\n}\n\npub comptime fn set_action_def_pre_calc_effects_in_action_def(effects: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_pre_calc_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_pre_calc_effects_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $effects.register[$i]; });\n    // result = quote { $result $action_def += $effects.register[$i] as Field * $multiplier; };\n    // multiplier *= 2;\n  }\n  result\n}\n\ncomptime fn derive_frontend_action_def_pre_calc_effects_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n#[derive_frontend_action_def_pre_calc_effects_struct]\n#[derive(Default)]\npub struct FrontendActionDefPreCalcEffects {}\n\n\npub comptime fn derive_frontend_action_def_pre_calc_effects_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_pre_calc_base_index(), ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n  quote { FrontendActionDefPreCalcEffects { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionPreCalcEffect.nr"},"92":{"source":"use skplg::{UNREADABLE_BYTES_PER_FIELD, softassert};\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse std::append::Append;\nuse crate::{actionDefinition::derive_frontend_action_def_struct, actionDefinition::derive_frontend_action_def_struct_builder};\n\n    // fn get_action_req_target_free_space(self) -> bool;\n    // fn get_action_req_target_is_not_self(self) -> bool;\n    // fn get_action_req_status_visible(self) -> bool;\n    // fn get_action_req_status_invisible(self) -> bool;\n    // fn get_action_req_status_hidden(self) -> bool;\n    // fn get_action_req_max_range(self) -> u8;\n    // fn get_action_req_min_status(self) -> u8;\n    // fn get_action_req_max_status(self) -> u8;\n    // fn get_action_req_energy(self) -> u8;\n    // fn get_action_req_previous_action(self) -> u8;\npub type ActionDefDefRequirementCheck = (Quoted, Quoted);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, expr: Quoted, msg: Quoted) -> DEF_ROW<ActionDefDefRequirementCheck> {\n    (varname, bit_size, (expr, msg))\n}\n// comptime global ACTION_DEF_DEF_FIELD_COUNT: u32 = 11;\nglobal ACTION_DEF_DEF_REQUIREMENTS: [DEF_ROW<ActionDefDefRequirementCheck>] = [\n    action_def_def(quote { action_req_target_free_space }, 1, quote { could_move_to_target }, quote { f\"Target space cannot be moved to {action_target_x},{action_target_y}) cannot be moved to: {VIEW_DISTANCE},{my_obstacles},{their_obstacles}\" }),\n    action_def_def(quote { action_req_target_is_not_self }, 1, quote { (actor_x != action_target_x) | (actor_y != action_target_y) }, quote { f\"Target cannot be self ({action_target_x},{action_target_y})\" }),\n    action_def_def(quote { action_req_status_visible }, 1, quote { actor_is_in_view_range & !actor_is_hidden },  quote { f\"Character must be fully visible for action {action_type}: in_view_range: {actor_is_in_view_range} & !hidden {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_invisible }, 1, quote { !actor_is_in_view_range | actor_is_hidden }, quote { f\"Character must not be visible to perform action {action_type}: !in_view_range: {actor_is_in_view_range} || hidden: {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_hidden }, 1, quote { actor_is_hidden }, quote { f\"Character needs to be hidden to perform action {action_type}\" }),\n    // action_def_def(quote { action_req_previous_action }, 3, quote { true }, quote { f\"\" }),\n    action_def_def(quote { action_req_min_progress }, 4, quote { action_req_min_progress as u8 <= actor_progress as u8 }, quote { f\"Character needs min progress {action_req_min_progress} to perform action {action_type}, but only has {actor_progress}\" }),\n    action_def_def(quote { action_req_max_progress }, 4, quote { action_req_max_progress as u8 >= actor_progress as u8 }, quote { f\"Character cannot have a higher progress than {action_req_max_progress} to perform action {action_type}: got {actor_progress}\" }),\n    action_def_def(quote { action_req_status }, 4, quote { (action_req_status as u8 == 0 as u8) | (action_req_status as u8 == actor_progress as u8) }, quote { f\"Character can only perform action {action_type} while having status {action_req_status}. Invalid status {actor_status}\" }),\n    // action_def_def(quote { action_req_required_energy }, 4, quote { action_req_required_energy <= energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_req_required_energy}\" }),\n    action_def_def(quote { action_req_max_range }, 8, quote { distance as u16 <= (action_req_max_range as u16) * (action_req_max_range as u16) }, quote { f\"Character is out of range! Distance: {distance} > {action_req_max_range}: {{{actor_x},{actor_y}}} - {{{action_target_x},{action_target_y}}} with {action_req_max_range}\" }),\n];\npub comptime fn get_action_def_requirements_base_index() -> u32 {\n  UNREADABLE_BYTES_PER_FIELD as u32\n}\n\npub comptime fn get_action_def_requirements_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_REQUIREMENTS)\n}\n\ncomptime fn derive_action_def_def_req_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n// comptime fn derive_action_def_requirements_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_REQUIREMENTS);\n// }\n\n#[derive_action_def_def_req_struct]\npub struct ActionRequirement {\n  pub register: [u8; 32]\n}\nimpl ActionRequirement {\n  #[derive_action_def_requirements_struct_new()]\n  pub fn new() -> ActionRequirement {\n    ActionRequirement { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_req_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[export]\n#[derive_action_def_def_req_builder]\npub fn build_action_def_requirements() -> pub ActionRequirement { ActionRequirement::new() }\n\npub comptime fn validate_action_requirements(valid_varname: Quoted, register: Quoted) -> Quoted {\n  let mut result = build_over_def_array(ACTION_DEF_DEF_REQUIREMENTS, get_action_def_requirements_base_index(), |bytes, bits, varname, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    // let varname = f\"action_requirement_{i}_is_valid\".quoted_contents();\n    let (checkexpr, msg) = args;\n    let check = if bitsize == 1 { quote { !($varname as bool) | ($checkexpr) } } else { quote { $checkexpr } };\n    let sa = softassert(valid_varname, check, msg);\n    quote {\n      let $varname = $expr;\n      $sa\n    }\n  });\n  // println(result);\n  // quote { assert(1==1); }\n  result\n}\n\npub comptime fn set_action_def_requirements_in_action_def(requirements: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_requirements_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_requirements_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $requirements.register[$i]; });\n    // result = quote { $result $action_def += $requirements.register[$i] as Field * $multiplier; };\n    // multiplier *= 2.pow_32(8);\n  }\n  // println(result);\n  result\n}\n\ncomptime fn derive_frontend_action_def_requirements_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[derive_frontend_action_def_requirements_struct]\n#[derive(Default)]\npub struct FrontendActionDefRequirements {}\n\n\npub comptime fn derive_frontend_action_def_requirements_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_requirements_base_index(), ACTION_DEF_DEF_REQUIREMENTS);\n  // println(content);\n  quote { FrontendActionDefRequirements { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionRequirements.nr"},"93":{"source":"// pub type ActionResultEffects = (bool, bool, bool, bool);\n// pub comptime fn to_action_result_effect(set_hidden: bool, remove_hidden: bool, move_to_target: bool, continuous: bool) -> Quoted {\n//     quote { ($set_hidden, $remove_hidden, $move_to_target, $continuous ) }\n// }\n\n// pub comptime fn get_sets_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_removes_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_move_to_target_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_is_continuous_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse skplg::softassert;\nuse crate::actionPreCalcEffect::{get_action_def_pre_calc_base_index, get_action_def_pre_calc_effects_byte_size};\nuse std::append::Append;\n\npub type ActionDefDefPreCalcEffect = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefPreCalcEffect> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_RESULT_EFFECTS: [DEF_ROW<ActionDefDefPreCalcEffect>] = [\n    action_def_def(quote { action_result_required_energy }, 4, |action_required_energy|{\n      let check = softassert(quote { is_valid }, quote { action_required_energy <= result_energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_required_energy}\" });\n      quote {\n        let action_required_energy = $action_required_energy;\n        $check\n        result_energy = std::wrapping_sub(result_energy, action_required_energy);\n      }\n    }),\n    action_def_def(quote { action_result_progress_increment }, 4, |progress_increment|quote { let action_result_effect_progress_increment: u32 = $progress_increment as u32; }),\n    action_def_def(quote { action_result_progress_multiplier }, 2, |progress_multiplier|quote { let action_result_effect_progress_multiplier: u32 = $progress_multiplier as u32; }),\n    action_def_def(quote { action_result_move_to_target }, 1, |move_to_target|quote { result_coords = coords[$move_to_target as u8]; }),\n    action_def_def(quote { action_result_hide }, 1, |hide|quote { let action_result_effect_hide: bool = $hide as bool; }),\n    action_def_def(quote { action_result_reveal }, 1, |leave_shadows|quote { let action_result_effect_leave_shadows: bool = $leave_shadows as bool; })\n];\npub comptime fn get_action_def_result_effect_base_index() -> u32 {\n  get_action_def_pre_calc_base_index() + get_action_def_pre_calc_effects_byte_size()\n}\n\npub comptime fn get_action_def_result_effects_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_RESULT_EFFECTS)\n}\n\ncomptime fn derive_action_def_def_result_effect_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n// }\n#[derive_action_def_def_result_effect_struct]\npub struct ActionResultEffect {\n  pub register: [u8; 32]\n}\nimpl ActionResultEffect {\n  //#[derive_action_def_result_effects_struct_new]\n  pub fn new() -> ActionResultEffect {\n    ActionResultEffect { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_result_effects_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[export]\n#[derive_action_def_def_result_effects_builder]\npub fn build_action_def_result_effects() -> pub ActionResultEffect { ActionResultEffect::new() }\n\npub comptime fn apply_action_result_effects(register: Quoted) -> Quoted {\n  let base_index = get_action_def_result_effect_base_index();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_RESULT_EFFECTS, base_index, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n// println(result);\n  quote {\n    $result\n\n    let result_progress_raw = actor_progress as u32 * action_result_effect_progress_multiplier + action_result_effect_progress_increment;\n    //softassert!(quote { is_valid }, quote { result_progress_raw <= MAX_PROGRESS as u32 }, quote { f\"Invalid result progress: {result_progress_raw} > {MAX_PROGRESS}\" });\n    result_progress = result_progress_raw as u8;\n\n    result_is_hidden = (result_is_hidden & !action_result_effect_leave_shadows) | action_result_effect_hide;\n    result_is_visible = !result_is_hidden & is_visible(enemy_advance, result_coords.0);\n  }\n}\n\npub comptime fn set_action_def_result_effects_in_action_def(effects: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_result_effect_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_result_effects_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $effects.register[$i]; });\n    // result = quote { $result $action_def += $effects.register[$i] as Field * $multiplier; };\n    // multiplier *= 2;\n  }\n  result\n}\n\ncomptime fn derive_frontend_action_def_result_effects_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[derive_frontend_action_def_result_effects_struct]\n#[derive(Default)]\npub struct FrontendActionDefResultEffects {}\n\n\npub comptime fn derive_frontend_action_def_result_effects_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_result_effect_base_index(), ACTION_DEF_DEF_RESULT_EFFECTS);\n  quote { FrontendActionDefResultEffects { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionResultEffect.nr"},"94":{"source":"// pub global ACTION_RESULT_EVENT_TYPE: u8 = 0;\n// pub global ACTION_RESULT_EVENT_SUBTYPE: u8 = 1;\n// pub global ACTION_RESULT_EVENT_VALUE_MULTIPLIER: u8 = 2;\n// pub global ACTION_RESULT_EVENT_VALUE_FIXED_ADDITION: u8 = 3;\n// pub global ACTION_RESULT_EVENT_COORD_IDX: u8 = 4;\n// pub global ACTION_RESULT_EVENT_RADIUS: u8 = 5;\n// pub comptime fn to_action_result_event(event_type: Quoted, subtype: Quoted, val_mul: Quoted, val_add: Quoted, coord_idx: Quoted, radius: Quoted) -> Quoted {\n//     quote { ($event_type, $subtype, $val_mul, $val_add, $coord_idx, $radius)}\n// }\n// pub comptime fn get_type_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_subtype_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_value_multiplier_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_value_addition_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n// pub comptime fn get_coord_idx_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.4 }\n// }\n// pub comptime fn get_radius_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.5 }\n// }\n// pub type ActionResultEventDefinition = (u8, u8, u8, u8, u8, u8);\n\nuse skplg::{softassert};\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse crate::actionResultEffect::{get_action_def_result_effect_base_index, get_action_def_result_effects_byte_size};\n\npub type ActionDefDefResultEventRow = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefResultEventRow> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_RESULT_EVENTS: [DEF_ROW<ActionDefDefResultEventRow>] = [\n    action_def_def(quote { result_event_value_fixed_addition }, 8, |fixed_addition|quote { result_event_value += $fixed_addition as u32; }),\n    action_def_def(quote { result_event_value_scaled_by_progress }, 4, |factor|quote { result_event_value += ($factor as u32) * (actor_progress as u32); }),\n    action_def_def(quote { result_event_coords_idx }, 2, |coords_idx|{\n     let check = softassert(quote { is_valid }, quote { $coords_idx < 3 }, quote { f\"Invalid event coord idx: {result_event_coords_idx} does not fit in u8!\" });\n      quote {\n        let result_event_coords_idx: u8 = $coords_idx;\n        $check\n        result_event_coords = coords[result_event_coords_idx & 3];\n      }\n    }),\n    action_def_def(quote { result_event_type }, 4, |event_type|quote { result_event_type = $event_type; }),\n    action_def_def(quote { result_event_subtype }, 8, |event_subtype|quote { result_event_subtype = $event_subtype; }),\n    action_def_def(quote { result_event_radius }, 6, |event_radius|quote { result_event_radius = $event_radius; })\n];\ncomptime fn get_action_def_result_event_base_index() -> u32 {\n  get_action_def_result_effect_base_index() + get_action_def_result_effects_byte_size()\n}\n\npub comptime fn get_action_def_result_event_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_RESULT_EVENTS)\n}\n\n\ncomptime fn derive_action_def_def_result_event_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_RESULT_EVENTS);\n// }\n#[derive_action_def_def_result_event_struct]\npub struct ActionResultEvent {\n  pub register: [u8; 32]\n}\nimpl ActionResultEvent {\n  #[derive_action_def_result_event_struct_new]\n  pub fn new() -> ActionResultEvent {\n    ActionResultEvent { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_result_event_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n#[export]\n#[derive_action_def_def_result_event_builder]\npub fn build_action_def_result_event() -> pub ActionResultEvent { ActionResultEvent::new() }\n\npub comptime fn build_result_event(event_idx: u32, events_collection_varname: Quoted, valid_varname: Quoted, register: Quoted) -> Quoted {\n  let base_index = get_action_def_result_event_base_index();\n  let event_data_start_idx = base_index + event_idx * get_action_def_result_event_byte_size();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_RESULT_EVENTS, event_data_start_idx, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n  //let value_valid_msg = f\"Invalid event value ({event_idx}): result_event_value does not fit in u8!\";\n  // let value_valid = softassert(valid_varname, quote { result_event_value <= 255 as u32 }, quote { f\"Invalid event value ({event_idx}): result_event_value does not fit in u8!\" });\n  let full_result = quote {\n    let event_idx = $event_idx as u8;\n    let mut result_event_type: u8 = 0;\n    let mut result_event_subtype: u8 = 0;\n    let mut result_event_coords: (u8,u8) = (NOWHERE, NOWHERE);\n    let mut result_event_value: u32 = 0;\n    let mut result_event_radius: u8 = 0;\n    $result\n    // $value_valid\n    if (result_event_value > 255) {\n      result_event_value = 255;\n    }\n\n    $events_collection_varname.push(build_subtype_value_event(\n      result_event_type,\n      actor_id,\n      result_event_coords.0,\n      result_event_coords.1,\n      result_event_value as u8,\n      result_event_subtype,\n      result_event_radius\n    ));\n  };\n  // println(full_result);\n  full_result\n}\n\npub comptime fn set_action_def_result_event_in_action_def(event: Quoted, event_count: u32, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let mut base_index = get_action_def_result_event_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  // println(\"start\");\n  for event_idx in 0..event_count {\n    let idx = event_idx * get_action_def_result_event_byte_size();\n    for i in 0..get_action_def_result_event_byte_size() {\n      let destination_idx = base_index + idx + i;\n      result = quote { $result $action_def[$destination_idx] = $event[$event_idx].register[$i]; };\n      // result = quote { $result $action_def += $event[$event_idx].register[$i] as Field * $multiplier; };\n      // multiplier *= 2;\n    }\n  }\n  //println(result);\n  result\n}\n\ncomptime fn derive_frontend_action_def_result_event_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n#[derive_frontend_action_def_result_event_struct]\n#[derive(Default)]\npub struct FrontendActionDefResultEvent {}\n\n\npub comptime fn derive_frontend_action_def_result_event_struct_builder(param_name: Quoted, event_idx: u32) -> Quoted {\n  let idx = get_action_def_result_event_base_index() + event_idx * get_action_def_result_event_byte_size();\n  let content = derive_frontend_action_def_struct_builder(param_name, idx, ACTION_DEF_DEF_RESULT_EVENTS);\n  quote { FrontendActionDefResultEvent { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionResultEvent.nr"}},"names":["calculate_action"],"brillig_names":["directive_integer_quotient","directive_invert"]}