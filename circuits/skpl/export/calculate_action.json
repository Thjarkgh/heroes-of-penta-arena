{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13783278776978043031,"abi":{"parameters":[{"name":"action","type":{"kind":"struct","path":"arenalib::skpla::action::Action","fields":[{"name":"action_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}}]},"visibility":"private"},{"name":"my_chars","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"character::Character","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"class","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"progress","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"has_been_seen","type":{"kind":"boolean"}},{"name":"is_hidden","type":{"kind":"integer","sign":"unsigned","width":1}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"damage_mod","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"last_action","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actions","type":{"kind":"array","length":7,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}}]}},"visibility":"private"},{"name":"my_obstacles_parsed","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"},{"name":"enemy_objects_parsed","type":{"kind":"array","length":29,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"},{"name":"enemy_advance_input","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"energy","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"array","length":5,"type":{"kind":"struct","path":"character::Character","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"class","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"progress","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"has_been_seen","type":{"kind":"boolean"}},{"name":"is_hidden","type":{"kind":"integer","sign":"unsigned","width":1}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"damage_mod","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"last_action","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actions","type":{"kind":"array","length":7,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}}]}},{"kind":"array","length":24,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}},{"kind":"integer","sign":"unsigned","width":8},{"kind":"struct","path":"event::Event","fields":[{"name":"event","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actor_id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"subtype","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"value","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"radius","type":{"kind":"integer","sign":"unsigned","width":8}}]}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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WJjvaB4DyltAeQooLwHlIaC8A5RngPIKUB4ByhtAeQIoLwDlAaB7/3TPn+710z1+urdP9/TpXj7dw6d793TPnu7V0z16ujdP9+TpXjzdg6d773TPfWe+o/fY6d463VOne+l0D53undM9c7pXTvfI6d443ROne+F0D5zufdM9b7rXTfe46d423dOme9l0D5vuXdM9a7pXTfeo6d403ZOme9F0D5ruPdM9Z7rXTPeY6d4y3VOme8l0D5nuHf99zzj/0XvEdG+Y7gnTvWC6B0z3fumeL93rpXu8dG+X7unSvVy6h0v3bumeLd2rpXu0dG+W7snSvVi6B0v3XumeK91rpXusdG+V7qnSvVS6h0r3TumeKd0rpXukdG+U7onSvVC6B0r3PumeJ93rpHucdG+T7mnSvUy6h0n3LumeJd2rpHuUdG+S7knSvUi6B0n3HumeI91rpHuMdG+R7inSvUS6h0j3DumeId0rpHuEdG+Q7gnSvUC6B0j3/uieH93ro3t8dG+P7unRvTy6h0f37uieHd2ro3t0dG+O7snRvTi6B0f33uieG91ro3tsdG+N7qnRvTS6h0b3zuieGd0ro3tkdG+M7onRvTC6B0b3vuieF93rontcdG+L7mnRvSy6h0X3ruieFd2rontUdG+K7knRvSi6B0X3nuieE91rontMdG+J7inRvSS6h0T3juieEd0rontEdG+I7gnRvSC6B0T3fuieD93roXs8dG+H7unQvRy6h0P3buieDd2roXs0dG+G7snQvRi6B0P3XuieC91roXssdG+F7qnQvRS6h0L3TuieCd0roXskdG+E7onQvRC6B0L3PuieB93roHscdG+D7mnQvQy6h0H3LuieBd2roHsUdG+C7knQvQi6B0H3HuieA91roHsMdG+B7inQvQS6h0D3DuieAd0roHsEdG+A7gnQvQC6B0Dn/umcP53rp3P8dG6fzunTuXw6h0/n7umcPZ2rp3P0dG6ezsnTuXg6B0/n3umcO51rp3PsdG6dzqnTuXQ6h07nzumcOZ0rp3PkdG6czonTuXA6B07nvumcN53rpnPcdG6bzmnTuWw6h03nrumcNZ2rpnPUdG6azknTuWg6B03nnumcMy0A6BwznVumc8p0LpnOIdO547/PGRc4eo6Yzg3TOWE6F0zngOncL53zpXO9dI6Xzu3SOV06l0vncOnc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1DEVaHivJOOIDHOdNh+3TgsteDDNF+D0oACnh7Ammw9ck00DCnB6MpZItKejqOILAheFkNHKF4RncYjRfYpAHyJnDVPAfRh70H05FTxTkqrntJBOzXmJPebtArg2z4C1+djLVjOS5S5b0W7Os8n404jIXaKZEV8dPO3v7KD7ELk79iqwD8NcaSxATfRCvGz1mj/Rez040XuNCci/HsL9jgXAyd9rQFG+nowlF23Y5HheFVj2v5F3l/1HnxAvW83yjXF20BhnMcY4OwRjnAc0xllAY5ydjCUXbYzkeN4QMMY3lZ6fQMw2w75sNcc3xreCxjiHMca3/oe4nJfYc0wnJhqXmwM0xrfA5KLFR47nTQFjfDukZWOi9URy/U7Elzd0KepJAa7nRnwTjrT4jkC75ykdcGYWwp3pYqorMvub7w84C4IDznxmwFkQQhw+vhMTnf3NBzqhBclYciXEN19gRxzHRw8oH+/C+KjixWv8XcFYogKOqiA5eg8X782N5+g9n6Mwl/YwHRgvtIOvC33nvijo3Bcyzn1RCEt7xLtizn0hUKiLcEv7GtRnJMyd/vvqFE9KusiWi22pb0sDWxra0tiWprZcZksLWy635QpbrrTlKlva2tLelmts6WTLtbZ0taW7Lbm29LLleltusOVGW2625RZbbrXlNltut+VOW+6y5W5b7rHlXlvut+UBWx605WFbHrHlUVses+VxW5605SlbnrHlWVues+UFW8bb8qItL9nysi1TbHnFlum2zLTlNVvesGW2LXNseduWubbMt+VdWxbastiWJbZ8YMsyWz62ZbktK21ZZctqW9bast6WjbZstmWrLdtt2WnL57bstuUrW7625RtbvrXle1t+sOVHW36y5WdbfrXlN1v+sOUvW5JKWEdhS0FbTrCliC3FbClhS0lbStuSaku6LZm2ZNtyoi0n23KKLeVsqWDL6bacacvZtlS05VxbzrPFs6WKLdVsqWFLji0X2FLHlotsudiW+rY0sKWhLY1taWrLZba0sOVyW66w5UpbrrKlrS3tbbnGlk62XGtLV1u625JrSy9brrflBltutOVmW26x5VZbbrPldlvutOUuW+625R5b7rXlflsesOVBWx625RFbHrXlMVset+VJW56y5RlbnrXlOVtesGW8LS/a8pItL9syxZZXbJluy0xbXrPlDVtm2zLHlrdt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","debug_symbols":"7b3ZjizLcab7LrzWRfrsrlc5OGhQEtUgQJCChgYaQr97x15VObAjtlmUp6WF23C3JVal5/+tjEg3Kw/7/vsP//Knf/qv//k//vzXf/3bf/zhH/+///7DX/72z3/8zz//7a/b//Xffwi5tF//3//4tz/+9bf/x3/85x///T//8I+hhlv/hz/86a//8uu/Y/0///CHf/3zX/70h39s5f/8///w2+/1yd8bc79Xb5O/FyZ/L07+Xpr8vTz5e2Xy9+rk701+Xurk56VOfl7a5OelTX5e2uTnpU1+Xtrk56VNfl7a5OelTX5e2uTnpU1+Xvrk56VPfl765OelT35e+uTnpU9+Xvrk56VPfl765OelT35exuTnZUx+Xsbk52VMfl7G5OdlTH5exuTnZUx+Xsbk52XMfV7K7Tb5e2Hy9+Lk76XJ38uTv1cmf69O/l6b/L0++XuTn5cw+XkJk5+XMPl5CZOflzD5eQmTn5cw+XkJk5+XMPl5CZOflzj5eYmTn5c4+XmJk5+XOPl5iZOflzj5eYmTn5c4+XmJk5+XNPl5SZOflzT5eUmTn5c0+XlJk5+XNPl5SZOflzT5eUmTn5c8+XnJk5+XPPl5yZOflzz5ecmTn5c8+XnJk5+XPPl5yZOflzL5eSmTn5cy+Xkpk5+XMvl5KZOflzL5eZns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns75bJ/m6Z7O+Wyf5umezvlsn+bpns79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezv1sn+bp3s79bJ/m6d7O/Wyf5unezvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O+2yf5um+zvtsn+bpvs77bJ/m6b7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s7/bJ/m6f7O/2yf5un+zv9sn+bp/s747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7umOzvjsn+7pjs747J/u6Y7O+Oyf7u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48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5ThzVznO3FWOM3eV48xd5Thz1zjO3DWOM3eN48xd4zhz126ZY5HCsUjlWKRxLNI5FuG44jnO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3eN48xd4zhz1zjO3DWOM3ed48xd5zhz1znO3HWOM3f9ljkWKRyLVI5FGscinWMRjiue48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO3HWOM3ed48xd5zhz1znO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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"56":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"61":{"source":"// use crate::{ HEIGHT, WIDTH };\nuse arenalib::{ NO_EVENT, WAIT, SEE_MOVE, WIDTH, HEIGHT };\nuse arenalib::{ MAX_ACTIONS, MAX_OBSTACLES };\nuse arenalib::{ SERIALIZED_ACTION_BYTE_SIZE, SERIALIZED_ACTIONS_ARRAY_SIZE, SERIALIZED_ACTIONS_PER_FIELD, VIEW_DISTANCE };\nuse skplg::{softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD};\nuse arenalib::{Action, get_action_actor, get_action_target_x, get_action_target_y, get_action_type, new_action};\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\nuse crate::character::Character;\nuse crate::event::Event;\nuse crate::event::{ build_subtype_value_event }; // , build_value_event\nuse crate::map::{ is_visible, get_distance, can_move_to };\nuse crate::obstacle::Obstacle;\nuse crate::obstacle::{ get_default_obstacles };\nuse arenalib::{MAGE};\nuse arenalib::{MAX_ACTIONS_PER_CHARACTER, MAX_ENEMY_OBSTACLES, MAX_CHARACTERS};\n// use crate::ResolvedAction::ResolvedAction;\n// use crate::actionDefinition::{ build_move_action };\nuse arenalib::{apply_action_result_effects, apply_action_pre_calc_effects, validate_action_requirements, build_result_event};\nuse arenalib::arena_action_def_builder;\nuse super::{map::get_distance_from_parts, map::get_distance_part, map::is_distance_within_viewing_range, obstacle::new_obstacle, map::get_free_map};\nuse arenalib::MAX_HEALTH;\n\n// use crate::{ACTION_RESULT_COORDINATES_IDX_SELF, ACTION_RESULT_COORDINATES_IDX_TARGET, ACTION_RESULT_COORDINATES_IDX_INVISIBLE};\n// use crate::{SEE_CAST, SEE_DRAW, SEE_RITUAL, SEE_SEARCH_TRAP, RECEIVE_ATTACK, DISARMED_TRAP, ADD_OBSTACLE, WIN};\n// use crate::action_builder;\n\n\n\n// global ACTION_TYPE: u8 = 0;\n// global ACTION_ACTOR: u8 = 1;\n// global ACTION_TARGET_X: u8 = 2;\n// global ACTION_TARGET_Y: u8 = 3;\n\nglobal SEEN_EVENT_IDX: u32 = 1;\nglobal UNSEEN_EVENT_IDX: u32 = 0;\nglobal WORLD_EVENT_IDX: u32 = 2;\nglobal SELF_EVENT_IDX: u32 = 3;\n\npub fn execute_action(\n    action: Action,\n    enemy_advance: u8,\n    actor: Character,\n    mut energy: u8,\n    my_char_obstacles: [Obstacle; MAX_CHARACTERS],\n    my_obstacles: [Obstacle; MAX_OBSTACLES],\n    their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]\n) -> (bool, Event, Event, Event, Character, u8) /*where T: ResolvedAction */{\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    //let action_def = c.resolve_action(action.register[action.base_index + ACTION_TYPE]);\n        //let mut result_event: Event = build_std_event(NO_EVENT, c.id, 0, 0);\n        //let mut result_char = c;\n        //let mut required_energy = 0;\n        let mut is_valid = true;\n        //let action_def = c.resolve_action(get_action_type(action));\n        // let mut result_valid = true;\n\n        // let need_sneak = get_action_type(action) == SNEAK;\n        //let can_sneak = c.can_sneak();\n        // let need_move = get_action_type(action) == MOVE | get_action_type(action) == SNEAK;\n        // let can_move = can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles);\n        // let need_target_is_neighbor = get_action_type(action) == SNEAK | get_action_type(action) == MOVE | get_action_type(action) == ATTACK | get_action_type(action) == SEARCH | get_action_type(action) == DISARM_TRAP;\n        //let target_is_neighbor = is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        // let need_target_is_not_self = get_action_type(action) == ATTACK | get_action_type(action) == SHOOT;\n        // let target_is_not_self = (c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action));\n        // let need_ritual = get_action_type(action) == RITUAL;\n        //let can_ritual = c.can_ritual();\n        // let need_search = get_action_type(action) == SEARCH;\n        //let can_search = c.can_search();\n        //let can_attack = is_neighbor & not_self;\n        // let need_can_cast_fireball = get_action_type(action) == CAST_FIREBALL;\n        // let min_rounds_to_finish = if get_action_type(action) == CAST_FIREBALL {\n        //     FIREBALL_ROUNDS_FOR_CAST\n        // } else if get_action_type(action) == RITUAL {\n        //     RITUAL_ROUNDS_FOR_WIN\n        // } else if get_action_type(action) == SHOOT {\n        //     MIN_DRAW_ROUNDS_FOR_SHOOT\n        // } else {\n        //     0\n        // };\n        // let max_rounds_to_finish = if get_action_type(action) == CAST_FIREBALL {\n        //     FIREBALL_ROUNDS_FOR_CAST\n        // } else if get_action_type(action) == RITUAL {\n        //     RITUAL_ROUNDS_FOR_WIN\n        // } else if (get_action_type(action) == DRAW) | (get_action_type(action) == SHOOT) {\n        //     MAX_DRAW_ROUNDS_FOR_SHOOT\n        // } else {\n        //     0\n        // };\n        // let need_check_status = get_action_type(action) == CAST_FIREBALL | get_action_type(action) == RITUAL | get_action_type(action) == DRAW | get_action_type(action) == SHOOT;\n        // let can_cast_fireball = c.can_cast_fireball(); // & (result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        // let can_draw = c.can_shoot(); // & (c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        // let can_shoot = c.can_shoot(); // & (c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT);\n        // let can_disarm = c.can_disarm();\n        // let is_valid =\n        //     (get_action_type(action) == WAIT) |\n        //     ((get_action_type(action) == SNEAK) & can_sneak & can_move & target_is_neighbor) |\n        //     ((get_action_type(action) == MOVE) & can_move & target_is_neighbor) |\n        //     ((get_action_type(action) == RITUAL) & can_ritual) |\n        //     ((get_action_type(action) == SEARCH) & can_search & target_is_neighbor) |\n        //     ((get_action_type(action) == ATTACK) & target_is_neighbor & target_is_not_self) |\n        //     ((get_action_type(action) == CAST_FIREBALL) & can_cast_fireball & result_char.status <= max_rounds_to_finish) |\n        //     ((get_action_type(action) == DRAW) & can_draw) |\n        //     ((get_action_type(action) == SHOOT) & can_shoot & target_is_not_self) |\n        //     ((get_action_type(action) == DISARM_TRAP) & can_disarm & target_is_neighbor);\n\n\n\n\n        // need to adapt status first in case of action interruption!\n\n    //let action_type = action.get_action_type(action);\n    //let action_def = c.resolve_action(action_type);\n    let action_type = get_action_type(action);\n\n    let actor_id = actor.get_id();\n    let actor_x = actor.get_x();\n    let actor_y = actor.get_y();\n    let actor_target_x = actor.get_target_x();\n    let actor_target_y = actor.get_target_y();\n    let actor_last_action = actor.get_last_action();\n    let (action_def_valid, action_def) = actor.get_action(action_type);\n    softassert!(quote { is_valid }, quote { action_def_valid }, quote { f\"Failed to fetch action def of {action_type}\" });\n\n    let action_target_x = get_action_target_x(action);\n    let action_target_y = get_action_target_y(action);\n    let distance = get_distance(actor_x, actor_y, action_target_x, action_target_y);\n\n    // let is_continuous = action.get_action_is_continuous();\n    // let is_not_interrupted = (\n    //     ((!is_continuous) & (action.get_action_result_status_multiplier() != 0)) | // that's the ID of the wait action => leave status, but not continuous\n    //     ((is_continuous) & (action.get_action_req_previous_action() == c.last_action) & (action_target_x == c.get_target_x()) & (action_target_y == c.get_target_y()))\n    // );\n\n\n    let mut actor_progress = actor.get_progress();\n    let mut actor_is_hidden = actor.get_is_hidden() == 1;\n    let actor_is_in_view_range = is_visible(enemy_advance, actor_x);\n    // let max_range_part = get_action_req_max_range(action) as u16;\n    // let mut actor_max_range = max_range_part * max_range_part;\n    let mut is_not_interrupted = true;\n    let mut actor_damage_mod = actor.get_damage_mod();\n    let mut actor_status = actor.get_status();\n    // ~200 gates\n    apply_action_pre_calc_effects!(quote { action_def });\n\n    let mut obst = my_obstacles.as_slice();\n    for i in 0..MAX_CHARACTERS {\n      obst = obst.push_back(my_char_obstacles[i]);\n    }\n        let could_move_to_target = can_move_to(distance, action_target_x, action_target_y, obst.as_array(), their_obstacles);\n\n\n///////////////////////////\n    // ~4000 gates\n    validate_action_requirements!(quote { is_valid }, quote { action_def });\n    // // pub global ACTION_NEEDS_TARGET_FREE_SPACE: u8 = 0;  // u1\n    // let target_is_free_space_valid = !action.get_action_req_target_free_space() | can_move_to(distance, action_target_x, action_target_y, my_obstacles, their_obstacles);\n    // softassert!(quote { is_valid }, quote { target_is_free_space_valid }, quote { f\"Target space ({action_target_x},{action_target_y}) cannot be moved to: {VIEW_DISTANCE},{my_obstacles},{their_obstacles}\" });\n    \n    // // pub global ACTION_NEEDS_TARGET_IS_NOT_SELF: u8 = 1; // u1\n    // let target_is_not_self_valid = !action.get_action_req_target_is_not_self() | (c_x != action_target_x) | (c_y != action_target_y);\n    // softassert!(quote { is_valid }, quote { target_is_not_self_valid }, quote { f\"Target cannot be self ({action_target_x},{action_target_y})\" });\n\n    // // pub global ACTION_NEEDS_STATUS_HIDDEN: u8 = 4; // u1\n    // let char_is_hidden = c.is_hidden == 1;\n    // let char_is_hidden_valid = !action.get_action_req_status_hidden() | char_is_hidden;\n    // softassert!(quote { is_valid }, quote { char_is_hidden_valid }, quote { f\"Character needs to be hidden to perform action {action_type}\" });\n    \n    // // pub global ACTION_NEEDS_STATUS_VISIBLE: u8 = 2; // u1\n    // let char_is_in_view_range = is_visible(enemy_advance, c_x);\n    // let char_is_fully_visible = char_is_in_view_range & !char_is_hidden;\n    // let char_is_fully_visible_valid = !action.get_action_req_status_visible() | char_is_fully_visible;\n    // softassert!(quote { is_valid }, quote { char_is_fully_visible_valid }, quote { f\"Character must be fully visible for action {action_type}: in_view_range: {char_is_in_view_range} & !hidden {char_is_hidden} for enemy_advance {enemy_advance} @ {c_x}\" });\n\n    // // pub global ACTION_NEEDS_STATUS_INVISIBLE: u8 = 3; // u1\n    // let char_invisible_valid = !action.get_action_req_status_invisible() | !char_is_in_view_range | char_is_hidden;\n    // softassert!(quote { is_valid }, quote { char_invisible_valid }, quote { f\"Character must not be visible to perform action {action_type}: !in_view_range: {char_is_in_view_range} || hidden: {char_is_hidden} for enemy_advance {enemy_advance} @ {c_x}\" });\n\n    // // pub global ACTION_MAX_RANGE: u8 = 7; // u6 // TODO: max_range!\n    // let max_range_part = action.get_action_req_max_range() as u16;\n    // let max_range = max_range_part * max_range_part;\n    // let max_range_valid  = distance <= max_range;\n    // softassert!(quote { is_valid }, quote { max_range_valid }, quote { f\"Character is out of range! Distance: {distance} > {max_range}: {{{c_x},{c_y}}} - {{{action_target_x},{action_target_y}}} with {max_range_part}\" });\n\n    // // pub global ACTION_NEEDS_MIN_STATUS: u8 = 8; // u4\n    // let min_status = action.get_action_req_min_status();\n    // let min_status_valid = min_status <= status;\n    // softassert!(quote { is_valid }, quote { min_status_valid }, quote { f\"Character needs min status {min_status} to perform action {action_type}, but only has {status}\" });\n\n    // // pub global ACTION_NEEDS_MAX_STATUS: u8 = 9; // u4\n    // let max_status = action.get_action_req_max_status();\n    // let max_status_valid = max_status >= status;\n    // softassert!(quote { is_valid }, quote { max_status_valid }, quote { f\"Character cannot have a higher status than {max_status} to perform action {action_type}: got {status}\" });\n\n    // // pub global ACTION_NEEDED_ENERGY: u8 = 10;    // u4\n    // let required_energy = action.get_action_req_energy();\n    // let energy_valid = required_energy <= energy;\n    // softassert!(quote { is_valid }, quote { energy_valid }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {required_energy}\" });\n    //////////////////////\n    \n\n        let coords = [\n            (actor_x, actor_y),\n            (action_target_x, action_target_y),\n            (NOWHERE, NOWHERE),\n        ];\n\n    // pub global ACTION_RESULT_STATUS_MULTIPLIER: u8 =     ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT;     // u1\n    // pub global ACTION_RESULT_STATUS_FIXED_ADDITION: u8 = ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 1; // u4\n    // pub global ACTION_MOVE_TO_TARGET: u8 =               ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 2; // u1\n    // pub global ACTION_SETS_STATUS_HIDDEN: u8 = 5; // u1\n    // pub global ACTION_REMOVES_STATUS_HIDDEN: u8 = 6; // u1\n\n        // CALCULATE EVENTS\n        comptime {\n          assert(SEEN_EVENT_IDX == 1);\n          assert(UNSEEN_EVENT_IDX == 0);\n        }\n        //let result_event_idx = is_visible as u32;\n        let mut events: BoundedVec<Event, 4> = BoundedVec::new();\n        // 19000 gates\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        // events.push(build_subtype_value_event(0, 0, 0, 0, 0, 0, 0));\n        build_result_event!(0 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(1 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(2 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        build_result_event!(3 as u32, quote { events }, quote { is_valid }, quote { action_def });\n        assert(events.len() == 4);\n\n        // let seen_event_value = status as u32 * action.get_action_result_event_seen_value_status_multiplier() as u32 + action.get_action_result_event_seen_value_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { seen_event_value <= 255 as u32 }, quote { f\"Invalid event value (seen): {seen_event_value} does not fit in u8!\" });\n\n        // let unseen_event_value = status as u32 * action.get_action_result_event_not_seen_value_status_multiplier() as u32 + action.get_action_result_event_not_seen_value_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { unseen_event_value <= 255 as u32 }, quote { f\"Invalid event value (unseen): {unseen_event_value} does not fit in u8!\" });\n\n        // let seen_event_coords_idx = action.get_action_result_event_seen_coord_idx();\n        // softassert!(quote { is_valid }, quote { seen_event_coords_idx < 4 }, quote { f\"Invalid seen event coord idx: {seen_event_coords_idx} > 3\" });\n\n        // let seen_event_coords = coords[seen_event_coords_idx & 3];\n\n        // let unseen_event_coords_idx = action.get_action_result_event_not_seen_coord_idx();\n        // softassert!(quote { is_valid }, quote { unseen_event_coords_idx < 4 }, quote { f\"Invalid unseen event coord idx: {unseen_event_coords_idx} > 3\" });\n\n        // let unseen_event_coords = coords[unseen_event_coords_idx & 3];\n\n        // //let events = [\n        // let dummy_event =    build_subtype_value_event(NO_EVENT, c.get_id(), coords[ACTION_RESULT_COORDINATES_IDX_INVISIBLE].0, coords[ACTION_RESULT_COORDINATES_IDX_INVISIBLE].1, 0 as u8, 0 as u8, 0 as u8);\n        // let unseen_event =    build_subtype_value_event(\n        //         action.get_action_result_event_not_seen_type(),\n        //         c.get_id(), \n        //         unseen_event_coords.0,\n        //         unseen_event_coords.1,\n        //         unseen_event_value as u8,\n        //         action.get_action_result_event_not_seen_subtype(),\n        //         action.get_action_result_event_not_seen_radius()\n        //     );\n        // let seen_event =    build_subtype_value_event(\n        //         action.get_action_result_event_seen_type(),\n        //         c.get_id(), \n        //         seen_event_coords.0,\n        //         seen_event_coords.1,\n        //         seen_event_value as u8,\n        //         action.get_action_result_event_seen_subtype(),\n        //         action.get_action_result_event_seen_radius()\n        //     );\n        //];\n\n\n        // APPLY EFFECTS ON SELF\n        let mut result_energy = energy;\n        let mut result_coords = coords[0];\n        let mut result_progress = actor_progress;\n        let mut result_is_hidden = actor_is_hidden;\n        let mut result_is_visible = actor_is_in_view_range;\n        let mut result_damage_mod = actor_damage_mod;\n        let mut result_health = actor.get_health();\n        let mut result_status = actor_status;\n\n\n        // let energy = std::wrapping_sub(energy, action.get_action_req_energy());\n        // let status = actor_progress as u32 * action.get_action_result_status_multiplier() as u32 + action.get_action_result_status_fixed_addition() as u32;\n        // softassert!(quote { is_valid }, quote { status <= MAX_STATUS as u32 }, quote { f\"Invalid result status: {status} > {MAX_STATUS}\" });\n\n        // let final_coords = coords[action.get_action_move_to_target() as u8];\n        // // debug!(quote { println(f\"final_coords:{final_coords}\"); });\n        // let is_hidden = ((c.is_hidden == 1) & !action.get_action_result_effect_removes_status_hidden()) | action.get_action_result_effect_sets_status_hidden();\n        // let is_visible = !is_hidden & is_visible(enemy_advance, final_coords.0);\n        // 200 gates\n        apply_action_result_effects!(quote { action_def });\n\n// let result_coord_src = action_def[6] as u8;\n// let result_coord_src_fixed = result_coord_src & 4 as u8;\n// let result_coord = result_coord_src_fixed != 0 as u8;\n// let result_coord_cast = result_coord as u8;\n// println(f\"result coords: {result_coord_src} {result_coord_src_fixed} {result_coord} {result_coord_cast}\");\n// result_coords = coords[((action_def[6]as u8 / 4 as u8) == 1 as u8)as u8];\n        // let target_coords = [\n        //     (target_x, target_y),\n        //     (c.get_target_x(), c.get_target_y())\n        // ];\n\n        // actor.x = result_coords.0;\n        // actor.y = result_coords.1;\n        // actor.progress = result_progress;\n        // actor.is_hidden = result_is_hidden as u1;\n        // actor.has_been_seen = result_is_visible;\n        // actor.last_action = is_not_interrupted as u8 * actor.get_last_action() + (!is_not_interrupted) as u8 * action_type;\n        // actor.target_x = is_not_interrupted as u8 * actor.get_target_x() + (!is_not_interrupted) as u8 * action_target_x;\n        // actor.target_y = is_not_interrupted as u8 * actor.get_target_y() + (!is_not_interrupted) as u8 * action_target_y;\n        // actor.damage_mod = result_damage_mod;\n        // actor.health = result_health;\n        // actor.status = result_status;\n\n        (\n            is_valid,\n            if result_is_visible { events.get_unchecked(SEEN_EVENT_IDX) } else { events.get_unchecked(UNSEEN_EVENT_IDX) },//events[1 + (is_visible as u8)],\n            events.get_unchecked(WORLD_EVENT_IDX),\n            events.get_unchecked(SELF_EVENT_IDX),//events[get_action_unseen_event_is_internal(action_def) as u8],\n            Character {\n                id: actor_id,\n                x: result_coords.0,\n                y: result_coords.1,\n                progress: result_progress, // status as u8,\n                is_hidden: result_is_hidden as u1, //is_hidden as u1,\n                has_been_seen: result_is_visible, //is_visible,\n                last_action: is_not_interrupted as u8 * actor.get_last_action() + (!is_not_interrupted) as u8 * action_type,\n                target_x: is_not_interrupted as u8 * actor.get_target_x() + (!is_not_interrupted) as u8 * action_target_x, // if is_not_interrupted { c.get_target_x() } else { get_action_target_x(action) };\n                target_y: is_not_interrupted as u8 * actor.get_target_y() + (!is_not_interrupted) as u8 * action_target_y,\n                class: actor.class,\n                damage_mod: result_damage_mod,\n                health: result_health,\n                status: result_status,\n                actions: actor.actions,\n            },\n            result_energy\n        )\n\n        // if get_action_type(action) == SNEAK {\n        //     //assert(c.can_sneak());\n        //     if !can_sneak { let actor_id = c.id; println(f\"Failed to execute action: Character {actor_id} cannot sneak\"); }\n        //     //assert(can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles));\n        //     //assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_sneak() & can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles) & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.x = get_action_target_x(action);  \n        //     result_char.y = get_action_target_y(action);\n        //     result_char.status = 0;\n        //     required_energy = c.get_energy_per_sneak();\n        // }\n        // if get_action_type(action) == MOVE {\n        //     // assert(can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles));\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = can_move_to(get_action_target_x(action), get_action_target_y(action), my_obstacles_parsed, their_obstacles) & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.x = get_action_target_x(action);\n        //     result_char.y = get_action_target_y(action);\n        //     result_char.status = 0;\n        //     required_energy = c.get_energy_per_move();\n        //     result_char.has_been_seen = is_visible(enemy_advance, result_char.x);\n        //     if c.get_has_been_seen() {\n        //         result_event = build_std_event(SEE_MOVE, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     }\n        // }\n        // if get_action_type(action) == RITUAL {\n        //     //assert(c.can_ritual());\n        //     // result_valid = c.can_ritual();\n        //     result_char.status += 1;\n        //     if result_char.status >= RITUAL_ROUNDS_FOR_WIN {\n        //         result_event = build_std_event(WIN, c.id, 0, 0);\n        //     } else {\n        //         result_event = build_std_event(SEE_RITUAL, c.id, 0, 0);\n        //     }\n        //     required_energy = c.get_energy_per_ritual();\n        // }\n        // if get_action_type(action) == SEARCH {\n        //     // assert(c.can_search());\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_search() & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.status = 0;\n        //     result_event = build_std_event(SEE_SEARCH_TRAP, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     required_energy = c.get_energy_per_search();\n        // }\n        // if get_action_type(action) == ATTACK {\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // assert((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     // result_valid = is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)) & ((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     result_char.status = 0;\n        //     result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_MELEE), ATTACK_MELEE);\n        //     required_energy = c.get_energy_per_attack();\n        // }\n        // // TODO: global SET_TRAP = 6 as u8;\n        // if get_action_type(action) == CAST_FIREBALL {\n        //     // assert(c.can_cast_fireball());\n        //     result_char.status += 1;\n        //     // assert(result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        //     // result_valid = c.can_cast_fireball() & (result_char.status <= FIREBALL_ROUNDS_FOR_CAST);\n        //     if result_char.status >= FIREBALL_ROUNDS_FOR_CAST {\n        //         // TODO: handle friendly fire and destruction of own walls and own traps\n        //         result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_FIREBALL), ATTACK_FIREBALL);\n        //     } else {\n        //         if c.get_has_been_seen() {\n        //             result_event = build_subtype_value_event(SEE_CAST, c.id, get_action_target_x(action), get_action_target_y(action), 0, ATTACK_FIREBALL);\n        //         }\n        //     }\n        //     required_energy = c.get_energy_per_cast();\n        // }\n        // if get_action_type(action) == DRAW {\n        //     // assert(c.can_shoot());\n        //     // assert(c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        //     // result_valid = c.can_shoot() & (c.status < MAX_DRAW_ROUNDS_FOR_SHOOT);\n        //     result_char.status += 1;\n        //     if c.get_has_been_seen() {\n        //         result_event = build_std_event(SEE_DRAW, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     }\n        //     required_energy = c.get_energy_per_draw();\n        // }\n        // if get_action_type(action) == SHOOT {\n        //     // assert(c.can_shoot());\n        //     // assert(c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT);\n        //     // assert((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     // result_valid = c.can_shoot() & (c.status >= MIN_DRAW_ROUNDS_FOR_SHOOT) & ((c.x != get_action_target_x(action)) | (c.y != get_action_target_y(action)));\n        //     result_char.status = 0;\n        //     // TODO: check distance! abs(c.x - get_action_target_x(action)) + abs(c.y - get_action_target_y(action)) <= c.get_shoot_range()\n        //     result_event = build_subtype_value_event(RECEIVE_ATTACK, c.id, get_action_target_x(action), get_action_target_y(action), c.get_damage(ATTACK_RANGED), ATTACK_RANGED);\n        //     required_energy = c.get_energy_per_shoot();\n\n        // }\n        // // TODO: SET_TRAP\n        // if get_action_type(action) == DISARM_TRAP {\n        //     // assert(c.can_disarm());\n        //     // assert(is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action)));\n        //     // result_valid = c.can_disarm() & is_neighbor(c.x, c.y, get_action_target_x(action), get_action_target_y(action));\n        //     result_char.status = 0;\n        //     result_event = build_std_event(DESTROY, c.id, get_action_target_x(action), get_action_target_y(action));\n        //     required_energy = c.get_energy_per_disarm();\n        // }\n        \n        // // assert(energy >= required_energy);\n        // let result_valid = is_valid & (energy >= required_energy);\n        // if result_valid {\n        //     energy -= required_energy;\n        // }\n        // // energy -= required_energy;\n        // (result_valid, result_event, result_char, energy)\n    }\n//}\n\n//global test_actions: [TestActionDefinition; 1] = [\n    // build_test_action_def!(build_wait_action_def(), quote { 0, 1, 3, 4 }),\n    //TestActionDefinition { register: build_test_action_def!(build_wait_action_def()), action: new_action(0, 1, 3, 4) },\n    // build_move_action(class_energy_per_move[ARCHER]),\n    //     build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n    //     build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n    //     build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n    //     build_wait_action_def(),\n    //     ,\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[RITUALIST]),\n    //     build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n    //     build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n    //     build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[ROGUE]),\n    //     build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n    //     build_sneak_action(class_energy_per_sneak[ROGUE]),\n    //     build_search_action(class_energy_per_search[ROGUE], 1),\n    //     build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n    //     build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[KNIGHT]),\n    //     build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    //     build_wait_action_def(),\n    // ],\n    // [\n    //     build_move_action(class_energy_per_move[MAGE]),\n    //     build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n    //     build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n    //     build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, FIREBALL_ROUNDS_FOR_CAST, FIREBALL_ROUNDS_FOR_CAST),\n    //     build_wait_action_def(),\n    //     build_wait_action_def()\n    // ]\n// ]\n\n// pub fn create_test_action(action: Action) -> TestActionDefinition {\n//     TestActionDefinition {\n//         register: \n//     }\n// }\n\n// pub struct TestActionDefinition {\n//     pub register: [u8; ACTION_DEFINITION_SIZE],\n//     pub action: Action,\n// }\n\n// impl ResolvedAction for TestActionDefinition {\n//     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n//     }\n//     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n//     }\n//     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n//     }\n//     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n//     }\n//     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n//     }\n//     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_MAX_RANGE]\n//     }\n//     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_MIN_STATUS]\n//     }\n//     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_MAX_STATUS]\n//     }\n//     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDED_ENERGY]\n//     }\n//     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_EVENT_IS_TRAP] == 1\n//     }\n//     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n//     }\n//     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n//     }\n//     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n//     }\n//     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n//     }\n//     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n//     }\n//     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n//     }\n//     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n//     }\n//     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n//     }\n//     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n//     }\n//     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n//     }\n//     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n//     }\n//     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n//     }\n//     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n//         self.register[ACTION_MOVE_TO_TARGET] as u1\n//     }\n//     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n//         self.register[ACTION_IS_CONTINUOUS] == 1\n//     }\n//     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n//         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n//     }\n\n//     fn get_action_target_x(self) -> u8 {\n//         get_action_target_x(self.action)\n//     }\n//     fn get_action_target_y(self) -> u8 {\n//         get_action_target_y(self.action)\n//     }\n//     fn get_action_type(self) -> u8 {\n//         get_action_type(self.action)\n//     }\n// }\n\n#[test]\nfn test_execute_action() {\n  // global action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// let action_builder = get_arena_action_def_builder();\n    let action_def = arena_action_def_builder.build_move_action(4); //, quote { 1, 2, 3, 4 }; //new_action(1, 2, 3, 4);\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n    let action = new_action(1, 2, 3, 4);\n    let their_advance = 30;\n    let mut actions = [[0; 32]; MAX_ACTIONS_PER_CHARACTER + 1];\n    actions[1] = action_def;\n    let actor = Character {\n        id: 2,\n        x: 2,\n        y: 4,\n        target_x: 0,\n        target_y: 0,\n        health: MAX_HEALTH,\n        damage_mod: 1,\n        last_action: WAIT,\n        class: MAGE,\n        is_hidden: 0 as u1,\n        has_been_seen: true,\n        progress: 0,\n        status: 0,\n        actions: actions\n    };\n    let energy = 15;\n    let my_obstacles = get_default_obstacles(0);\n    let (no_obstacle_valid, no_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, MAX_HEALTH, 0);\n    let mut mco: [Obstacle] = &[];\n    for i in 0..MAX_CHARACTERS {\n      let (co_valid, co) = new_obstacle(i as u8, i as u8, HEIGHT - 1, MAX_HEALTH, i as u8 + 1);\n      assert(co_valid);\n      mco = mco.push_back(co);\n    }\n    assert(no_obstacle_valid);\n    let their_obstacles = get_default_obstacles(1).as_slice().push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle).push_back(no_obstacle);\n    let (valid, event, _, internal_event, c, result_energy) = execute_action(\n        action,\n        their_advance,\n        actor,\n        energy,\n        mco.as_array(),\n        my_obstacles,\n        their_obstacles.as_array()\n    );\n    assert(valid, \"valid\");\n    assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n    assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n    assert(event.x == get_action_target_x(action), f\"{event}.target_x is not action target x\");\n    assert(event.y == get_action_target_y(action), f\"{event}.target_y is not action target y\");\n    assert(c.x == event.x, f\"{c}.x is not event {event}.x\");\n    assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n    assert(result_energy == 11, f\"{result_energy} != 11\");\n}\n\n\n\npub fn parse_actions(fields: [Field; SERIALIZED_ACTIONS_ARRAY_SIZE]) -> [Action; MAX_ACTIONS] {\n    comptime {\n        assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_ACTIONS_PER_FIELD * SERIALIZED_ACTION_BYTE_SIZE <= 32);\n        assert(SERIALIZED_ACTIONS_ARRAY_SIZE * SERIALIZED_ACTIONS_PER_FIELD == MAX_ACTIONS);\n        assert(SERIALIZED_ACTION_BYTE_SIZE >= 4);\n    }\n\n    let mut actions: [Action] = &[];\n    for i in 0..SERIALIZED_ACTIONS_ARRAY_SIZE {\n        let split: [u8; 32] = fields[i].to_be_bytes::<32>();\n        //assert(split.len() == 32);\n        for j in 0..SERIALIZED_ACTIONS_PER_FIELD {\n            let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_ACTION_BYTE_SIZE;\n            actions = actions.push_back(new_action(\n                split[offset],\n                split[offset + 1],\n                split[offset + 2],\n                split[offset + 3],\n            ));\n            /*Action {\n                action: split[offset],\n                actor: split[offset + 1],\n                target_x: split[offset + 2],\n                target_y: split[offset + 3],\n            }*/\n        }\n    }\n    actions.as_array()\n}\n\nglobal H: u32 = HEIGHT as u32;\nglobal W: u32 = WIDTH as u32;\n/**\n* Warning: This function can throw!!!\n*/\n// pub fn serialize_actions(actions: [Action]) -> [Field; SERIALIZED_ACTIONS_ARRAY_SIZE] {\n//     comptime {\n//         assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_ACTIONS_PER_FIELD * SERIALIZED_ACTION_BYTE_SIZE <= 32);\n//         assert(SERIALIZED_ACTIONS_ARRAY_SIZE * SERIALIZED_ACTIONS_PER_FIELD == MAX_ACTIONS);\n//         assert(SERIALIZED_ACTION_BYTE_SIZE >= 4);\n//     }\n\n//     assert(actions.len() <= MAX_ACTIONS);\n\n//     let mut actions_stuffed: [Action; MAX_ACTIONS] = [new_action(WAIT, 0, 0, 0); MAX_ACTIONS];\n//     for i in 0..actions.len() {\n//         actions_stuffed[i] = actions[i];\n//     }\n\n//     let mut fields: [Field] = &[];\n//     for i in 0..SERIALIZED_ACTIONS_ARRAY_SIZE {\n//         let mut data: [u8; 32] = [0; 32];\n//         for j in 0..SERIALIZED_ACTIONS_PER_FIELD {\n//             let index = i * SERIALIZED_ACTIONS_PER_FIELD + j;\n//             let action = actions_stuffed[index];\n//             let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_ACTION_BYTE_SIZE;\n//             data[offset] = get_action_type(action);\n//             data[offset + 1] = get_action_actor(action);\n//             data[offset + 2] = get_action_target_x(action);\n//             data[offset + 3] = get_action_target_y(action);\n//         }\n//         fields = fields.push_back(std::field::bytes32_to_field(data));\n//     }\n//     fields.as_array()\n// }\n\n#[export]\npub fn get_performable_actions(actor: Character,\n    enemy_advance: u8, energy: u8,\n    my_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES],\n    their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]\n    // action_type: u8\n) -> pub [[Field; H]; MAX_ACTIONS_PER_CHARACTER + 1] {\n  // assert(action_type as u32 <= (MAX_ACTIONS_PER_CHARACTER + 1));\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n  let mut result = [[0; H]; MAX_ACTIONS_PER_CHARACTER + 1];\n\n  let actor_id = actor.get_id();\n  let actor_x = actor.get_x();\n  let actor_y = actor.get_y();\n  let actor_target_x = actor.get_target_x();\n  let actor_target_y = actor.get_target_y();\n  let actor_last_action = actor.get_last_action();\n\n  let actor_is_in_view_range = is_visible(enemy_advance, actor_x);\n  let map = get_free_map(my_obstacles, their_obstacles);\n\n  for action_target_y in 0..HEIGHT {\n    let mut row = [[0 as u8; W]; MAX_ACTIONS_PER_CHARACTER + 1];\n    // let dy = get_distance_part(actor.get_y(), action_target_y);\n    for action_target_x in 0..WIDTH {\n      let distance = get_distance(actor.get_x(), actor.get_y(), action_target_x, action_target_y);\n      // let dx = get_distance_part(actor.get_x(), action_target_x);\n      // let distance = get_distance_from_parts(dx, dy);\n      //let could_move_to_target = can_move_to(distance, action_target_x, action_target_y, my_obstacles, their_obstacles);\n      let could_move_to_target = is_distance_within_viewing_range(distance) & (0 == map[action_target_x][action_target_y]);\n      for action_type in 0..(MAX_ACTIONS_PER_CHARACTER + 1) {\n        let mut is_valid = true;\n        let mut actor_progress = actor.get_progress();\n        let mut actor_is_hidden = actor.get_is_hidden() == 1;\n        let mut is_not_interrupted = true;\n        let mut actor_damage_mod = actor.get_damage_mod();\n        let mut actor_status = actor.get_status();\n        let action_def = actor.actions[action_type];\n        apply_action_pre_calc_effects!(quote { action_def });\n    //        action_def_def(quote { pre_calc_effect_continues_action }, 3, |continued_action|quote { let continues_action: bool = $continued_action as u8 == actor_last_action; }),\n    // action_def_def(quote { pre_calc_effect_is_continuous }, 1, |is_continuous|quote { let is_continuous: bool = $is_continuous as bool; }),\n    // action_def_def(quote { pre_calc_effect_interrupts }, 1, |is_interrupting|quote { let is_interrupting: bool = $is_interrupting as bool; }),\n    // action_def_def(quote { pre_calc_effect_allow_retargeting }, 1, |allows_retargetting|quote { let not_interrupted_through_retargeting: bool = $allows_retargetting as bool | ((action_target_x == actor_target_x) & (action_target_y == actor_target_y)); })\n\n        validate_action_requirements!(quote { is_valid }, quote { action_def });\n        let coords = [\n            (actor_x, actor_y),\n            (action_target_x, action_target_y),\n            (NOWHERE, NOWHERE),\n        ];\n        // let mut result_energy = energy;\n        // let mut result_coords = coords[0];\n        // let mut result_progress = actor_progress;\n        // let mut result_is_hidden = actor_is_hidden;\n        // let mut result_is_visible = actor_is_in_view_range;\n        // let mut result_damage_mod = actor_damage_mod;\n        // let mut result_health = actor.get_health();\n        // let mut result_status = actor_status;\n        //apply_action_result_effects!(quote { action_def });\n        row[action_type][action_target_x] = is_valid as u8;\n      }\n    }\n    for action_type in 0..(MAX_ACTIONS_PER_CHARACTER + 1) {\n      result[action_type][action_target_y] = std::field::bytes32_to_field(row[action_type]);\n    }\n  }\n\n  result\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/action.nr"},"72":{"source":"\nuse arenalib::ARCHER;\nuse arenalib::KNIGHT;\nuse arenalib::MAGE;\nuse arenalib::RITUALIST;\nuse arenalib::ROGUE;\nuse arenalib::WIDTH;\nuse arenalib::HEIGHT;\nuse arenalib::{ CLASS_COUNT, PROGRESS_COUNT };\nuse arenalib::{ WAIT }; //, ATTACK_MELEE, ATTACK_FIREBALL, ATTACK_RANGED, MAX_FIREBALL_ROUNDS_FOR_CAST, MIN_FIREBALL_ROUNDS_FOR_CAST, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS, MAX_OBSTACLES, MAX_ACTIONS_PER_CHARACTER };\nuse arenalib::{ WIDTH_MASK, HEIGHT_MASK, CLASS_MASK, PROGRESS_MASK };\nuse arenalib::{ WIDTH_BITS, HEIGHT_BITS, CLASS_BITS, PROGRESS_BITS };\nuse crate::event::Event;\nuse crate::map::is_visible;\nuse crate::obstacle::Obstacle;\nuse crate::obstacle::new_obstacle;\nuse skplg::{NOWHERE, debug, softassert};\nuse arenalib::{ActionDefinition};\nuse arenalib::{SerializedArenaCharacterRoster, SerializedArenaActionDefinitions, SerializedArenaCharacterActionDefinitions, SerializedArenaCharacterActionDefinition};\n// use arenalib::{TRAP, ADD_OBSTACLE, WIN_BY_RITUAL, RITUAL_ROUNDS_FOR_WIN};\nuse arenalib::get_test_action_register;\nuse crate::event::{build_subtype_value_event, serialize_events};\nuse arenalib::NO_EVENT;\nuse arenalib::get_wait_action_def;\n\n\npub global SERIALIZED_CHARACTER_BYTES: u32 = 6;\npub type SerializedCharacter = [u8; SERIALIZED_CHARACTER_BYTES];\n\n// use skplam::{build_wait_action_def, build_shoot_action, build_draw_action, build_move_action, build_attack_action, build_cast_action, build_evocation_action, build_search_action, build_set_trap_action, build_sneak_action, build_ritual_action, build_disarm_trap_action};\n\n// this should be more efficient: for all the following: order is: UNKNOWN_CLASS, ARCHER, RITUALIST, ROGUE, KNIGHT, MAGE\nglobal class_damage_melee: [u8; 6] = [ 0, 32, 8, 24, 40, 16 ];\nglobal class_damage_ranged: [u8; 6] = [ 0, 24, 40, 16, 32, 8 ];\nglobal class_damage_fireball: [u8; 6] = [ 0, 0, 100, 50, 0, 100 ];\nglobal class_damage: [[u8; 6]; 3] = [ class_damage_melee, class_damage_ranged, class_damage_fireball ];\nglobal class_energy_per_attack: [u8; 6] = [ 0, 7, 7, 7, 6, 7 ];\nglobal class_energy_per_cast: [u8; 6] = [ 0, 255, 12, 255, 255, 6 ];\nglobal class_energy_per_disarm: [u8; 6] = [ 0, 255, 255, 12, 255, 255 ];\nglobal class_energy_per_move: [u8; 6] = [ 0, 3, 4, 3, 4, 4 ];\nglobal class_energy_per_ritual: [u8; 6] = [ 0, 255, 12, 255, 255, 255 ];\nglobal class_energy_per_search: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_sneak: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_draw: [u8; 6] = [ 0, 9, 255, 255, 255, 255 ];\nglobal class_energy_per_shoot: [u8; 6] = [ 0, 6, 255, 255, 255, 255 ];\nglobal resistances: [u16; 8 * 3] = [\n     0,  75, 100, 85,  50, 100, 20,  0, //,  255, 255, 0, 0, 0, 255, 255, 255 ], // Melee vs dummy, archer, ritualist, thief, knight, mage, wall, water, unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n     0,  80, 100, 90,  25, 100,  5,  0, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Ranged vs dummy, archer, ritualist, thief, knight, mage, wall, water\n     0,  80, 100, 90, 100,  90, 60, 50, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Fireball vs dummy, archer, ritualist, thief, knight, mage, wall, water\n];\n\nglobal trap_resistances: [u16; 8] = [ 0,  75, 100, 50,  75, 90, 5, 0]; //,  255, 255, 255, 255, 255, 255, 255, 255 ]; // Trap vs dummy, archer, ritualist, thief, knight, mage\n\n\n//global x: ActionDefinition = build_set_trap_action(1 as u8, 1 as u8);\n// TODO: move to character!\n// global ARCHER: u8 = 1;    WAIT, MOVE, ATTACK, DRAW, SHOOT\n// global RITUALIST: u8 = 2; WAIT, MOVE, ATTACK, CAST, RITUAL\n// global ROGUE: u8 = 3;     WAIT, MOVE, ATTACK, SNEAK, SEARCH, DISARM_TRAP, SET_TRAP\n// global KNIGHT: u8 = 4;    WAIT, MOVE, ATTACK\n// global MAGE: u8 = 5;      WAIT, MOVE, ATTACK, CAST, CAST_FIREBALL\n// global ACTION_DEFINITIONS: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER * CLASS_COUNT] = [\n//     // [[0 as u8; ACTION_DEFINITION_SIZE]; MAX_ACTIONS_PER_CHARACTER], // 0 for no action\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n    \n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ARCHER]),\n//         build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//         build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//         build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[RITUALIST]),\n//         build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//         build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//         build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ROGUE]),\n//         build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//         build_sneak_action(class_energy_per_sneak[ROGUE]),\n//         build_search_action(class_energy_per_search[ROGUE], 1),\n//         build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[KNIGHT]),\n//         build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[MAGE]),\n//         build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//         build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//         build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, FIREBALL_ROUNDS_FOR_CAST, FIREBALL_ROUNDS_FOR_CAST),\n//         WAIT_ACTION,\n//         WAIT_ACTION\n//     // ]\n// ];\n// global \n// pub fn get_test_action_register() -> [u8; ACTION_DEFINITION_REGISTER_SIZE] {\n//     build_action_def_reg!([\n//         [\n//             build_move_action(class_energy_per_move[ARCHER]),\n//             build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//             build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//             build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[RITUALIST]),\n//             build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//             build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//             build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[ROGUE]),\n//             build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//             build_sneak_action(class_energy_per_sneak[ROGUE]),\n//             build_search_action(class_energy_per_search[ROGUE], 1),\n//             build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//             build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[KNIGHT]),\n//             build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[MAGE]),\n//             build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//             build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//             build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST),\n//             build_wait_action_def(),\n//             build_wait_action_def()\n//         ]\n//     ])\n// }\n// pub fn get_test_action_register() -> SerializedArenaActionDefinitions {\n//   let action_builder = arena_action_def_builder;\n//      [\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER)),\n//             std::field::bytes32_to_field(action_builder.build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT)), // arche),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n            \n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST, 255)),\n//             std::field::bytes32_to_field(action_builder.build_ritual_action(3, class_energy_per_ritual[RITUALIST], RITUAL_ROUNDS_FOR_WIN, WIN_BY_RITUAL)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_sneak_action(class_energy_per_sneak[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_search_action(class_energy_per_search[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_set_trap_action(class_energy_per_disarm[ROGUE], 1, ADD_OBSTACLE, TRAP)),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[KNIGHT])),\n//            std::field::bytes32_to_field( action_builder.build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT])),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[MAGE], MAGE, 7)),\n//             std::field::bytes32_to_field(action_builder.build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def())\n//         ]\n// }\n\n// struct CharacterClass {\n//     class: u8,\n//     damage: u8,\n//     energy_per_attack: u8,\n//     energy_per_cast: u8,\n//     energy_per_disarm: u8,\n//     energy_per_move: u8,\n//     energy_per_ritual: u8,\n//     energy_per_search: u8,\n//     energy_per_sneak: u8,\n// }\n\npub struct Character {\n    pub id: u8,\n    pub x: u8, // 5 bit\n    pub y: u8, // 4 bit\n    pub class: u8, // 3 bit\n    pub progress: u8, // 0 = idle, 1-15 = continuing action => 4 bit\n    pub health: u8,\n    pub has_been_seen: bool,\n    pub is_hidden: u1,\n    pub target_x: u8,\n    pub target_y: u8,\n    pub damage_mod: u8,\n    pub last_action: u8,\n    pub status: u8,\n    // pub wait_action: ActionDefinition,\n    pub actions: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1], // BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER>,\n}\n\n// pub fn resolve_action(action: u8, class: u8) -> ActionDefinition {\n//     let mut idx = class as u32 * MAX_ACTIONS_PER_CHARACTER + action as u32;\n//     if idx >= (ACTION_DEFINITIONS.len()) {\n//         idx = 0;\n//     }\n//     // assert(action as u32 < MAX_ACTIONS_PER_CHARACTER);\n//     // assert(class as u32 < CLASS_COUNT);\n//     ACTION_DEFINITIONS[idx]\n// }\n//     pub fn resolve_action(action: Action) -> ActionDefinition {\n//         // let idx = get_action_base_index(self.get_id(), action);\n//         ActionDefinition::new(action, ACTION_DEFINITIONS)\n// //        (idx, ACTION_DEFINITIONS)\n//         //resolve_action(action, self.class)\n//         // let mut a = action as u32;\n//         // if a >= self.actions.len() { a = 0; }\n//         // self.actions[a] //.get_unchecked(a)\n//     }\n//global wait_action: ActionDefinition = buld_wait_action_def();\n\n// global wait_action: ActionDefinition = action_builder.build_wait_action_def();\n\nimpl Character {\n    // pub fn new(id: u8 x: u8, y: u8, class: u8, status: u8, health: u8, has_been_seen: u8)\n    /// May throw\n\n\n    pub fn get_id(self) -> u8 {\n        self.id\n    }\n\n    pub fn get_x(self) -> u8 {\n        self.x\n    }\n\n    pub fn get_y(self) -> u8 {\n        self.y\n    }\n\n    pub fn get_class(self) -> u8 {\n        self.class\n    }\n\n    pub fn get_progress(self) -> u8 {\n        self.progress\n    }\n\n    pub fn get_status(self) -> u8 {\n        self.status\n    }\n\n    pub fn get_health(self) -> u8 {\n        self.health\n    }\n\n    pub fn get_has_been_seen(self) -> bool {\n        self.has_been_seen\n    }\n\n    pub fn get_target_x(self) -> u8 {\n        self.target_x\n    }\n\n    pub fn get_target_y(self) -> u8 {\n        self.target_y\n    }\n\n    pub fn get_is_hidden(self) -> u1 {\n      self.is_hidden\n    }\n\n    pub fn get_damage_mod(self) -> u8 {\n      self.damage_mod\n    }\n\n    pub fn get_action(self, action_idx: u8) -> (bool, ActionDefinition) {\n      /*if action_idx == 0 {\n        (true, self.wait_action)\n      } else */if action_idx <= MAX_ACTIONS_PER_CHARACTER as u8 {\n        (true, self.actions[action_idx])\n      } else {\n        (false, self.actions[0])\n      }\n    }\n\n    // pub fn get_energy_per_attack(self) -> u8 {\n    //     class_energy_per_attack[self.class]\n    // }\n\n    // pub fn get_energy_per_cast(self) -> u8 {\n    //     class_energy_per_cast[self.class]\n    // }\n\n    // pub fn get_energy_per_disarm(self) -> u8 {\n    //     class_energy_per_disarm[self.class]\n    // }\n\n    // pub fn get_energy_per_move(self) -> u8 {\n    //     class_energy_per_move[self.class]\n    // }\n\n    // pub fn get_energy_per_ritual(self) -> u8 {\n    //     class_energy_per_ritual[self.class]\n    // }\n\n    // pub fn get_energy_per_search(self) -> u8 {\n    //     class_energy_per_search[self.class]\n    // }\n\n    // pub fn get_energy_per_sneak(self) -> u8 {\n    //     class_energy_per_sneak[self.class]\n    // }\n\n    // pub fn get_energy_per_draw(self) -> u8 {\n    //     class_energy_per_draw[self.class]\n    // }\n\n    // pub fn get_energy_per_shoot(self) -> u8 {\n    //     class_energy_per_shoot[self.class]\n    // }\n\n    // pub fn get_damage(self, attack_type: u8) -> u8 {\n    //     self.damage_mod + class_damage[attack_type][self.class]\n    // }\n\n    pub fn get_last_action(self) -> u8 {\n      self.last_action\n    }\n\n    // pub fn can_sneak(self) -> bool {\n    //     class_energy_per_sneak[self.class] != 255\n    // }\n\n    // pub fn can_ritual(self) -> bool {\n    //     class_energy_per_ritual[self.class] != 255\n    // }\n\n    // pub fn can_cast_fireball(self) -> bool {\n    //     class_energy_per_cast[self.class] != 255\n    // }\n\n    pub fn can_shoot(self) -> bool {\n        self.class == ARCHER\n    }\n    // pub fn can_disarm(self) -> bool {\n    //     class_energy_per_disarm[self.class] != 255\n    // }\n\n    // pub fn can_search(self) -> bool {\n    //     class_energy_per_search[self.class] != 255\n    // }\n\n    fn is_pos_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_target_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_class_valid(class: u8) -> bool { class as u32 <= CLASS_COUNT }\n    fn is_status_valid(status: u8) -> bool { status < PROGRESS_COUNT }\n\n    pub fn is_valid(self) -> bool {\n        Character::is_pos_valid(self.x, self.y) &\n        Character::is_target_valid(self.target_x, self.target_y) &\n        Character::is_class_valid(self.class) &\n        Character::is_status_valid(self.progress)\n    }\n\n    pub fn serialize(self) -> (SerializedCharacter, SerializedArenaCharacterActionDefinitions) {\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n        assert(self.is_valid());\n        let packed_x = self.x + (self.class << WIDTH_BITS);\n        let packed_y = self.y + (self.progress << HEIGHT_BITS);\n        let packed_target_x = (self.target_x & WIDTH_MASK) + ((self.is_hidden as u8) << WIDTH_BITS);\n        let packed_target_y = (self.target_y & HEIGHT_MASK) + ((self.last_action as u8) << HEIGHT_BITS);\n\n        // let serialized_action_defs = self.actions.map(|a|std::field::bytes32_to_field(a));\n        let serialized_action_defs = [\n          std::field::bytes32_to_field(self.actions[1]),\n          std::field::bytes32_to_field(self.actions[2]),\n          std::field::bytes32_to_field(self.actions[3]),\n          std::field::bytes32_to_field(self.actions[4]),\n          std::field::bytes32_to_field(self.actions[5]),\n          std::field::bytes32_to_field(self.actions[6])\n        ];\n        \n        ([packed_x, packed_y, self.health, packed_target_x, packed_target_y, self.damage_mod], serialized_action_defs)\n    }\n\n    pub fn to_obstacle(self) -> (bool, Obstacle) {\n        comptime {\n            assert(MAX_CHARACTERS < (255 - MAX_OBSTACLES));\n        }\n        assert(self.is_valid());\n        new_obstacle(self.id + (MAX_OBSTACLES as u8), self.x, self.y, self.health, self.class)\n        // Obstacle {\n        //     id: self.id + (MAX_CHARACTERS as u8),\n        //     x: self.x,\n        //     y: self.y,\n        //     obstacle_type: self.class,\n        //     health: self.health,\n        //     //was_alive: \n        // }\n    }\n\n    pub fn move(self, x: u8, y: u8) -> Character {\n        let mut c = self;\n        c.x = x;\n        c.y = y;\n        c\n    }\n\n    pub fn take_damage(self, attack_type: u8, dmg: u8) -> Character {\n        let damage_after_resistances = get_attack_damage_to_tile(attack_type, dmg as u32, self.class);\n        let mut c = self;\n        if damage_after_resistances > (c.health as u32) {\n            c.health = 0;\n        } else {\n            c.health -= (damage_after_resistances as u8);\n        }\n        c\n    }\n\n    pub fn set_status(self, status: u8) -> Character {\n        assert(status < PROGRESS_COUNT);\n        let mut c = self;\n        c.progress = status;\n        c\n    }\n\n    pub fn create_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n        // let mut actions: BoundedVec<ActionDefinition, 6> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..6 {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions.push(ACTION_DEFINITIONS[idx + i]);\n        //     }\n        // }\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: 0,\n            health: 0,\n            has_been_seen: false,\n            is_hidden: 0,\n            target_x: 255,\n            target_y: 255,\n            damage_mod: 0,//: class_damage[class],\n            last_action: WAIT,\n            status: 0, // TODO: status\n            actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1]// BoundedVec::new()\n        };\n        assert(c.is_valid());\n        c\n    }\n\n    pub fn parse(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool, Character) {\n        // these asserts could be disabled for production\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n\n      let (is_valid, c) = parse_unconstrained(id, data, actions_data, wait_action, events, enemy_advance);\n      // assert(c.)\n\n        assert(c.is_valid());\n        (is_valid, c)\n    }\n}\n\nfn parse_unconstrained(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool,Character) {\n          let mut is_valid = true;\n\n        let split: [u8; 32] = data.to_be_bytes::<32>();\n        assert(split.len() == 32);\n        let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n        let y_packed = split[2 + id * 6 + 1]; // 4 bit y, 4 bit status\n        let mut health = split[2 + id * 6 + 2] as u16;\n        let target_x_packed = split[2 + id * 6 + 3]; // 5 bit target x, 1 bit hidden, 1 bit has target, 1 bit unused\n        let target_y_packed = split[2 + id * 6 + 4]; // 4 bit target y, 4 bit last action\n        let damage_mod = split[2 + id * 6 + 5]; // last byte: for the moment, use to save damage_mod (buffs, etc)\n\n        let x = x_packed & WIDTH_MASK;\n        let y = y_packed & HEIGHT_MASK;\n        let mut class = (x_packed >> WIDTH_BITS) & CLASS_MASK;\n        if !Character::is_class_valid(class) {\n            debug!(quote { println(f\"Invalid class {class}\"); });\n            class = 0;\n            is_valid = false;\n        }\n\n        let progress = (y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n        softassert!(quote { is_valid }, quote { Character::is_status_valid(progress) }, quote { f\"Invalid status {progress} during character parsing {id}\" });\n\n        let target_x = target_x_packed & WIDTH_MASK;\n        let target_y = target_y_packed & HEIGHT_MASK;\n        let last_action = (target_y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n\n        let is_visible = is_visible(enemy_advance, x); //((target_x_packed >> 5) & 1) as u1;\n        let is_hidden = ((target_x_packed >> WIDTH_BITS) & 1) as u1;\n\n        let mut damage: u16 = 0;\n        for i in 0..MAX_EVENTS {\n            let event = events[i];\n            damage += event.get_applied_damage_to_my_asset(x, y, class);\n            // if events[i].actor_id == id {\n            //     let event = events[i];\n            //     if event.actor_id == id {\n            //         damage += event.get_applied_damage_to_my_asset(x, y, class);\n            //     }\n            // }\n        }\n        if damage > health {\n            health = 0;\n        } else {\n            health -= damage;\n        }\n\n        // let mut actions = [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]; //: BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..MAX_ACTIONS_PER_CHARACTER {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions[i] = ACTION_DEFINITIONS[idx + i];\n        //     }\n        // }\n\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: progress,\n            health: health as u8,\n            has_been_seen: is_visible, // TODO \n            is_hidden: is_hidden,\n            target_x: target_x,\n            target_y: target_y,\n            damage_mod: damage_mod,\n            last_action: last_action,\n            actions: [\n              wait_action,\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 1].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 2].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 3].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 4].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 5].to_be_bytes::<32>()\n            ],\n            status: 0 // TODO: status\n        };\n        (is_valid, c)\n}\n\n// unconstrained fn create_character_unconstrained(\n//   id: u8,\n//   x: u8,\n//   y: u8,\n//   class: u8,\n//   progress: u8,\n//   health: u8,\n//   has_been_seen: u8\n// )\n\nfn select_action_defs_of_character(actions: SerializedArenaActionDefinitions, char_id: u32) -> [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1] {\n  let mut result: [SerializedArenaCharacterActionDefinition] = &[std::field::bytes32_to_field(get_wait_action_def())];\n  let offset = char_id * MAX_ACTIONS_PER_CHARACTER;\n  for i in 0..MAX_ACTIONS_PER_CHARACTER {\n    result = result.push_back(actions[offset + i]);\n  }\n  result.as_array().map(|f|f.to_be_bytes())\n}\n\npub fn get_default_characters(side: u8) -> [Character; MAX_CHARACTERS] {\n    assert(side < 2, f\"Side is too large {side}\");\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n    let default_actions = get_test_action_register();\n\n    let x = |x| x * ((side + 1) % 2) + (WIDTH - 1 - x) * side;\n    [\n        Character { id: 0, x: x(2), y: 2, class: ARCHER, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 1), status: 0 },\n        Character { id: 1, x: x(2), y: 3, class: RITUALIST, health: 60, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 2), status: 0 },\n        Character { id: 2, x: x(2), y: 4, class: ROGUE, health: 80, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 3), status: 0 },\n        Character { id: 3, x: x(2), y: 5, class: KNIGHT, health: 120, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 4), status: 0 },\n        Character { id: 4, x: x(2), y: 6, class: MAGE, health: 40, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 5), status: 0 },\n    ]\n}\n\n#[export]\npub fn parse_characters(data: SerializedArenaCharacterRoster, actions_data: SerializedArenaActionDefinitions, events: [Event; MAX_EVENTS], enemy_advance: u8) -> pub (bool, [Character; MAX_CHARACTERS]) {\n    comptime { assert(MAX_CHARACTERS == 5); }\n\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut is_valid = true;\n\n    let wait_action = get_wait_action_def();\n\n    // no need to optimize, compiler automatically rolls this out\n    // let mut result: [Character; MAX_CHARACTERS] = [Character::create_character(0, 0, 0, 0), Character::create_character(1, 0, 0, 0), Character::create_character(2, 0, 0, 0), Character::create_character(3, 0, 0, 0), Character::create_character(4, 0, 0, 0)];\n    // for i in 0..(MAX_CHARACTERS as u8) {\n    //     let (curr_valid, curr_c) = Character::parse(i, data, actions_data, wait_action, events, enemy_advance);\n    //     is_valid &= curr_valid;\n    //     result[i] = curr_c;\n    // }\n\n        let (curr_valid, curr_c0) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[0] = curr_c0;\n        let (curr_valid, curr_c1) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[1] = curr_c1;\n        let (curr_valid, curr_c2) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[2] = curr_c2;\n        let (curr_valid, curr_c3) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[3] = curr_c3;\n        let (curr_valid, curr_c4) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[4] = curr_c4;\n    let result = [curr_c0, curr_c1, curr_c2, curr_c3, curr_c4];\n    (is_valid, result)\n}\n\npub fn get_test_my_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 100,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\npub fn get_test_their_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 255,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\n#[test]\nfn test_serialize_character() {\n    let mut character = Character {\n        id: 4,\n        x: 21,\n        y: 9,\n        class: 5,\n        progress: 9,\n        health: 129,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 31,\n        target_y: 9,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    };\n    let (field, _) = character.serialize();\n    assert(field[0] == (21 | (5 << 5)));\n    assert(field[1] == (9 | (9 << 4)));\n    assert(field[2] == 129);\n    assert(field[3] == 31); // TODO: why?\n    assert(field[4] == 9);\n    assert(field[5] == 0);\n}\n\n#[test]\nfn test_parse_character() {\n    let dummy_events = Event::get_test_dummy_events();\n    let data_array: [u8; 32] = [\n        0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        191 as u8, 249 as u8, 255 as u8, 255 as u8, 9 as u8, 255 as u8,\n        181 as u8, 153 as u8, 129 as u8, 127 as u8, 9 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n    ];\n    let data: Field = std::field::bytes32_to_field(data_array);\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    println(data);\n    assert(data == 0xbff9ffff09ffb599817f0900000000000000, f\"Failed assumption: data: {data} != 0xbff9ffff09ffb599817f0900000000000000\");\n    let (character_valid, character) = Character::parse(3, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_valid);\n    assert(character.get_id() == 3);\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 9);\n    assert(character.get_class() == 5);\n    assert(character.get_progress() == 9);\n    assert(character.get_health() == 129);\n    assert(character.get_has_been_seen());\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n\n    let (character_max_valid, character_max) = Character::parse(2, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_max_valid);\n    assert(character_max.get_id() == 2);\n    assert(character_max.get_x() == 31);\n    assert(character_max.get_y() == 9);\n    assert(character_max.get_class() == 5);\n    assert(character_max.get_progress() == 15);\n    assert(character_max.get_health() == 255);\n    assert(character_max.get_has_been_seen());\n    assert(character_max.get_target_x() == 31);\n    assert(character_max.get_target_y() == 9);\n\n    let (character_min_valid, character_min) = Character::parse(0, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_min_valid);\n    assert(character_min.get_id() == 0);\n    assert(character_min.get_x() == 0);\n    assert(character_min.get_y() == 0);\n    assert(character_min.get_class() == 0);\n    assert(character_min.get_progress() == 0);\n    assert(character_min.get_health() == 0);\n    assert(character_min.get_has_been_seen() == false);\n    assert(character_min.get_target_x() == 0);\n    assert(character_min.get_target_y() == 0);\n}\n\n#[test]\nfn test_parse_character_as_in_game() {\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    let data: Field = 0x1602ff1f09001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00;\n    let (character_valid, character) = Character::parse(0, data, dummy_actions, wait_action, Event::get_test_dummy_events(), 20);\n    assert(character_valid);\n    assert(character.get_id() == 0);\n    assert(character.get_x() == 22, character.get_x());\n    assert(character.get_y() == 2, character.get_y());\n    assert(character.get_class() == 0, character.get_class());\n    assert(character.get_progress() == 0, character.get_progress());\n    assert(character.get_health() == 255);\n    assert(character.get_has_been_seen() == true);\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n}\n\n#[export]\npub fn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> pub (Field, SerializedArenaActionDefinitions) {\n    let mut result: [u8; 32] = [0; 32];\n    let mut actions: SerializedArenaActionDefinitions = [0; 30]; //&[].as_array();\n    for i in 0..MAX_CHARACTERS {\n        let (serialized_char_bytes, serialized_actions) = chars[i].serialize();\n        for j in 0..6 {\n            result[2 + i * 6 + j] = serialized_char_bytes[j];\n        }\n        for k in 0..MAX_ACTIONS_PER_CHARACTER {\n          actions[i * MAX_ACTIONS_PER_CHARACTER + k] = serialized_actions[k];\n        }\n    }\n    \n    (std::field::bytes32_to_field(result), actions)\n}\n\n/**\n* For now we will only take class into account.\n*/\npub fn get_attack_damage_to_tile(attack_type: u8, damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * resistances[attack_type * 8 + (class & 7)] as u32 / 100) as u32\n}\n\npub fn get_trap_damage_to_tile(damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * trap_resistances[class & 7] as u32 / 100) as u32\n}\n\n#[test]\nfn test_parse_character_round0() {\n  // let actions_data = .map(|f|f.to_be_bytes::<32>()).map(|f|std::field::bytes32_to_field(f));\n  let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let enemy_advance = 0x00;\n  let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0)\n  ];\n  let serialized_events = serialize_events(events);\n   println(f\"events: {serialized_events}\");\n\n  let parsed = parse_characters(data, [\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071020100a000020100a00000020000000002000000000000000,\n    0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n    0x023100081b161118120a010018120a01000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071008100a000008100a00000020000000002000000000000000,\n    0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n    0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071018100a000018100a00000020000000002000000000000000,\n    0x09f0000130060c002000000000200000000020000000002000000000000000,\n    0xf00001100610001005000100100500010020000000002000000000000000,\n    0xf00001301c0100100d000000100d00000020000000002000000000000000,\n    0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110061028100a000028100a00000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071010100a000010100a00000020000000002000000000000000,\n    0xf000071b1611002000000000000705000020000000002000000000000000,\n    0x6300061b161164150a020164150a02010020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000\n], events, enemy_advance);\n\n  assert(parsed.0);\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/character.nr"},"74":{"source":"use arenalib::{ NO_EVENT, SEE_MOVE, RECEIVE_ATTACK, TRIGGERED_TRAP }; //, SEE_RITUAL, SEE_CAST, SEE_DRAW, SEE_SEARCH_TRAP, FOUND_TRAP\n// use crate::{ EMPTY, WALL };\nuse arenalib::{ EVENT_COUNT };\nuse arenalib::{ ATTACK_FIREBALL };\nuse arenalib::{ SERIALIZED_EVENT_BYTE_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD };\nuse arenalib::{ WIDTH };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS }; //, MAX_TRAPS\nuse arenalib::SerializedArenaEvents;\n// use crate::TRAPS_BUFFER_MASK;\nuse crate::map::get_distance;\n// use crate::character::Character;\nuse crate::character::{ get_attack_damage_to_tile, get_trap_damage_to_tile };\nuse crate::map::their_x_to_mine;\nuse skplg::{ debug, softassert, NOWHERE, UNREADABLE_BYTES_PER_FIELD };\n\npub struct Event {\n    pub event: u8,\n    pub actor_id: u8,\n    pub subtype: u8,\n    pub x: u8,\n    pub y: u8,\n    pub value: u8,\n    pub radius: u8,\n}\n\n\n    #[export]\n    pub fn parse_their_events(fields: SerializedArenaEvents) -> pub (bool, [Event; MAX_EVENTS]) {\n        comptime {\n            assert(UNREADABLE_BYTES_PER_FIELD + SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENT_BYTE_SIZE <= 32);\n            assert(SERIALIZED_EVENTS_ARRAY_SIZE * SERIALIZED_EVENTS_PER_FIELD == MAX_EVENTS);\n            assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n        }\n\n        let mut valid = true;\n        let mut events: [Event; MAX_EVENTS] = [Event::empty(0); MAX_EVENTS];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let split: [u8; 32] = fields[i].to_be_bytes::<32>(); //.to_be_bytes<32>();\n            //assert(split.len() == 32);\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                let raw_x = split[offset + 2];\n                let (x_parsed_valid, x_parsed) = their_x_to_mine(raw_x);\n                softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to calculate their_x_to_mine: {raw_x}\" });\n                events[i * SERIALIZED_EVENTS_PER_FIELD + j] = Event {\n                    event: split[offset],\n                    actor_id: split[offset + 1],\n                    x: x_parsed,\n                    y: split[offset + 3],\n                    value: split[offset + 4],\n                    subtype: split[offset + 5],\n                    radius: split[offset + 6],\n                };\n            }\n        }\n        (valid, events)\n    }\n    \n    #[export]\n    pub fn serialize_events(events: [Event; MAX_EVENTS]) -> pub SerializedArenaEvents {\n        assert(events.len() == MAX_EVENTS);\n        assert(MAX_EVENTS % SERIALIZED_EVENTS_PER_FIELD == 0);\n        assert(SERIALIZED_EVENT_BYTE_SIZE >= 6);\n\n        let mut fields: [Field] = &[];\n        for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n            let mut data: [u8; 32] = [0; 32];\n            for j in 0..SERIALIZED_EVENTS_PER_FIELD {\n                let index = i * SERIALIZED_EVENTS_PER_FIELD + j;\n                let event = events[index];\n                let offset = UNREADABLE_BYTES_PER_FIELD + j * SERIALIZED_EVENT_BYTE_SIZE;\n                data[offset] = event.event;\n                data[offset + 1] = event.actor_id;\n                data[offset + 2] = event.x;\n                data[offset + 3] = event.y;\n                data[offset + 4] = event.value;\n                data[offset + 5] = event.subtype;\n                data[offset + 6] = event.radius;\n            }\n            fields = fields.push_back(std::field::bytes32_to_field(data));\n        }\n        fields.as_array()\n    }\n    \n#[test]\nfn test_event_serde() {\n    let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 5, NO_EVENT, 1),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 6, NO_EVENT, 2),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 7, NO_EVENT, 3),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 8, NO_EVENT, 4)\n  ];\n\n  let serialized = serialize_events(events);\n  let (result_valid, result) = parse_their_events(serialized);\n  assert(result_valid);\n  assert(result[0].event == events[0].event);\n  assert(result[1].event == events[1].event);\n  assert(result[2].event == events[2].event);\n  assert(result[3].event == events[3].event);\n  assert(result[0].actor_id == events[0].actor_id);\n  assert(result[1].actor_id == events[1].actor_id);\n  assert(result[2].actor_id == events[2].actor_id);\n  assert(result[3].actor_id == events[3].actor_id);\n  assert(result[0].x == events[0].x);\n  assert(result[1].x == events[1].x);\n  assert(result[2].x == events[2].x);\n  assert(result[3].x == events[3].x);\n  assert(result[0].y == events[0].y);\n  assert(result[1].y == events[1].y);\n  assert(result[2].y == events[2].y);\n  assert(result[3].y == events[3].y);\n  assert(result[0].value == events[0].value);\n  assert(result[1].value == events[1].value);\n  assert(result[2].value == events[2].value);\n  assert(result[3].value == events[3].value);\n  assert(result[0].subtype == events[0].subtype);\n  assert(result[1].subtype == events[1].subtype);\n  assert(result[2].subtype == events[2].subtype);\n  assert(result[3].subtype == events[3].subtype);\n  assert(result[0].radius == events[0].radius);\n  assert(result[1].radius == events[1].radius);\n  assert(result[2].radius == events[2].radius);\n  assert(result[3].radius == events[3].radius);\n}\n    // fn affects_my_character(self, x: u8, y: u8) -> bool {\n    //     let distance = get_distance(self.x, self.y, x, y);\n    //     ((self.x == x) & (self.y == y)) | ((self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y))\n    // }\nimpl Event {\n    fn affects_my_obstacle(self, x: u8, y: u8) -> bool {\n        (self.x == x) & (self.y == y)\n    }\n\n    fn may_affect_my_other_characters(self) -> bool {\n        (self.event == RECEIVE_ATTACK) & (self.subtype == ATTACK_FIREBALL)\n    }\n\n    fn may_affect_my_obstacles(self) -> bool {\n        self.event == RECEIVE_ATTACK\n    }\n\n    /**\n    * For now we will only take class into account.\n    */\n    pub fn get_applied_damage_to_my_asset(self, x: u8, y: u8, tile: u8) -> u16 {\n        let mut damage = 0;\n        let radius = self.radius as u32;\n        let radius = radius * radius;\n        let distance = get_distance(self.x, self.y, x, y) as u32;\n    \n        if self.event == RECEIVE_ATTACK {\n            debug!(quote {\n                        // let event = self.event;\n                        // let actor = self.actor_id;\n                        // let self_x = self.x;\n                        // let self_y = self.y;\n                        // let val = self.value;\n                        // println(f\"GetAppliedDamageToMyAsset: Event({event}:{val} from {actor}@{self_x}|{self_y})@{x}|{y}: {distance} <= {radius}\");\n                    });\n            if distance <= radius {\n                let damage_raw = get_attack_damage_to_tile(self.subtype, self.value as u32, tile) as u32;\n                damage = damage_raw * (1 + radius - distance) / (radius + 1) as u32;\n                debug!(quote { println(f\"Deal damage: {damage_raw} * (1 + {radius} - {distance}) / ({radius} + 1) = {damage}\"); });\n            }\n            // if (self.x == x) & (self.y == y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile);\n            // } else if (self.subtype == ATTACK_FIREBALL) & is_neighbor(self.x, self.y, x, y) {\n            //     damage = get_attack_damage_to_tile(self.subtype, self.value as u16, tile) / 2;\n            // }\n        }\n        if self.event == TRIGGERED_TRAP {\n            damage = get_trap_damage_to_tile(self.value as u32, tile);\n        }\n        damage as u16\n    }\n\n    pub fn empty(actor_id: u8) -> Event {\n        Event {\n            event: NO_EVENT,\n            actor_id: actor_id,\n            x: 0,\n            y: 0,\n            value: 0,\n            subtype: 0,radius: 0\n        }\n    }\n\n    pub fn get_dummy_events() -> [Field; MAX_EVENTS] {\n        [0; MAX_EVENTS]\n    }\n\n    pub fn get_test_dummy_events() -> [Event; MAX_EVENTS] {\n        [Event::empty(0); MAX_EVENTS]\n    }\n}\n\npub fn build_std_event(event: u8, actor_id: u8, x: u8, y: u8) -> Event {\n    assert(event < EVENT_COUNT);\n    assert((actor_id as u32) < MAX_CHARACTERS);\n    assert((x < WIDTH) | (x == NOWHERE));\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: 0,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\n#[test]\nfn test_build_std_event() {\n    let event = build_std_event(SEE_MOVE, 1, 2, 3);\n    assert(event.event == SEE_MOVE);\n    assert(event.actor_id == 1);\n    assert(event.x == 2);\n    assert(event.y == 3);\n}\n\n#[test(should_fail)]\nfn test_build_std_event_fail() {\n    let event = build_std_event(EVENT_COUNT, 1, 2, 3);\n    assert(event.event == EVENT_COUNT);\n}\n\npub fn build_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8) -> Event {\n    Event {\n        event: event,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: 0,\n        radius: 0,\n    }\n}\n\npub fn build_subtype_value_event(event_type: u8, actor_id: u8, x: u8, y: u8, value: u8, event_subtype: u8, radius: u8) -> Event {\n    Event {\n        event: event_type,\n        actor_id: actor_id,\n        x: x,\n        y: y,\n        value: value,\n        subtype: event_subtype,\n        radius: radius,\n    }\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/event.nr"},"75":{"source":"mod common;\n// mod actionPreCalcEffect;\n// mod actionResultEvent;\n// mod actionResultEffect;\n// mod actionRequirements;\nmod action;\n// mod actionDefinitionRegister;\nmod bugs;\nuse arenalib::{ new_action };\npub use action::execute_action;\n// mod actionDefinition;\nmod character;\nuse character::{ Character };\nuse character::parse_characters;\nmod event;\nuse event::Event;\npub use event::{serialize_events, parse_their_events};\nmod obstacle;\nuse obstacle::Obstacle;\npub use obstacle::{ new_obstacle, parse_my_obstacles, parse_their_obstacles, get_obstacle_x, get_obstacle_y, get_obstacle_id, get_obstacle_type, get_obstacle_health, serialize_my_obstacles, get_default_obstacles };\nmod map;\nuse dep::std;\nuse obstacle::serialize_obstacle;\nuse obstacle::serialize_their_obstacles;\n// use action::ACTION_TARGET_X;\n// use action::ACTION_TARGET_Y;\n// use action::ACTION_TYPE;\nuse arenalib::{get_action_target_y, get_action_target_x, get_action_type};\nuse obstacle::serialize_my_obstacles_for_me;\nuse map::is_visible;\npub use arenalib::{SerializedArenaActionDefinitions, SerializedArenaActions, SerializedArenaCharacterRoster, SerializedArenaEnemyObstacles, SerializedArenaEvents, SerializedArenaObstacles};\nuse arenalib::arena_test_action_def_register;\nuse character::serialize_chars;\nuse skplg::{softassert, debug};\nuse arenalib::{serialize_actions, parse_actions};\n\nuse arenalib::{SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_EVENTS_ARRAY_SIZE, SERIALIZED_EVENTS_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLE_BYTE_SIZE};\nuse arenalib::{WIDTH};\nuse arenalib::{MAX_ACTIONS, MAX_CHARACTERS, MAX_EVENTS, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES};\nuse arenalib::{VIEW_DISTANCE};\nuse arenalib::{ARCHER, KNIGHT, ROGUE, MAGE, RITUALIST};\nuse arenalib::{MIN_FIREBALL_ROUNDS_FOR_CAST};\nuse arenalib::{SEE_MOVE, RECEIVE_ATTACK, NO_EVENT};\nuse arenalib::{ATTACK_FIREBALL, ATTACK_RANGED};\nuse arenalib::{WAIT};\nuse arenalib::get_wait_action_def;\nuse arenalib::get_test_action_register;\npub use action::get_performable_actions;\nuse arenalib::Action;\nuse arenalib::get_action_actor;\n\n// mod ResolvedAction;\n\n\n\n// #[export]\n// pub fn ext_can_move_to(x: u8, y: u8, obstacles: [Obstacle; MAX_OBSTACLES], their_obstacles: [Obstacle]) -> bool {\n//     assert(MAX_OBSTACLES == 24);\n//     let mut my_obstacles_parsed = Obstacle::parse_my_obstacles(my_obstacles, events).as_array();\n//     // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n//     // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n//     let enemy_objects_parsed = Obstacle::parse_their_obstacles(enemy_objects);\n\n//     let mut can = true;\n//     for i in 0..MAX_OBSTACLES {\n//         if !obstacles[i].is_traversible() & (obstacles[i].x == x) & (obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     for i in 0..their_obstacles.len() {\n//         if !their_obstacles[i].is_traversible() & (their_obstacles[i].x == x) & (their_obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     can\n// }\n\n// pub comptime global DEBUG: bool = false;\n// pub comptime fn debug(stmt: Quoted) -> Quoted {\n//     let debug_result = if DEBUG {\n//         stmt\n//     } else { quote {} };\n//     debug_result\n// }\n// pub comptime fn debugmsg<T>(msg: T) -> Quoted {\n//     debug!(quote { println($msg); })\n// }\n// pub comptime fn softassert(varname: Quoted, check: Quoted, msg: Quoted) -> Quoted {\n//     let result = if DEBUG {\n//         quote {\n//             $varname &= $check;\n//             if !($check) {\n//                 println($msg);\n//             }\n//         }\n//     } else {\n//         quote {\n//             $varname &= $check;\n//         }\n//     };\n//     result\n// }\n\n// // MAP\n// global WIDTH_BITS: u8 = 5;\n// global WIDTH_MASK: u8 = (1 << WIDTH_BITS) - 1;\n// global WIDTH: u8 = 1 << WIDTH_BITS;\n// global HEIGHT_BITS: u8 = 4;\n// global HEIGHT_MASK: u8 = (1 << HEIGHT_BITS) - 1;\n// global HEIGHT: u8 = 10;\n// // global NOWHERE: u8 = 255;\n\n// // CLASSES\n// //global UNKNOWN_CLASS: u8 = 0;\n// global ARCHER: u8 = 1;\n// global RITUALIST: u8 = 2;\n// global ROGUE: u8 = 3;\n// global KNIGHT: u8 = 4;\n// global MAGE: u8 = 5;\n// global CLASS_BITS: u8 = 3;\n// global CLASS_MASK: u8 = (1 << CLASS_BITS) - 1;\n// global CLASS_COUNT: u32 = 6;\n// global MAX_ACTIONS_PER_CHARACTER: u32 = 6;\n\n// // ACTIONS\n// global WAIT: u8 = 0;\n// //global SNEAK: u8 = 1;\n// //global MOVE: u8 = 2;          // => SEE_COLUMN (depr: MOVE)\n// //global RITUAL: u8 = 3;        // => SEE_RITUAL | WIN\n// //global SEARCH: u8 = 4;        // => SEE_SEARCH_TRAP\n// //global ATTACK: u8 = 5;        // => RECEIVE_ATTACK | DESTROY // affects my obstacles; TODO: with more attack types might also affect other own characters\n// //global CAST: u8 = 6;          // => SEE_CAST // affects my obstacles; TODO: with more attack types might also affect other own characters\n// //global CAST_FIREBALL: u8 = 7; // => RECEIVE_ATTACK // affects other characters if status == FIREBALL_ROUNDS_FOR_CAST\n// //global DRAW: u8 = 8;          // => SEE_DRAW\n// //global SHOOT: u8 = 9;         // => RECEIVE_ATTACK\n// //global TRIGGER_TRAP = 9;  // => TRIGGERED_TRAP ?????????\n// //global DISARM_TRAP: u8 = 10;  // => DESTROY\n// //global SET_TRAP: u8 = 11;\n// global ACTION_COUNT: u32 = 12;\n// pub global ACTION_RESULT_EVENT_COUNT: u32 = 4;\n// global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0;\n// global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1;\n// global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2;\n\n// // EVENTS\n// global NO_EVENT: u8 = 0 ;\n// // global DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n// //global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n// //global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\n// global SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n// //global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\n// global SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\n// global SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// global SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// global SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n// //global RECEIVE_DAMAGE = 9;   // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\n// global RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\n// global TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\n// // global FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\n// global DISARMED_TRAP: u8 = 13;      // actor_id = their-char when receive - need to remove my trap from the map\n// global WIN: u8 = 14;\n// // global LOSE: u8 = 15;\n// global ADD_OBSTACLE: u8 = 4;\n// global EVENT_COUNT: u8 = 16;\n\n// // SUBTYPES:\n// global WIN_BY_RITUAL: u8 = 1;\n\n// // ATTACKS\n// global ATTACK_MELEE: u8 = 0;\n// global ATTACK_RANGED: u8 = 1;\n// global ATTACK_FIREBALL: u8 = 2;\n// // global ATTACK_COUNT: u8 = 3;\n// // TODO: instead of enum, use a global array of structs with damage, range, etc.\n\n\n// // TILES\n// global EMPTY: u8 = 0;\n// global WALL: u8 = 6;\n// global WATER: u8 = 7;\n// // global UNKNOWN_CLASS_TILE: u8 = 8;\n// global NON_EMPTY_WALKABLE_TILE_MIN: u8 = 9;\n// // global FLAG: u8 = 9;\n// global TRAP: u8 = 10;\n// // global TRAP_USED: u8 = 11;\n// // global TRAP_FOUND: u8 = 12;\n// // global BODY: u8 = 13;\n// // global BODY_LOOTED: u8 = 14;\n// // global FOG: u8 = 15;\n// global MAX_OBSTACLE_TYPE: u8 = 0x0f;\n// // global TILE_COUNT: u8 = 16;\n// // unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n// // STATUS\n// global RITUAL_ROUNDS_FOR_WIN: u8 = 15;\n// global MIN_FIREBALL_ROUNDS_FOR_CAST: u8 = 3;\n// global MAX_FIREBALL_ROUNDS_FOR_CAST: u8 = 6;\n// // global DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\n// global MIN_DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\n// global MAX_DRAW_ROUNDS_FOR_SHOOT: u8 = 3;\n// global PROGRESS_BITS: u8 = 4;\n// global PROGRESS_MASK: u8 = (1 << PROGRESS_BITS) - 1;\n// global PROGRESS_COUNT: u8 = 16 ; // just to be more in line with the other constants, actually used as a counter\n// global MAX_HEALTH: u8 = 255;\n\n// // GAMEPLAY\n// global VIEW_DISTANCE: u8 = 6;\n// // global MAX_TRAPS: u32 = 8; // note: only lowest bit of first byte of field is usable! => ! Field = 1 bit + 31 bytes!\n// // global TRAPS_BUFFER_SIZE: Field = 16;\n// // global TRAPS_BUFFER_MASK: Field = 15; // has to be 2^n - 1\n// global MAX_ACTIONS: u32 = 4;\n// global MAX_EVENTS: u32 = 4; // = MAX_ACTIONS // NO! handle traps in a different way (by passing as argument!)+ 4 (2 FOUND_TRAP + WIN/LOSE + 1 reserved)\n// global MAX_OBSTACLES: u32 = 24; // leave traps for now + MAX_TRAPS; // 24 + 8 player placeables\n// pub global MAX_CHARACTERS: u32 = 5;\n// global MIN_PROGRESS: u8 = 0;\n// pub global MAX_PROGRESS: u8 = PROGRESS_COUNT - 1;\n// global SERIALIZED_OBSTACLE_BYTE_SIZE: u32 = 3;//3\n// pub global SERIALIZED_OBSTACLES_ARRAY_SIZE: u32 = 3;//3 // TODO: we take 3 because 3 x 8 = MAX_OBSTACLES ... should assert on this (MAX_OBSTACLES + MAX_CHARACTERS + 7) / 8;\n// pub global SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE: u32 = SERIALIZED_OBSTACLES_ARRAY_SIZE + 1; // +1 because enemy characters are also serialized as obstacles\n// global SERIALIZED_OBSTACLES_PER_FIELD: u32 = 8;//8 // TODO: need to verify that SERIALIZED_OBSTACLES_ARRAY_SIZE * SERIALIZED_OBSTACLES_PER_FIELD = MAX_OBSTACLES!\n// global SERIALIZED_EVENT_BYTE_SIZE: u32 = 7;\n// pub global SERIALIZED_EVENTS_ARRAY_SIZE: u32 = 1; // MAX_EVENTS / SERIALIZED_EVENTS_PER_FIELD => 4 / 4 = 1\n// global SERIALIZED_EVENTS_PER_FIELD: u32 = 4; // 31 / 7 = 4\n// global SERIALIZED_ACTION_BYTE_SIZE: u32 = 5;\n// pub global SERIALIZED_ACTIONS_ARRAY_SIZE: u32 = 1;\n// global SERIALIZED_ACTIONS_PER_FIELD: u32 = 4; // could be up to 6, but we only use 4\n\n\n// pub type SerializedArenaActionDefinitions = SerializedRosterActionDefinitions<MAX_ACTIONS_PER_CHARACTER, MAX_CHARACTERS>;\n// pub type SerializedArenaCharacterActionDefinitions = SerializedCharacterActionDefinitions<MAX_ACTIONS_PER_CHARACTER>;\n// pub type SerializedArenaCharacterActionDefinition = SerializedCharacterActionDefinition;\n// #[export]\n// fn tf(x: Field) -> (u32, [u8;32]) {\n//     let mut result: [u8;32] = [0;32];\n//     let bts = x.to_be_bytes::<32>();\n//     for j in 0..31 {\n//         result[j] = 2*j;//bts[j];\n//     }\n//     (32 , result)\n// }\n// i,\n// 20, 0 -> 25,\n// 25 -> 0, \n// x, 0, 0, d0,\n// x, 0, 0, 9d, 1, 0,\n// x, 0, 0, 1, 0, b4, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 91, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 23, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, d4, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, 66, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 50, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b9, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, c5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 55, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b2, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, e8, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2a, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, cb, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 9b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 5c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, a6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 86, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, d5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 38, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8e, 1, 0, 0, 1,\n// 0, 32, 1, 0, 1, 1, x, 0, 0, 1,\n// x, 0, 0, 1, x, 0, 0, 1, 0, 1, 1\n\n// i,\n// 20, 0, 1e -> 0, 0 -> 1e, 0\n// x, 0, 0, d0,\n// x, 0, 0, ba, 1, 0,\n// x, 0, 0, 1, 0, cf, 1, 0, 1, 1,\n\nfn get_actor_from_move(mut move: u32) -> u8 {\n    if (move % 2) == 1 {\n        move -= 1; //((move % 10) - 1) >> 1 // actually not needed ... but clearer this way\n    }\n    let single_digit: u32 = (move % 10 as u32) >> 1;\n    single_digit as u8\n}\n// 3, 1, 1, 1, 0, 1, 2, 0, 2, 8, 1, 0, 0, 1\n// 4, 2, 2, 0, x, 0, 0, 0, 4, a, 2, 0, 0, 2\n\n#[export]\npub fn hash_serialized_private_state(my_chars: SerializedArenaCharacterRoster, my_char_actions: SerializedArenaActionDefinitions, my_obstacles: SerializedArenaObstacles, secret: Field) -> pub Field {\n    // let my_chars_be_bytes: [u8; 32] = my_chars.to_be_bytes::<32>();\n    // assert(my_chars_be_bytes.len() == 32);\n    let gamestate_before_hash_calculated = get_data_hash(secret, my_chars, my_char_actions, my_obstacles);\n    //let gamestate_before_hash_calculated_field = std::field::bytes32_to_field(gamestate_before_hash_calculated);\n    gamestate_before_hash_calculated\n}\n\n#[test]\nfn test_hash_match() {\n  let my_chars = 12345678901234567890;\n  let my_char_actions = [\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,\n    12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890,12345678901234567890\n  ];\n  let my_obstacles = [\n    12345678901234567890, 12345678901234567890, 12345678901234567890\n  ];\n  let secret = 12345678901234567890;\n\n  let hash1 = get_data_hash(secret, my_chars, my_char_actions, my_obstacles);\n  let valid = hash_serialized_private_state(my_chars, my_char_actions, my_obstacles, secret);\n\n  assert(hash1 == valid, f\"{hash1} != {valid}\");\n}\n\n#[export]\nfn get_serialized_obstacle(id: u8, x: u8, y: u8, obstacle_type: u8) -> pub Field {\n    let mut result: [u8; 32] = [0; 32];\n    result[0] = id;\n    result[1] = x;\n    result[2] = y;\n    result[3] = obstacle_type;\n    std::field::bytes32_to_field(result)\n}\n\n// global action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// global action_builder: ActionDefinitionBuilder = ActionDefinitionBuilder::new(\n//   WAIT,\n//   MIN_PROGRESS,\n//   MAX_PROGRESS,\n//   ACTION_RESULT_COORDINATES_IDX_SELF,\n//   ACTION_RESULT_COORDINATES_IDX_TARGET,\n//   ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//   NO_EVENT,\n//   RECEIVE_ATTACK,\n//   SEE_CAST,\n//   SEE_DRAW,\n//   SEE_MOVE,\n//   SEE_RITUAL,\n//   SEE_SEARCH_TRAP,\n//   DISARMED_TRAP,\n//   ADD_OBSTACLE,\n//   WIN\n// );\n\n#[export]\npub fn calculate_action(\n  action: Action,\n  mut my_chars: [Character; MAX_CHARACTERS],\n  mut my_obstacles_parsed: [Obstacle; MAX_OBSTACLES],\n  enemy_objects_parsed: [Obstacle; MAX_ENEMY_OBSTACLES],\n  enemy_advance_input: u8,\n  mut energy: u8\n) -> (bool, [Character; MAX_CHARACTERS], [Obstacle; MAX_OBSTACLES], u8, Event) {\n  let mut success = true;\n  let actor_id = get_action_actor(action);\n  let mut actor = my_chars[actor_id];\n  let (my_chars_as_obstacles_valid, my_chars_as_obstacles) = chars_to_obstacles(my_chars);\n  softassert!(quote { success }, quote { my_chars_as_obstacles_valid }, quote { f\"Failed to convert my chars to obstacles: {my_chars}\" });\n  let result = execute_action(action, enemy_advance_input, actor, energy, my_chars_as_obstacles, my_obstacles_parsed, enemy_objects_parsed);\n  //assert(result.0);\n  success &= result.0;\n  let result_event = result.1;\n  let internal_event = result.2;\n  let self_event = result.3;\n  actor = result.4;\n  energy = result.5;\n  \n  // 4461 / 5 = 892,2\n  my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n  // 16800 / 24 = 700\n  my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| {\n      let (updated_obstacle_valid, updated_obstacle) = update_my_obstacle(obstacle, result_event);\n      //success = success & updated_obstacle_valid;\n      softassert!(quote { success }, quote { updated_obstacle_valid }, quote { f\"Failed to update my obstacle {obstacle}, {result_event}\" });\n      updated_obstacle\n  });\n\n  (success, my_chars, my_obstacles_parsed, energy, result_event)\n}\n\n#[export]\npub fn calculate_turn(\n    my_chars_input: SerializedArenaCharacterRoster,\n    my_char_actions_input: SerializedArenaActionDefinitions,\n    my_obstacles_input: SerializedArenaObstacles,\n    //mut my_obstacles_parsed: [[u8; 5]; 24],\n    actions_input: SerializedArenaActions,\n    // Common Inputs\n    move_input: u32, //pub\n    // Enemy Inputs\n    enemy_advance_input: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects_input: SerializedArenaEnemyObstacles, // pub\n    enemy_events_input: SerializedArenaEvents, // pub //MAX_EVENTS],\n\n) -> pub (bool, SerializedArenaCharacterRoster, SerializedArenaActionDefinitions, [Obstacle; 24], u8, SerializedArenaEvents, SerializedArenaEnemyObstacles) {\n    let mut success = true;\n    \n// let action_serde: ActionSerDe = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n// let action_builder: ActionDefinitionBuilder = ActionDefinitionBuilder::new(\n//   WAIT,\n//   MIN_PROGRESS,\n//   MAX_PROGRESS,\n//   ACTION_RESULT_COORDINATES_IDX_SELF,\n//   ACTION_RESULT_COORDINATES_IDX_TARGET,\n//   ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//   NO_EVENT,\n//   RECEIVE_ATTACK,\n//   SEE_CAST,\n//   SEE_DRAW,\n//   SEE_MOVE,\n//   SEE_RITUAL,\n//   SEE_SEARCH_TRAP,\n//   DISARMED_TRAP,\n//   ADD_OBSTACLE,\n//   WIN\n// );\n    //let actionRegister = ActionDefinitionRegister::new(my_char_actions_input);\n    // calculate enemy advance in our coordinates and shadow\n    // let (enemy_advance_valid, enemy_advance) = their_x_to_mine(enemy_advance);\n\n    // // more efficient to do this here, BUT leads to bad side effects for frontend (and it is not THAT costly)\n    // let enemy_advance = if enemy_advance_input >= WIDTH { 0 } else { WIDTH - enemy_advance_input - 1 };\n\n\n    // TODO: Validate map => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    let (events_valid, events) = parse_their_events(enemy_events_input);\n    softassert!(quote { success }, quote { events_valid }, quote { f\"Failed to parse their events {events}\" });\n\n    // let side = move as u1;\n    let (my_chars_valid, mut my_chars) = parse_characters(my_chars_input, my_char_actions_input, events, enemy_advance_input);\n    softassert!(quote { success }, quote { my_chars_valid }, quote { f\"Failed to parse my characters {my_chars}\" });\n\n    let actor_id = get_actor_from_move(move_input);\n    // let mut actor = my_chars[actor_id]; //Character::parse(actor_id, my_chars, events);\n    \n    comptime {\n        assert(MAX_OBSTACLES == 24);\n    }\n\n    let (valid, my_obstacles_parsed) = parse_my_obstacles(my_obstacles_input, events);\n    softassert!(quote { success }, quote { valid }, quote { f\"Failed to parse my obstacles {my_obstacles_input}\" });\n    let mut my_obstacles_parsed: [Obstacle; MAX_OBSTACLES] = my_obstacles_parsed;\n\n    let (actions_valid, actions) = parse_actions(MAX_CHARACTERS as u8, actions_input); // actions.map(|action| Action::from_field(action));\n    softassert!(quote { success }, quote { actions_valid }, quote { f\"Failed to parse actions {actions_input}\" });\n    // let mut my_obstacles_parsed = my_obstacles_parsed.as_array();\n//    let (valid, mut my_obstacles_parsed) = parse_my_obstacles(my_obstacles, events).as_array();\n    // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n    let (enemy_objects_parsed_valid, enemy_objects_parsed) = parse_their_obstacles(enemy_objects_input);\n    softassert!(quote { success }, quote { enemy_objects_parsed_valid }, quote { f\"Failed to parse their obstacles {enemy_objects_input}\" });\n\n    let mut energy: u8 = 12;\n    let mut result_events_calculated: [Event] = &[];\n    for i in 0..MAX_ACTIONS {\n        // TODO: ensure that if actor committed suicide, it is not allowed to do any more actions\n        let action = actions[i];\n        //let resolved_action = actionRegister.resolve_action(action); //resolve_action(action);\n\n        let (\n          turn_action_result_action_valid,\n          turn_action_result_my_chars,\n          turn_action_result_my_obstacles_parsed,\n          turn_action_result_energy,\n          turn_action_result_result_event\n        ) = calculate_action(\n          action,\n          my_chars,\n          my_obstacles_parsed,\n          enemy_objects_parsed,\n          enemy_advance_input,\n          energy\n        );\n        softassert!(quote { success }, quote { turn_action_result_action_valid }, quote { f\"Failed to execute turn action {i}\" });\n\n        my_chars = turn_action_result_my_chars;\n        my_obstacles_parsed = turn_action_result_my_obstacles_parsed;\n        energy = turn_action_result_energy;\n\n        // let result = execute_action(action, enemy_advance_input, actor, energy, my_obstacles_parsed, enemy_objects_parsed);\n        // //assert(result.0);\n        // success &= result.0;\n        // let result_event = result.1;\n        // let internal_event = result.2;\n        // let self_event = result.3;\n        // actor = result.4;\n        // energy = result.5;\n        \n        // // 4461 / 5 = 892,2\n        // my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n        // // 16800 / 24 = 700\n        // my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| {\n        //     let (updated_obstacle_valid, updated_obstacle) = update_my_obstacle(obstacle, result_event);\n        //     //success = success & updated_obstacle_valid;\n        //     softassert!(quote { success }, quote { updated_obstacle_valid }, quote { f\"Failed to update my obstacle {obstacle}, {result_event}\" });\n        //     updated_obstacle\n        // });\n\n        result_events_calculated = result_events_calculated.push_back(turn_action_result_result_event);\n    }\n    let result_events_calculated = serialize_events(result_events_calculated.as_array());\n    assert(result_events_calculated.len() == SERIALIZED_EVENTS_ARRAY_SIZE);\n\n    // send death events => no need\n\n    // determine view range\n    let mut my_advance_calculated = 0;\n    for i in 0..MAX_CHARACTERS {\n        if my_chars[i].x > my_advance_calculated {\n            my_advance_calculated = my_chars[i].x;\n        }\n    }\n    my_advance_calculated += VIEW_DISTANCE;\n\n    let (serialized_characters, serialized_action_defs) = serialize_chars(my_chars);\n    let serialized_obstacles: [Field] = serialize_my_obstacles(enemy_advance_input, my_obstacles_parsed);\n    let (serialized_chars_as_obstacles_valid, serialized_chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance_input, my_chars);\n    // success = success & serialized_chars_as_obstacles_valid;\n    softassert!(quote { success }, quote { serialized_chars_as_obstacles_valid }, quote { f\"Failed to serialize chars as obstacles: {my_chars}\" });\n    let serialized_obstacles_for_enemy: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE] = serialized_obstacles.push_back(serialized_chars_as_obstacles).as_array();\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles_parsed);\n\n    (success, serialized_characters, serialized_action_defs, my_obstacles_parsed, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy)\n}\n\n\n\n#[export]\npub fn turn(\n    // verification_key: pub [Field; 114],\n    // proof: pub [Field; 93],\n    // public_inputs: pub [Field; 1 ],//+ 2 * SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE + 2 * SERIALIZED_EVENTS_ARRAY_SIZE],\n    // key_hash: pub Field,\n    // last_move: pub u32,\n    // last_enemy_advance: pub u8,\n    // last_enemy_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // last_events: pub [Field, SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_advance: pub u8,\n    // last_my_result_events: pub [Field; SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_result_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // Gamestate Hashes\n    // gamestate_before_hash: pub Field,\n    // gamestate_after_hash: pub Field,\n    // My Secret State\n    secret: Field,\n    my_chars_input: SerializedArenaCharacterRoster,\n    my_char_actions: SerializedArenaActionDefinitions,\n    my_obstacles_input: SerializedArenaObstacles,\n    //my_obstacles: [[u8; 5]; 24],\n    actions: SerializedArenaActions,\n    // Common Inputs\n    move: u32, //pub\n    // Enemy Inputs\n    enemy_advance: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects: SerializedArenaEnemyObstacles, // pub\n    enemy_events: SerializedArenaEvents, // pub //MAX_EVENTS],\n    // My Results\n    my_result_advance: u8, // pub // 1 bit win, 1 bit lose, 1 bit reserved, 5 bits advance\n    my_result_events: SerializedArenaEvents, // pub\n    my_result_objects: SerializedArenaEnemyObstacles, // pub\n    // Gamestate Hashes\n    gamestate_before_hash: Field, // pub\n    gamestate_after_hash: Field, // pub\n) -> pub bool {\n    // Validate global constants (to make sure one didn't change one without updating dependet ones)\n    comptime {\n        assert((SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLE_BYTE_SIZE) < 32);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE >= MAX_OBSTACLES);\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        // assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    //let my_char_actions = arena_test_action_def_register;// get_test_action_register();\n\n    let mut success = true;\n    // let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    // assert(secret_be_bytes.len() == 32);\n\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles);\n    let gamestate_before_hash_calculated_field = hash_serialized_private_state(my_chars_input, my_char_actions, my_obstacles_input, secret);\n    // assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    softassert!(quote { success }, quote { gamestate_before_hash == gamestate_before_hash_calculated_field }, quote { f\"Invalid pre-hash: {gamestate_before_hash} != {gamestate_before_hash_calculated_field}\" });\n    // std::verify_proof(verification_key, proof, public_inputs, key_hash);\n\n    let  (turn_calc_valid, serialized_characters, my_char_actions_after, serialized_obstacles, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy) = calculate_turn(\n        my_chars_input,\n        my_char_actions,\n        my_obstacles_input,\n        actions,\n        move,\n        enemy_advance,\n        enemy_objects,\n        enemy_events\n    );\n    softassert!(quote { success }, quote { turn_calc_valid }, quote { f\"Tun calculation failed\" });\n\n    // if side == 0 {\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x > my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated += VIEW_DISTANCE;\n    // } else {\n    //     my_advance_calculated = WIDTH - 1;\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x < my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated -= VIEW_DISTANCE;\n    // }\n    softassert!(quote { success }, quote { my_result_advance == my_advance_calculated }, quote { f\"Invalid result advance: {my_result_advance} != {my_advance_calculated}\" });\n\n    // validate result\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        softassert!(quote { success }, quote { result_event_should == result_event_calculated }, quote { f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\" });\n    }\n    // assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    // let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes::<32>();\n    // assert(serialized_characters_be_bytes.len() == 32);\n    debug!(quote {\n        println(f\"serialized_obstacles: {serialized_obstacles}\");\n        println(f\"serialized_obstacles_for_enemy: {serialized_obstacles_for_enemy}\");\n        println(f\"serialized_characters: {serialized_characters}\");\n        // println(f\"serialized_characters_be_bytes: {serialized_characters_be_bytes}\");\n    });\n    // let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    assert(my_result_objects.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE {\n        let my_result_object = my_result_objects[i];\n        let serialized_obstacle = serialized_obstacles_for_enemy[i];\n        softassert!(quote { success }, quote { my_result_object == serialized_obstacle }, quote { f\"Invalid result obstacle row {i}: {my_result_object} != {serialized_obstacle}\" });\n    }\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(serialized_obstacles);\n    let new_hash_bytes = get_data_hash(secret, serialized_characters, my_char_actions_after, my_obstacles_serialized_for_me);\n    softassert!(quote { success }, quote { new_hash_bytes == gamestate_after_hash }, quote { f\"Invalid result hash: {new_hash_bytes} != {gamestate_after_hash}\" });\n    success\n}\n\nfn wb_apply_damage_to_char(mut c: Character, event: Event, actor: Character) -> Character {\n    if c.id == actor.id {\n        c = actor;\n    }\n    apply_damage_to_char(c, event)\n}\n\nfn apply_damage_to_char(c: Character, event: Event) -> Character {\n    let dmg = event.get_applied_damage_to_my_asset(c.x, c.y, c.class);\n    Character {\n        id: c.id,\n        x: c.x,\n        y: c.y,\n        class: c.class,\n        health: safe_subtract_dmg(c.health, dmg),\n        progress: c.progress,\n        target_x: c.target_x,\n        target_y: c.target_y,\n        has_been_seen: c.has_been_seen,\n        is_hidden: c.is_hidden,\n        damage_mod: c.damage_mod,\n        last_action: c.last_action,\n        actions: c.actions,\n        status: 0\n    }\n}\nfn update_my_obstacle(obstacle: Obstacle, event: Event) -> (bool, Obstacle) {\n    let dmg =\n        // event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle)) +\n        event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle));\n    new_obstacle(get_obstacle_id(obstacle), get_obstacle_x(obstacle), get_obstacle_y(obstacle), safe_subtract_dmg(get_obstacle_health(obstacle), dmg), get_obstacle_type(obstacle))\n    // Obstacle {\n    //     health: safe_subtract_dmg(obstacle.health, dmg),\n    //     id: obstacle.id,\n    //     x: obstacle.x,\n    //     y: obstacle.y,\n    //     obstacle_type: obstacle.obstacle_type,\n    // }\n}\n\nfn get_data_hash(secret: Field, characters: Field, character_actions: SerializedArenaActionDefinitions, obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> Field {\n  assert(character_actions.len() == 30);\n  assert(obstacles.len() == 3);\n  std::hash::poseidon2::Poseidon2::hash([\n    secret,\n    characters,\n    character_actions[0],\n    character_actions[1],\n    character_actions[2],\n    character_actions[3],\n    character_actions[4],\n    character_actions[5],\n    character_actions[6],\n    character_actions[7],\n    character_actions[8],\n    character_actions[9],\n    character_actions[10],\n    character_actions[11],\n    character_actions[12],\n    character_actions[13],\n    character_actions[14],\n    character_actions[15],\n    character_actions[16],\n    character_actions[17],\n    character_actions[18],\n    character_actions[19],\n    character_actions[20],\n    character_actions[21],\n    character_actions[22],\n    character_actions[23],\n    character_actions[24],\n    character_actions[25],\n    character_actions[26],\n    character_actions[27],\n    character_actions[28],\n    character_actions[29],\n    obstacles[0],\n    obstacles[1],\n    obstacles[2]\n  ], 2 + 30 + 3)\n}\n// fn get_data_hash(secret: [u8], characters: [u8], character_actions: [u8; ACTION_DEFINITION_REGISTER_SIZE], obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> [u8; 32] {\n//     assert(secret.len() == 32);\n//     assert(characters.len() == 32);\n\n//     let mut data: [u8; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE] = [0; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE];\n//     for i in 0..32 {\n//         data[i] = secret[i];\n//         data[i + 32] = characters[i];\n//     }\n//     let offset = 32 + 32;\n//     for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//         let obstacle: [u8; 32] = obstacles[i].to_be_bytes::<32>();\n//         assert(obstacle.len() == 32);\n//         for j in 0..32 {\n//             data[offset + i * 32 + j] = obstacle[j];\n//         }\n//     }\n//     let offset = 32 + 32 + 32 * SERIALIZED_OBSTACLES_ARRAY_SIZE;\n//     for i in 0..ACTION_DEFINITION_REGISTER_SIZE {\n//         data[offset + i] = character_actions[i];\n//     }\n//     // let offset = WIDTH * HEIGHT + 32 * 3;\n//     // for i in 0..10 {\n//     //     data[offset + i * 4] = (searched_traps[i] & 255) as u8;\n//     //     data[offset + i * 4 + 1] = ((searched_traps[i] >> 8) & 255) as u8;\n//     //     data[offset + i * 4 + 2] = ((searched_traps[i] >> 16) & 255) as u8;\n//     //     data[offset + i * 4 + 3] = ((searched_traps[i] >> 24) & 255) as u8;\n//     // }\n//     std::hash::blake3(data)\n// }\n\n// fn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> Field {\n//     comptime {\n//         assert(MAX_CHARACTERS <= 5);\n//     }\n//     let mut result: [u8; 32] = [0; 32];\n//     for i in 0..MAX_CHARACTERS {\n//         let serialized = chars[i].serialize();\n//         for j in 0..6 {\n//             result[2 + i * 6 + j] = serialized[j];\n//         }\n//     }\n//     std::field::bytes32_to_field(result)\n// }\n\n#[export]\npub fn chars_to_obstacles(chars: [Character; MAX_CHARACTERS]) -> pub (bool, [Obstacle; MAX_CHARACTERS]) {\n  let mut result: BoundedVec<Obstacle, MAX_CHARACTERS> = BoundedVec::new();\n  let mut valid_result = true;\n  for i in 0..MAX_CHARACTERS {\n    let (valid, char_as_obstacle) = chars[i].to_obstacle();\n    result.push(char_as_obstacle);\n    valid_result &= valid;\n  }\n  assert(result.len() == MAX_CHARACTERS);\n  (valid_result, result.storage())\n}\n\nfn serialize_chars_as_obstacles(enemy_advance: u8, chars: [Character; MAX_CHARACTERS]) -> (bool, Field) {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut result: [u8; 32] = [0; 32];\n    let mut valid_result = true;\n    for i in 0..MAX_CHARACTERS {\n        if (chars[i].is_hidden == 0) & is_visible(enemy_advance, chars[i].get_x()) {\n            let (valid, char_as_obstacle) = chars[i].to_obstacle();\n            let serialized = serialize_obstacle(char_as_obstacle);\n            valid_result = valid_result & valid;\n            result[2 + i * 3] = serialized[0];\n            result[2 + i * 3 + 1] = serialized[1];\n            result[2 + i * 3 + 2] = serialized[2];\n        }\n    }\n    (valid_result, std::field::bytes32_to_field(result))\n}\n\nfn safe_subtract_dmg(a: u8, b: u16) -> u8 {\n    let mut result = 0;\n    if (a as u16) > b {\n        result = a - (b as u8);\n    }\n    result\n}\n\nfn test_result_object_builder(enemy_advance: u8, chars: [Character; MAX_CHARACTERS], obs: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1]) {\n    let mut result: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        result[i] = obs[i];\n    }\n    let (valid, chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance, chars);\n    result[SERIALIZED_OBSTACLES_ARRAY_SIZE] = chars_as_obstacles;\n    (valid, result)\n}\n\n// fn test_helper_roster(actor: Character, mut chars: [Character; MAX_CHARACTERS]) -> [Character; MAX_CHARACTERS] {\n//     chars[actor.id] = actor;\n//     chars\n// }\n\n// fn test_helper_execute_move(move: u32, actor: Character, advances: [u8; 2], secret: [Field; 2], last_hashes: [Field; 2], chars: [[Character; MAX_CHARACTERS]; 2], obs: [[Obstacle; MAX_OBSTACLES]; 2], actions: [Action], my_events: [Event], their_events: [Event]) -> (u32, [Character; MAX_CHARACTERS], Field) {\n//     let side = move as u1;\n//     let other_side = (side as u8 + 1) as u1;\n//     let chars_after = test_helper_roster(actor, chars[side]);\n//     let my_obstacles_serialized = serialize_obstacles(advances[other_side], obs[side]);\n//     let secret_be_bytes: [u8; 32] = secret[side].to_be_bytes();\n//     assert(secret_be_bytes.len() == 32);\n//     let serialized_chars_after = serialize_chars(chars_after);\n//     let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes();\n//     assert(serialized_chars_after_be_bytes.len() == 32);\n//     let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, my_obstacles_serialized)); \n\n//     let (enemy_objects_valid, enemy_objects) = test_result_object_builder(chars[other_side], serialize_obstacles(other_side, advances[side], obs[other_side]));\n//     assert(enemy_objects_valid, \"Invalid enemy objects\");\n//     let (my_result_objects_valid, my_result_objects) = test_result_object_builder(chars_after, my_obstacles_serialized);\n//     assert(my_result_objects_valid, \"Invalid my result objects\");\n\n//     let result = turn(\n//         secret[side],\n//         character::serialize_chars(chars[side]),\n//         my_obstacles_serialized,\n//         serialize_actions(actions),\n//         move,\n//         advances[other_side],\n//         enemy_objects,\n//         Event::serialize_events(their_events).as_array(),\n//         advances[side],\n//         Event::serialize_events(my_events).as_array(),\n//         my_result_objects,\n//         last_hashes[side],\n//         current_hash\n//     );\n//     assert(result, \"Invalid result\");\n\n//     (move + 1, chars_after, current_hash)\n// }\n\n// #[test]\n// fn test_main() {\n//     let secrets = [123456789, 9876543210];\n//     let mut chars = [ character::get_default_characters(0), character::get_default_characters(1) ];\n//     let mut obs = [ Obstacle::get_default_obstacles(0), Obstacle::get_default_obstacles(1) ];\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 2, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 3, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 4, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 5, target_y: 1 },\n//     ];\n//     let their_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let mut move = 0;\n//     let mut actor = chars[0][0].move(5, 1);\n//     let mut last_hashes = [ 0x12b8f97907a05ec6a77da3f70368fa3b02e166c74edab8ea0695d6f406146559, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n//     let mut advances = [2 + VIEW_DISTANCE, 29 - VIEW_DISTANCE];\n//     advances[0] = 5 + VIEW_DISTANCE;\n\n//     let mut side = move % 2;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 0 },\n//         Action { action: MOVE, actor: 0, target_x: 27, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(27, 0);\n//     advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 1, target_y: 3 },\n//         Action { action: MOVE, actor: 1, target_x: 0, target_y: 3 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(0, 3);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 2 },\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 1, target_x: 28, target_y: 1 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(28, 1);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n// }\n\n#[test]\nfn test_main_fireball_ff() {\n  // let action_serde = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n  let wait_action = get_wait_action_def();\n    let secrets = [123456789, 9876543210];\n    let test_actions = arena_test_action_def_register.map(|a|a.to_be_bytes());\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, progress: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0, },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, progress: MIN_FIREBALL_ROUNDS_FOR_CAST + 1, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10, last_action: 3, actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, progress: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0,  },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT,actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ]\n    ];\n// x, y & type, health\n// 0x091264 0b2300 0c3400 0a442d 095764 000000000000000000000000000000 // direct\n// 0x091264 0b2319 0c3414 0a4464 095764 000000000000000000000000000000 // turn\n    let mut obs = [ get_default_obstacles(0), get_default_obstacles(1) ];\n    let actions = &[\n        new_action(4, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(1, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 20, y: 3, subtype: ATTACK_RANGED, value: 50, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    let my_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 0x78, radius: 1 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    // event actor x y value subt rad\n    // 0x091264 0b2300 0c3400 0a4428 0b5464 000000000000000000000000000000\n    // 0x0a040b04780201 03040907000000 0004000000000000040000000000000000\n    // 0x0a040b04780201 03040907000000 0004ffff0000000004ffff000000000000\n    // 0x091264 0b2300 0c3400 0a4428 095764000000000000000000000000000000\n    let mut move = 8;\n    let mut actor = Character { //chars[0][4].move(9, 7).set_status(0);\n        id: chars[0][4].id,\n        class: chars[0][4].class,\n        x: get_action_target_x(actions[1]),\n        y: get_action_target_y(actions[1]),\n        target_x: get_action_target_x(actions[1]), // TODO\n        target_y: get_action_target_y(actions[1]),\n        has_been_seen: chars[0][4].has_been_seen,\n        is_hidden: 0 as u1,\n        health: chars[0][4].health,\n        damage_mod: chars[0][4].damage_mod,\n        last_action: get_action_type(actions[1]),\n        progress: 0,\n        status: 0,\n        actions: chars[0][4].actions\n    };\n    //let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut last_hashes = [ 0x2cb6bffa42e22e89cbd87e4ac9ae7a82214febcab9c7b68e33fb1b7b8263ce7d, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 18 + VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 60), chars[side][2].take_damage(ATTACK_FIREBALL, 54), chars[side][3].take_damage(ATTACK_FIREBALL, 60), actor ];\n    let my_obstacles_serialized_for_enemy = serialize_my_obstacles(advances[other_side], obs[side]);\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n    let (serialized_chars_after, serialized_char_actions_after) = serialize_chars(chars_after);\n    // let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes::<32>();\n    // assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = get_data_hash(secrets[side], serialized_chars_after, serialized_char_actions_after, my_obstacles_serialized_for_me);\n\n    // turn:  0x2912640000004b03000000006c04002000008a0428000000a9076400000a\n    // calc:  0x2912640000004b03000000006c04002000008a0428000000a907640b340a\n    let (test_result_object_chars_after_valid, test_result_object_chars_after) = test_result_object_builder(advances[other_side], chars_after, my_obstacles_serialized_for_enemy);\n    let test_result_object_other_side_result = serialize_their_obstacles(advances[side], obs[other_side]);\n    let test_result_object_other_side = test_result_object_other_side_result.1;\n    let (test_result_object_other_chars_valid, test_result_object_other_chars) = test_result_object_builder(advances[side], chars[other_side], test_result_object_other_side);\n    println(\"Test-Inputs:\");\n    println(secrets[side]);\n    println(character::serialize_chars(chars[side]));\n    // println(get_test_action_register());\n    println(my_obstacles_serialized_for_me);\n    println(serialize_actions(actor.id, actions));\n    println(move);\n    println(advances[other_side]);\n    println(test_result_object_other_chars);\n    println(serialize_events(their_events));\n    println(advances[side]);\n    println(serialize_events(my_events));\n    println(test_result_object_chars_after);\n    println(last_hashes[side]);\n    println(current_hash);\n    println(\"Test-Inputs done\");\n    assert(test_result_object_chars_after_valid, \"Invalid test result object chars after\");\n    assert(test_result_object_other_chars_valid, \"Invalid test result object other chars\");\n\n    let (serialized_chars_input, serialized_char_actions_input) = serialize_chars(chars[side]);\n    // let (serialized_actions_valid, serialized_actions_input) = ;\n    let result = turn(\n        secrets[side],\n        serialized_chars_input,\n        serialized_char_actions_input,\n        my_obstacles_serialized_for_me, //obs[side],\n        serialize_actions(actor.id, actions),\n        move,\n        advances[other_side],\n        test_result_object_other_chars,\n        serialize_events(their_events),\n        advances[side],\n        serialize_events(my_events),\n        test_result_object_chars_after,\n        last_hashes[side],\n        current_hash\n    );\n    assert(result, \"Turn failed\");\n}\n\n\n#[test]\nfn test_calc_fireball_ff() {\n  // let action_serde = ActionSerDe::new(MAX_ACTIONS, MAX_ACTIONS_PER_CHARACTER as u8, WIDTH, HEIGHT, WAIT);\n  let wait_action = get_wait_action_def();\n    let secrets = [123456789, 9876543210];\n    let test_actions_raw = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000];\n    let test_actions = test_actions_raw.map(|a|a.to_be_bytes());\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, progress: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0, },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, progress: MIN_FIREBALL_ROUNDS_FOR_CAST + 1, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10, last_action: 3, actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, progress: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[0], test_actions[1], test_actions[2], test_actions[3], test_actions[4], test_actions[5]], status: 0,  },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[6], test_actions[7], test_actions[8], test_actions[9], test_actions[10], test_actions[11]], status: 0,  },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[12], test_actions[13], test_actions[14], test_actions[15], test_actions[16], test_actions[17]], status: 0,  },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [wait_action, test_actions[18], test_actions[19], test_actions[20], test_actions[21], test_actions[22], test_actions[23]], status: 0,  },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, progress: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT,actions: [wait_action, test_actions[24], test_actions[25], test_actions[26], test_actions[27], test_actions[28], test_actions[29]], status: 0,  },\n        ]\n    ];\n// x, y & type, health\n// 0x091264 0b2300 0c3400 0a442d 095764 000000000000000000000000000000 // direct\n// 0x091264 0b2319 0c3414 0a4464 095764 000000000000000000000000000000 // turn\n    let mut obs = [ get_default_obstacles(0), get_default_obstacles(1) ];\n    let actions = &[\n        new_action(4, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(1, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 20, y: 3, subtype: ATTACK_RANGED, value: 50, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    let my_events: [Event; MAX_EVENTS] = [\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 0x78, radius: 1 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    // event actor x y value subt rad\n    // 0x091264 0b2300 0c3400 0a4428 0b5464 000000000000000000000000000000\n    // 0x0a040b04780201 03040907000000 0004000000000000040000000000000000\n    // 0x0a040b04780201 03040907000000 0004ffff0000000004ffff000000000000\n    // 0x091264 0b2300 0c3400 0a4428 095764000000000000000000000000000000\n    let mut move = 8;\n    let mut actor = Character { //chars[0][4].move(9, 7).set_status(0);\n        id: chars[0][4].id,\n        class: chars[0][4].class,\n        x: get_action_target_x(actions[1]),\n        y: get_action_target_y(actions[1]),\n        target_x: get_action_target_x(actions[1]), // TODO\n        target_y: get_action_target_y(actions[1]),\n        has_been_seen: chars[0][4].has_been_seen,\n        is_hidden: 0 as u1,\n        health: chars[0][4].health,\n        damage_mod: chars[0][4].damage_mod,\n        last_action: get_action_type(actions[1]),\n        progress: 0,\n        status: 0,\n        actions: chars[0][4].actions\n    };\n    //let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut last_hashes = [ 0x2cb6bffa42e22e89cbd87e4ac9ae7a82214febcab9c7b68e33fb1b7b8263ce7d, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 18 + VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 60), chars[side][2].take_damage(ATTACK_FIREBALL, 54), chars[side][3].take_damage(ATTACK_FIREBALL, 60), actor ];\n    let my_obstacles_serialized_for_enemy = serialize_my_obstacles(advances[other_side], obs[side]);\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n    let (serialized_chars_after, serialized_char_actions_after) = serialize_chars(chars_after);\n    // let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes::<32>();\n    // assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = get_data_hash(secrets[side], serialized_chars_after, serialized_char_actions_after, my_obstacles_serialized_for_me);\n\n    // turn:  0x2912640000004b03000000006c04002000008a0428000000a9076400000a\n    // calc:  0x2912640000004b03000000006c04002000008a0428000000a907640b340a\n    let (test_result_object_chars_after_valid, test_result_object_chars_after) = test_result_object_builder(advances[other_side], chars_after, my_obstacles_serialized_for_enemy);\n    let test_result_object_other_side_result = serialize_their_obstacles(advances[side], obs[other_side]);\n    let test_result_object_other_side = test_result_object_other_side_result.1;\n    let (test_result_object_other_chars_valid, test_result_object_other_chars) = test_result_object_builder(advances[side], chars[other_side], test_result_object_other_side);\n    println(\"Test-Inputs:\");\n    // println(secrets[side]);\n    // println(character::serialize_chars(chars[side]));\n    // println(get_test_action_register());\n    // println(my_obstacles_serialized_for_me);\n    // println(serialize_actions(actor.id, actions));\n    // println(move);\n    // println(advances[other_side]);\n    // println(test_result_object_other_chars);\n    // println(serialize_events(their_events));\n    // println(advances[side]);\n    // println(serialize_events(my_events));\n    // println(test_result_object_chars_after);\n    println(last_hashes[side]);\n    println(current_hash);\n    println(\"Test-Inputs done\");\n    assert(test_result_object_chars_after_valid, \"Invalid test result object chars after\");\n    assert(test_result_object_other_chars_valid, \"Invalid test result object other chars\");\n\n    let (serialized_chars_input, serialized_char_actions_input) = serialize_chars(chars[side]);\n\n\n\n    comptime {\n        assert((SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLE_BYTE_SIZE) < 32);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE >= MAX_OBSTACLES);\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        // assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    let my_char_actions = arena_test_action_def_register; //get_test_action_register();\n    println(\"my_char_actions\");\n    println(my_char_actions);\n    println(\"serialized_char_actions_input\");\n    println(serialized_char_actions_input);\n    // [0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071020100a000020100a0000002000000000200000000000000000, 0x02f0000a3b190100200000000000080100002000000000200000000000000000, 0x023100081b161118120a010018120a0100002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071008100a000008100a0000002000000000200000000000000000, 0xf0003f1b1c1100200000000000070200002000000000200000000000000000, 0xff003f1b1c1100200e013f00000e013f002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071018100a000018100a0000002000000000200000000000000000, 0x09f0000130060c00200000000020000000002000000000200000000000000000, 0xf0000110061000100500010010050001002000000000200000000000000000, 0xf00001301c0100100d000000100d0000002000000000200000000000000000, 0x0bf00001100c00002000000000200000000010040a0000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110061028100a000028100a0000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071010100a000010100a0000002000000000200000000000000000, 0xf000071b161100200000000000070500002000000000200000000000000000, 0x6300061b161164150a020164150a0201002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000]\n    // [0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071020100a000020100a0000002000000000200000000000000000, 0x02f0000a3b190100200000000000080100002000000000200000000000000000, 0x023100081b161118120a010018120a0100002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071008100a000008100a0000002000000000200000000000000000, 0xf0003f1b1c1100200000000000070200002000000000200000000000000000, 0xff003f1b1c1100200e013f00000e013f002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130031400200000000010030000002000000000200000000000000000, 0x02f0000110071018100a000018100a0000002000000000200000000000000000, 0x09f0000130060c00200000000020000000002000000000200000000000000000, 0xf0000110061000100500010010050001002000000000200000000000000000, 0xf00001301c0100100d000000100d0000002000000000200000000000000000, 0x0bf00001100c00002000000000200000000010040a0000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110061028100a000028100a0000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0x03f0000130041400200000000010030000002000000000200000000000000000, 0x02f0000110071010100a000010100a0000002000000000200000000000000000, 0xf000071b161100200000000000070500002000000000200000000000000000, 0x6300061b161164150a020164150a0201002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000, 0xf0003f00000100200000000020000000002000000000200000000000000000]\n\n    let mut success = true;\n    // let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    // assert(secret_be_bytes.len() == 32);\n\n    let gamestate_before_hash = last_hashes[side];\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles);\n    let gamestate_before_hash_calculated_field = hash_serialized_private_state(serialized_chars_input, my_char_actions, my_obstacles_serialized_for_me, secrets[side]);\n    // assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"Invalid pre-hash: {gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    // std::verify_proof(verification_key, proof, public_inputs, key_hash);\n    // let (serialized_actions_valid, serialized_actions_input) = ;\n    let  (turn_calc_valid, serialized_characters, my_char_actions_after, serialized_obstacles, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy) = calculate_turn(\n        serialized_chars_input,\n        arena_test_action_def_register, //serialized_char_actions_input,\n        // get_test_action_register(),\n        my_obstacles_serialized_for_me, //obs[side],\n        serialize_actions(actor.id, actions),\n        move,\n        advances[other_side],\n        test_result_object_other_chars,\n        serialize_events(their_events)\n    );\n    assert(turn_calc_valid, f\"Tun calculation failed\");\n    assert(advances[side] == my_advance_calculated, f\"Invalid result advance:  != {my_advance_calculated}\");\n\nlet my_result_events: [Field; SERIALIZED_EVENTS_ARRAY_SIZE] = serialize_events(my_events);\n    // validate result\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        assert(result_event_should == result_event_calculated, f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\");\n    }\n    // assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    // let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes::<32>();\n    // assert(serialized_characters_be_bytes.len() == 32);\n    debug!(quote {\n        println(f\"serialized_obstacles: {serialized_obstacles}\");\n        println(f\"serialized_obstacles_for_enemy: {serialized_obstacles_for_enemy}\");\n        println(f\"serialized_characters: {serialized_characters}\");\n        // println(f\"serialized_characters_be_bytes: {serialized_characters_be_bytes}\");\n    });\n    // let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    for i in 0..test_result_object_chars_after.len() {\n        let my_result_object = test_result_object_chars_after[i];\n        let serialized_obstacle = serialized_obstacles_for_enemy[i];\n        assert(my_result_object == serialized_obstacle, f\"Invalid result obstacle row {i}: {my_result_object} != {serialized_obstacle}\");\n    }\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(serialized_obstacles);\n    let new_hash_bytes = get_data_hash(secrets[side], serialized_characters, my_char_actions_after, my_obstacles_serialized_for_me);\n    assert(new_hash_bytes == current_hash, f\"Invalid result hash: {new_hash_bytes} != {current_hash}\");\n}\n\n// #[export]\n// pub fn setup_obstacles(\n    \n// )\n\n#[test]\nfn test_calc_turn_0() {\n  let my_chars = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let test_actions = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000]; //.map(|a|a.to_be_bytes());\n  let my_obstacles = [0x62c80162c80362c80462c80563c80564c80565c80567c8000000000000,0x0467c80367c80167c80067c80760c80761c80762c80763c8000000000000,0x0764c80765c80678ff0778ff0579ff0679ff0779ff0879ff000000000000];\n  let my_actions = [0x01000a02030010030000ffff0000ffff000000000000000000000000000000];\n  let move = 0;\n  let enemy_advance = 0;\n  let enemy_objects = [0, 0, 0, 0];\n  let enemy_events = [0x04ffff0000000004ffff0000000004ffff0000000004ffff000000000000];\n\n  let result = calculate_turn(my_chars, test_actions, my_obstacles, my_actions, move, enemy_advance, enemy_objects, enemy_events);\n\n  assert(result.0);\n}\n\nfn test_turn_0() {\n  let secret = 0x075bcd15;\n  let my_chars_input = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let test_actions = [0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071020100a000020100a00000020000000002000000000000000, 0x02f0000a3b1901002000000000000801000020000000002000000000000000, 0x023100081b161118120a010018120a01000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071008100a000008100a00000020000000002000000000000000, 0xf000ff1b1c11002000000000000702000020000000002000000000000000, 0xff00ff1b1c1100200e013f00000e013f0020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300314002000000000100300000020000000002000000000000000, 0x02f0000110071018100a000018100a00000020000000002000000000000000, 0x09f0000130060c002000000000200000000020000000002000000000000000, 0xf00001100610001005000100100500010020000000002000000000000000, 0xf00001301c0100100d000000100d00000020000000002000000000000000, 0x0bf00001100c00002000000000200000000010040a00002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110061028100a000028100a00000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0x03f00001300414002000000000100300000020000000002000000000000000, 0x02f0000110071010100a000010100a00000020000000002000000000000000, 0xf000071b1611002000000000000705000020000000002000000000000000, 0x6300061b161164150a020164150a02010020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000, 0xf000ff000001002000000000200000000020000000002000000000000000]; //.map(|a|a.to_be_bytes());\n  let my_obstacles = [0x62c80162c80362c80462c80563c80564c80565c80567c8000000000000,0x0467c80367c80167c80067c80760c80761c80762c80763c8000000000000,0x0764c80765c80678ff0778ff0579ff0679ff0779ff0879ff000000000000];\n  let my_actions = [0x01000a02030010030000ffff0000ffff000000000000000000000000000000];\n  let move = 0;\n  let enemy_advance = 0;\n  let enemy_objects = [0,0,0,0];\n  let enemy_events = [0x04ffff0000000004ffff0000000004ffff0000000004ffff000000000000];\n  let my_result_advance = 0x12;\n  let my_result_objects = [0,0,0,0];\n  let my_result_events = [0xffff0000000000ffff0000000000ffff0000000000ffff000000000000];\n  let initial_hash = 0x07a86579c9d2236bd1c02ced0660e9280e1d9a73146a0c9c8e4d8e27d64d6565;\n  let final_hash = 0x2c7492b9fc2adae465ec974b512f12b29b486e7c268cca2c304330eac57dd680;\n\n  let result = turn(secret, my_chars_input, test_actions, my_obstacles, my_actions, move, enemy_advance, enemy_objects, enemy_events, my_result_advance, my_result_events, my_result_objects, initial_hash, final_hash);\n\n  assert(result);\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/lib.nr"},"76":{"source":"use arenalib::{ WIDTH, HEIGHT, WIDTH_MASK, VIEW_DISTANCE, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES };\nuse crate::obstacle::{ Obstacle, get_obstacle_y, get_obstacle_x, is_obstacle_traversible };\nuse skplg::NOWHERE;\nuse std::collections::bounded_vec;\n\n// pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> bool {\n//     // assert(curr_x < WIDTH);\n//     // assert(curr_y < HEIGHT);\n//     // assert(x < WIDTH);\n//     // assert(y < HEIGHT);\n//     // validating coordinates is not the job of this function\n//     // only avoid overflows!\n\n\n//     let shifted_curr_x = std::wrapping_add(curr_x, 1);\n//     let shifted_curr_y = std::wrapping_add(curr_y, 1);\n//     let shifted_x = std::wrapping_add(x, 1);\n//     let shifted_y = std::wrapping_add(y, 1);\n\n//     ((shifted_curr_x == shifted_x) & (std::wrapping_add(shifted_curr_y, 1) >= shifted_y) & (shifted_curr_y <= std::wrapping_add(shifted_y, 1))) |\n//     ((shifted_curr_y == shifted_y) & (std::wrapping_add(shifted_curr_x, 1) >= shifted_x) & (shifted_curr_x <= std::wrapping_add(shifted_x, 1)))\n// }\n\n// global DISTANCE_TABLE_HEIGHT: u32 = HEIGHT as u32;\n// global DISTANCE_TABLE_WIDTH: u32 = WIDTH as u32;\n\n// unconstrained fn distance_sqrt(x: u32) -> u32 {\n//     let mut result: u32 = 0;\n//     for i in 0..DISTANCE_TABLE_WIDTH {\n//         if i * i == x {\n//             result = i;\n//             break;\n//         }\n//     }\n//     result\n// }\n\n// fn d(a: u8, b: u8) -> u8 {\n//     let d = a as i32 - b as i32;\n//     let d2 = d * d;\n//     assert(d2 >= 0);\n//     let d2u = d2 as u32;\n//     let result = unsafe {\n//         let sq = distance_sqrt(d2u);\n//         assert(sq * sq == d2u);\n//         sq\n//     };\n//     assert(result < DISTANCE_TABLE_WIDTH);\n//     comptime { assert(DISTANCE_TABLE_WIDTH <= 256) };\n//     result as u8\n// }\n// global DISTANCE_TABLE: [[u8; DISTANCE_TABLE_WIDTH]; DISTANCE_TABLE_HEIGHT] = [\n//     [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 2,  2,  3,  4,  5,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ],\n//     [ 3,  3,  3,  4,  4,  5,  6,  7,  8,  9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ],\n// ]\n\nglobal MAX_DISTANCE: u32 = 0xff * 0xff;\npub type DISTANCE = u16;\nfn get_distance_part(curr: u8, target: u8) -> DISTANCE_PART_ROLLED_OUT {\n  let d = if curr > target { curr - target } else { target - curr } as u32;\n  d * d\n}\npub fn get_distance(curr_x: u8, curr_y: u8, x: u8, y: u8) -> DISTANCE {\n    // assert(curr_x < WIDTH);\n    // assert(curr_y < HEIGHT);\n    // assert(x < WIDTH);\n    // assert(y < HEIGHT);\n    // validating coordinates is not the job of this function\n    // only avoid overflows!\n\n    // let dx = unsafe {\n    //     let diff_\n    //     distance_sqrt(x)\n    // }\n\n    let dx = get_distance_part(curr_x, x);\n    let dy = get_distance_part(curr_y, y);\n\n    // let dx = curr_x as i16 - x as i16;\n    // let dy = curr_y as i16 - y as i16;\n  get_distance_from_parts(dx, dy)\n}\n// NOTE: Leaving it for now, but no actual performance benefit from splitting this\npub type DISTANCE_PART_ROLLED_OUT = u32;\nfn get_distance_from_parts(x: DISTANCE_PART_ROLLED_OUT, y: DISTANCE_PART_ROLLED_OUT) -> DISTANCE {\n  let distance = x + y;\n  if distance > MAX_DISTANCE {\n    MAX_DISTANCE as u16\n  } else {\n    distance as u16\n  }\n}\n\n\npub fn is_visible(enemy_advance: u8, x: u8) -> bool {\n    //(x >= enemy_advance) == (side == 0)\n    x >= enemy_advance\n}\n\n// TODO: This is for the future - fireballs, etc. only if we have line of sight\n// pub fn is_visible(curr_x: u8, curr_y: u8, x: u8, y: u8, map: &Map) -> bool {\n//     assert(curr_x < WIDTH);\n//     assert(curr_y < HEIGHT);\n//     assert(x < WIDTH);\n//     assert(y < HEIGHT);\n\n//     let mut x = curr_x as f32;\n//     let mut y = curr_y as f32;\n//     let x2 = x + 0.5;\n//     let y2 = y + 0.5;\n//     let dx = x2 - x;\n//     let dy = y2 - y;\n//     let mut t = 0.0;\n//     let mut max_t = 1.0;\n//     let mut x = x;\n//     let mut y = y;\n\n//     while t < max_t {\n//         let x = x + dx * t;\n//         let y = y + dy * t;\n//         let x = x as u8;\n//         let y = y as u8;\n\n//         if map.is_wall(x, y) {\n//             return false;\n//         }\n\n//         t += 0.1;\n//     }\n\n//     true\n// }\n\npub fn their_x_to_mine(x: u8) -> (bool, u8) {\n    if x == NOWHERE {\n        (true, NOWHERE)\n    } else {\n        (x < WIDTH, std::wrapping_sub(WIDTH - 1, x) & WIDTH_MASK)\n    }\n}\n\npub fn is_distance_within_viewing_range(distance: u16) -> bool {\n  distance <= (VIEW_DISTANCE as u16 * VIEW_DISTANCE as u16)\n}\n\npub fn is_tile_free_or_invisible(x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n  let mut can = true;\n  for i in 0..MAX_OBSTACLES {\n      if !is_obstacle_traversible(obstacles[i]) & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n      if !is_obstacle_traversible(their_obstacles[i]) & (get_obstacle_x(their_obstacles[i]) == x) & (get_obstacle_y(their_obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  can\n}\n\nglobal W: u32 = WIDTH as u32;\nglobal H: u32 = HEIGHT as u32;\nunconstrained fn _get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] {\n  let mut map = [[0; H]; W];\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  map\n}\n\nunconstrained fn _to_obstacle_collision_array(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [(u8, u8, bool); MAX_ENEMY_OBSTACLES * 2] {\n  let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i] = (x,y,is_obstacle_traversible(obstacle));\n\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  o\n}\n\npub fn get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] { // missing own chars\n  // Safety: verifying all map elements afterwards\n  let map = unsafe { _get_free_map(obstacles, their_obstacles) };\n  \n  // Safety: verifying all below\n  //let o = unsafe { _to_obstacle_collision_array(obstacles, their_obstacles) };\n   //let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n\n          if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //o[i] = (x,y,is_obstacle_traversible(obstacle));\n          // assert(o[i].0 == x);\n          // assert(o[i].1 == y);\n          // assert(o[i].2 == is_obstacle_traversible(obstacle));\n\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = their_obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //  o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n\n          // assert(o[i + MAX_ENEMY_OBSTACLES].0 == x);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].1 == y);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].2 == is_obstacle_traversible(obstacle));\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        let mut sum: u32 = 0;\n  for x in 0..WIDTH {\n    for y in 0..HEIGHT {\n      sum += map[x][y] as u32;\n      // let val = map[x][y];\n      // if !val {\n      //   let mut found_obstacle = false;\n\n      //   for i in 0..58 {\n      //     if (x == o[i].0) & (y == o[i].1) & o[i].2 {\n      //       found_obstacle = true;\n      //     }\n      //   }\n\n      //   assert(found_obstacle);\n      // }\n    }\n  }\n  let mut obstacle_sum: u32 = 0;\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    obstacle_sum += (!is_obstacle_traversible(obstacles[i])) as u32 + (!is_obstacle_traversible(their_obstacles[i])) as u32;\n  }\n  assert(sum == obstacle_sum);\n\n  map\n}\n\npub fn can_move_to(distance: u16, x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n    let mut can = is_distance_within_viewing_range(distance); //x <= advance;\n    can &= is_tile_free_or_invisible(x, y, obstacles, their_obstacles);\n\n    can\n}\n// pub fn their_x_to_mine(side: u1, x: i8) -> i8 {\n//     let mul = side as i8;\n//     mul * 31 + 16 + x\n// }\n\n// x * s -16 + y = 0 if s == 0 => y = 16\n// x * s -16 + y = 31 if s == 1 => x = 31\n// y = 31 * s + 16 + x\n// s = 0:\n// x = -16 => y = 0\n// x = 15 => y = 31\n// s = 1:\n// x = -16 => y = 31\n// x = 15 => y = 0\n\n// pub fn serialize_x(x: i8) -> (bool, u8) {\n//     let valid = (x >= -(WIDTH / 2) as i8) & (x < (WIDTH / 2) as i8);\n//     (valid, (x + (WIDTH / 2) as i8) as u8)\n// }\n\n// pub fn deserialize_x(x: u8) -> (bool, i8) {\n//     let valid = x < WIDTH;\n//     (valid, x as i8 - (WIDTH / 2) as i8)\n// }","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/map.nr"},"77":{"source":"// use crate::MAX_OBSTACLES;\n// use crate::{ HEIGHT, WIDTH };\n// use crate::{ EMPTY, WALL, WATER };\n// use crate::{ MAX_EVENTS }; // MAX_CHARACTERS\n// // use crate::{ RECEIVE_ATTACK };\n// // use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\n// use crate::{ SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\n// use crate::event::Event;\n// use crate::map::{ is_visible }; //is_neighbor\n// use dep::std;\n\n// pub struct Obstacle {\n//     pub id: u8,\n//     pub x: u8,             // 5 bit\n//     pub y: u8,             // 4 bit\n//     pub health: u8,        // 8 bit\n//     pub obstacle_type: u8, // 4 bit\n// }\n\n// pub impl Obstacle {\n//     pub fn serialize(self) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         assert(self.y < 0x10, f\"Obstacle y is too large\");\n//         assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n\n//         let packed_y = self.obstacle_type * 0x10 + self.y;\n//         [ self.x, packed_y, self.health]\n//     }\n\n//     pub fn is_obstacle_traversible(self) -> bool {\n//         (self.obstacle_type >= NON_EMPTY_WALKABLE_TILE_MIN) | (self.obstacle_type == EMPTY)\n//     }\n\n//     pub fn parse_their_obstacles(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let health = field[2];\n//         let o = Obstacle {\n//             id: id,\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn parse_obstacle(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let mut health = field[2];\n//         if (obstacle_type == WALL) | (obstacle_type == WATER) {\n//             let mut damage = 0;\n//             for i in 0..MAX_EVENTS {\n//                 damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n//             }\n//             if damage > (health as u16) {\n//                 health = 0;\n//             } else {\n//                 health -= (damage as u8);\n//             }\n//         }\n//         let o = Obstacle {\n//             id: id, // + (MAX_CHARACTERS as u8),\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//             //was_alive: was_alive,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         (self.x < WIDTH) & (self.y < HEIGHT)\n//     }\n\n//     pub fn parse_their_obstacles(serialized_obstacles: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_their_obstacles(id, serialized_obstacle));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn parse_my_obstacles(serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], events: [Event; MAX_EVENTS]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_obstacle(id, serialized_obstacle, events));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn serialize_obstacles(side: u1, enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n//         let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n//         for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//             let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n//                 if is_visible(side, enemy_advance, obstacle.x) {\n//                     let serialized_obstacle = obstacle.serialize();\n//                     for k in 0..3 {\n//                         serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n//                     }\n//                 }\n//             }\n//             serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n//         }\n//         serialized_obstacles\n//     }\n\n//     pub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n//         // assert(side < 2, f\"Side is too large {side}\");\n//         let x = |x| x * (((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n//         [\n//             new_obstacle( 0, x(0), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 1, x(1), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 2, x(3), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 3, x(4), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 4, x(5), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle( 5, x(5), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle( 6, x(5), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle( 7, x(5), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 8, x(4), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 9, x(3), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(10, x(1), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(11, x(0), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(12, x(7), y: 0, obstacle_type: 200, WALL),\n//             new_obstacle(13, x(7), y: 1, obstacle_type: 200, WALL),\n//             new_obstacle(14, x(7), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle(15, x(7), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle(16, x(7), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle(17, x(7), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle(18, x(6), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(19, x(7), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(20, x(5), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(21, x(6), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(22, x(7), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(23, x(8), y: 9, obstacle_type: 255, WATER),\n//         ]\n//     }\n// }\n\n\nuse arenalib::MAX_OBSTACLES;\nuse arenalib::{ HEIGHT, WIDTH };\nuse arenalib::{ EMPTY, WALL, WATER };\nuse arenalib::{ MAX_EVENTS, MAX_HEALTH, MAX_OBSTACLE_TYPE, MAX_ENEMY_OBSTACLES }; // MAX_CHARACTERS\n// use crate::{ RECEIVE_ATTACK };\n// use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\nuse arenalib::{ SerializedArenaEnemyObstacles, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\nuse arenalib::NON_EMPTY_WALKABLE_TILE_MIN;\nuse arenalib::SerializedArenaObstacles;\nuse crate::event::Event;\nuse crate::map::{ is_visible, their_x_to_mine }; //is_neighbor\nuse dep::std;\nuse skplg::{softassert, NOWHERE};\nuse arenalib::SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE;\nuse arenalib::MAX_CHARACTERS;\n\n// pub type Obstacle = [u8; 5];\npub struct Obstacle {\n    pub id: u8,\n    pub x: u8,             // 5 bit\n    pub y: u8,             // 4 bit\n    pub health: u8,        // 8 bit\n    pub obstacle_type: u8, // 4 bit\n}\npub fn get_obstacle_id(obstacle: Obstacle) -> u8 {\n    obstacle.id //obstacle[0]\n}\npub fn get_obstacle_x(obstacle: Obstacle) -> u8 {\n    obstacle.x //[1]\n}\npub fn get_obstacle_y(obstacle: Obstacle) -> u8 {\n    obstacle.y //[2]\n}\npub fn get_obstacle_health(obstacle: Obstacle) -> u8 {\n    obstacle.health //[3]\n}\npub fn get_obstacle_type(obstacle: Obstacle) -> u8 {\n    obstacle.obstacle_type //[4]\n}\n\n#[export]\npub fn new_obstacle(id: u8, x: u8, y: u8, health: u8, obstacle_type: u8) -> pub (bool, Obstacle) {\n  let valid = ((x < WIDTH) | (x == NOWHERE)) & ((y < HEIGHT) | (y == NOWHERE)) & (health <= MAX_HEALTH) & (obstacle_type <= MAX_OBSTACLE_TYPE) & (id as u32 < (MAX_OBSTACLES + MAX_CHARACTERS));\n    // let mut valid = true;\n    // softassert!(quote { valid }, quote { (x < WIDTH) | (x == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid x: {x} >= {WIDTH}\" });\n    // softassert!(quote { valid }, quote { (y < HEIGHT) | (y == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid y: {y} >= {HEIGHT}\" });\n    // softassert!(quote { valid }, quote { health <= MAX_HEALTH }, quote { f\"Cannot create Obstacle: Invalid health: {health} > {MAX_HEALTH}\" });\n    // softassert!(quote { valid }, quote { obstacle_type <= MAX_OBSTACLE_TYPE }, quote { f\"Cannot create Obstacle: Invalid obstacle type: {obstacle_type} > {MAX_OBSTACLE_TYPE}\" }); //TODO: not sure if this or is_valid???\n    // (valid, [ id, x, y, health, obstacle_type ])\n    (valid, Obstacle { id: id, x: x, y: y, health: health, obstacle_type: obstacle_type })\n}\n\n#[test]\nfn test_new_obstacle() {\n  let (val, o) = new_obstacle(0, 0, 2, 0xc8, 0x06);\n  assert(val);\n  assert(o.id == 0);\n}\n\n// #[export]\n// pub struct FrontendObstacle {\n//   pub id: u8,\n//   pub x: u8,\n//   pub y: u8,\n\n// }\n\npub fn serialize_obstacle(obstacle: Obstacle) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n    // we could assert here, since obstacles can only be create with new_obstacle?!\n    // assert(self.y < 0x10, f\"Obstacle y is too large\");\n    // assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n    comptime {\n        let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let packed_y = get_obstacle_type(obstacle) * 0x10 + get_obstacle_y(obstacle);\n                [ get_obstacle_x(obstacle), packed_y, get_obstacle_health(obstacle)]\n            }\n        } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n                [ get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_health(obstacle), get_obstacle_type(obstacle)]\n            }\n        } else {\n            quote {\n                assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n            }\n        };\n        q\n    }\n}\n\npub fn is_obstacle_traversible(obstacle: Obstacle) -> bool {\n    (get_obstacle_type(obstacle) >= NON_EMPTY_WALKABLE_TILE_MIN) | (get_obstacle_type(obstacle) == EMPTY)\n}\n\npub fn parse_their_obstacle(id: u8, fld: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> (bool, Obstacle) {\n    comptime {\n        assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n    }\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let mut valid = true;\n    let x_raw = fld[0];\n    let (x_parsed_valid, x_parsed) = their_x_to_mine(x_raw);\n    softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to convert their x to mine of their obstacle {id}: {x_raw}\" });\n    let y = fld[1] & 0x0F;\n    let obstacle_type = (fld[1]) / 0x10;\n    let health = fld[2];\n    let (obstacle_valid, obstacle) = new_obstacle(id, x_parsed, y, health, obstacle_type);\n    softassert!(quote { valid }, quote { obstacle_valid }, quote { f\"Failed to create new obstacle {id}, {x_parsed}, {y}, {health}, {obstacle_type}\" });\n    (valid, obstacle)\n    // let o = Obstacle {\n    //     id: id,\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn parse_obstacle(id: u8, f: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> (bool, Obstacle) {\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let x = f[0];\n    // let mut y = f[1];\n    // let mut obstacle_type = f[1];\n    // comptime {\n    //     let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n    //         quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let y = f[1] & 0x0F;\n                let obstacle_type = (f[1]) / 0x10;\n    //         }\n    //     } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n    //         quote {\n    //             assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n    //             y = f[1];\n    //             obstacle_type = f[3];\n    //         }\n    //     } else {\n    //         quote {\n    //             assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n    //         }\n    //     };\n    //     q\n    // }\n    // let y = f[1]; // & 0x0F;\n    // let obstacle_type = f[3]; //f[1] / 0x10;// (f[1] & 0xF0) / 0x10;\n    let mut health = f[2];\n    //if (obstacle_type == WALL) | (obstacle_type == WATER) {\n        let mut damage = 0;\n        for i in 0..MAX_EVENTS {\n            damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n        }\n        if damage > (health as u16) {\n            health = 0;\n        } else {\n            health -= (damage as u8);\n        }\n    //}\n    new_obstacle(id, x, y, health, obstacle_type)\n    // let o = Obstacle {\n    //     id: id, // + (MAX_CHARACTERS as u8),\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    //     //was_alive: was_alive,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn is_obstacle_valid(obstacle: Obstacle) -> bool {\n    (get_obstacle_x(obstacle) < WIDTH) & (get_obstacle_y(obstacle) < HEIGHT)\n}\n\npub fn parse_their_obstacles(serialized_obstacles: SerializedArenaEnemyObstacles) -> (bool, [Obstacle; MAX_ENEMY_OBSTACLES]) {\n  let (dummy_obstacle_valid, dummy_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, 255, 0);\n  assert(dummy_obstacle_valid);\n    let mut obstacles: [Obstacle; MAX_ENEMY_OBSTACLES] = [dummy_obstacle; MAX_ENEMY_OBSTACLES];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n            obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j] = obstacle; //s.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    let serialized_obstacle_field = serialized_obstacles[SERIALIZED_OBSTACLES_ARRAY_SIZE].to_be_bytes::<32>();\n    assert(serialized_obstacle_field.len() == 32);\n    for j in 0..MAX_CHARACTERS {\n      let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n      // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n      let id = (MAX_OBSTACLES + j) as u8;\n      let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n      obstacles[MAX_OBSTACLES + j] = obstacle; //s.push_back(obstacle);\n      valid_result = valid_result & valid;\n    }\n    (valid_result, obstacles)\n}\n\npub fn parse_my_obstacles(serialized_obstacles: SerializedArenaObstacles, events: [Event; MAX_EVENTS]) -> (bool, [Obstacle; MAX_OBSTACLES]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            //let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_obstacle(id, serialized_obstacle, events);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles.as_array())\n}\n\n#[export]\npub fn serialize_my_obstacles_for_me(obstacles: [Obstacle; MAX_OBSTACLES]) -> pub [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            let serialized_obstacle = serialize_obstacle(obstacle);\n            for k in 0..3 {\n                serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\n\npub fn serialize_my_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let serialized_obstacle = serialize_obstacle(obstacle);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\npub fn serialize_their_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) {\n    let mut valid_result = true;\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let parsed_x = their_x_to_mine(get_obstacle_x(obstacle));\n                valid_result = valid_result & parsed_x.0;\n                let mirrored_obstacle = new_obstacle(\n                    get_obstacle_id(obstacle),\n                    parsed_x.1,\n                    get_obstacle_y(obstacle),\n                    get_obstacle_health(obstacle),\n                    get_obstacle_type(obstacle)\n                );\n                valid_result = valid_result & mirrored_obstacle.0;\n                let serialized_obstacle = serialize_obstacle(mirrored_obstacle.1);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    (valid_result, serialized_obstacles)\n}\n\nfn get_x_of_side(side: u1, x: u8) -> u8 {\n    x * ((side as u8 + 1) as u1) as u8 + side as u8 * (WIDTH - 1 - x)\n}\n\n#[test]\nfn test_x() {\n    let x8s0 = get_x_of_side(0, 8);\n    assert(x8s0 == 8, f\"{x8s0} != 8\");\n    let x8s1 = get_x_of_side(1, 8);\n    assert(x8s1 == 23, f\"{x8s1} != 23\");\n}\n\npub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n    // assert(side < 2, f\"Side is too large {side}\");\n    let x = |x| get_x_of_side(side, x); //(((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n    [\n        new_obstacle( 0, x(0), 2, 200, WALL).1,\n        new_obstacle( 1, x(1), 2, 200, WALL).1,\n        new_obstacle( 2, x(3), 2, 200, WALL).1,\n        new_obstacle( 3, x(4), 2, 200, WALL).1,\n        new_obstacle( 4, x(5), 3, 200, WALL).1,\n        new_obstacle( 5, x(5), 4, 200, WALL).1,\n        new_obstacle( 6, x(5), 5, 200, WALL).1,\n        new_obstacle( 7, x(5), 7, 200, WALL).1,\n        new_obstacle( 8, x(4), 7, 200, WALL).1,\n        new_obstacle( 9, x(3), 7, 200, WALL).1,\n        new_obstacle(10, x(1), 7, 200, WALL).1,\n        new_obstacle(11, x(0), 7, 200, WALL).1,\n        new_obstacle(12, x(7), 0, 200, WALL).1,\n        new_obstacle(13, x(7), 1, 200, WALL).1,\n        new_obstacle(14, x(7), 2, 200, WALL).1,\n        new_obstacle(15, x(7), 3, 200, WALL).1,\n        new_obstacle(16, x(7), 4, 200, WALL).1,\n        new_obstacle(17, x(7), 5, 200, WALL).1,\n        new_obstacle(18, x(6), 8, 255, WATER).1,\n        new_obstacle(19, x(7), 8, 255, WATER).1,\n        new_obstacle(20, x(5), 9, 255, WATER).1,\n        new_obstacle(21, x(6), 9, 255, WATER).1,\n        new_obstacle(22, x(7), 9, 255, WATER).1,\n        new_obstacle(23, x(8), 9, 255, WATER).1,\n        // new_obstacle(24, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(25, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(26, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(27, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(28, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(29, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(30, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(31, x(0), 0, 255, EMPTY).1,\n    ]\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/obstacle.nr"},"90":{"source":"use dep::std::{append::Append};\nuse skplg::UNREADABLE_BYTES_PER_FIELD;\n\npub trait ActionDefinitionPartBuilder<T> { fn new() -> T; }\npub type DEF_ROW<T> = (Quoted, u8, T);\npub comptime fn get_def_register_value(register: Quoted, bytes: u32, bits: u8, bitsize: u8) -> Quoted {\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    if bitsize == 8 {\n      quote { $register[$bytes] }\n      // quote { ($register / $multiplier) as u8 }\n    } else {\n      let divisor = 1 << bits;\n      let mask = std::wrapping_sub(1 << bitsize, 1);\n      if bitsize == 1 {\n        // quote { (($register / $multiplier) as u1) == 1 }\n        quote { (($register[$bytes] as u8 & $divisor as u8) != 0 as u8) }\n      } else {\n        quote { (($register[$bytes] as u8 / $divisor as u8) & $mask as u8) }\n        // quote { (($register / $multiplier) as u8) & $mask as u8 }\n      }\n    }\n}\npub comptime fn build_over_def_array<Env, T>(array: [DEF_ROW<T>], base_index: u32, builder: fn[Env] (u32, u8, Quoted, u8, T) -> Quoted) -> Quoted {\n  let mut result = quote {};\n  \n  let mut bits: u8 = 0;\n  let mut bytes: u32 = base_index;\n\n  for i in 0..array.len() {\n    let (varname, bitsize, args) = array[i];\n    assert(bitsize <= 8, f\"Invalid bit size: {bitsize}\");\n    if (bits + bitsize) > 8 {\n      bytes += 1;\n      bits = 0;\n    }\n    assert(bits < 8, f\"bits must not reach 8 or higher: {bits}\");\n\n    let new_result = builder(bytes, bits, varname, bitsize, args);\n    result = quote { $result $new_result };\n\n    bits += bitsize;\n  }\n  result\n}\npub comptime fn derive_action_def_def_builder<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let mut params: [(Quoted, Type)] = &[];\n  let mut last_byte: u32 = 0;\n  let mut result: Quoted = build_over_def_array(array, 0, |bytes, bits, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { u8 }.as_type() } else { quote { u8 }.as_type() };\n    params = params.push_back((varname, t));\n    let mut r = quote {};\n    if bytes != last_byte {\n      r = r.append(quote { , });\n    } else if (bytes + bits as u32) != 0 {\n      r = r.append(quote { + });\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = r.append(quote { $varname  });\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = r.append(quote { $varname as u8 * $multiplier });\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = r.append(quote { (( $varname & $mask ) * $multiplier) });\n      }\n    }\n    last_byte = bytes;\n    r\n  });\n  f.set_parameters(params);\n\n  let return_type = f.return_type();\n\n  f.set_body(quote { $return_type { register: [ $result ] } }.as_expr().unwrap());\n  // println(f.body());\n}\npub comptime fn get_action_def_def_register_size<T>(array: [DEF_ROW<T>]) -> u32 {\n  let mut size = 0;\n  let _ = build_over_def_array(array, 0, |bytes, _, _, _, _|{\n    size = bytes;\n    quote {}\n  });\n  size + 1\n}\npub comptime fn get_action_def_def_register_element_type() -> Type {\n  quote { u8 }.as_type()\n}\npub comptime fn get_action_def_def_register_type<T>(array: [DEF_ROW<T>]) -> Type {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  quote { [$et; $size] }.as_type()\n}\npub comptime fn derive_action_def_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  // let size = get_action_def_requirements_register_size();\n  let fields = s.fields([]);\n  assert(fields.len() == 1);\n  s.set_fields([(fields[0].0, get_action_def_def_register_type(array))]);\n}\npub comptime fn derive_action_def_def_struct_new<T>(f: FunctionDefinition, array: [DEF_ROW<T>]) {\n  let size = get_action_def_def_register_size(array);\n  let et = get_action_def_def_register_element_type();\n  let t = get_action_def_def_register_type(array);\n  f.set_return_type(t);\n  f.set_body(quote { ActionRequirement { [0 as $et; $size] } }.as_expr().unwrap());\n}\npub comptime fn derive_frontend_action_def_struct<T>(s: StructDefinition, array: [DEF_ROW<T>]) {\n  let mut fields: [(Quoted, Type)] = &[];\n  let _ = build_over_def_array(array, UNREADABLE_BYTES_PER_FIELD, |_, _, varname, bitsize, _|{\n    let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    fields = fields.push_back((varname, t));\n    quote {}\n  });\n  s.set_fields(fields);\n}\npub comptime fn derive_frontend_action_def_struct_builder<T>(param_name: Quoted, base_index: u32, array: [DEF_ROW<T>]) -> Quoted {\n  // let mut params: [(Quoted, Type)] = &[];\n  let mut first = true;\n  let mut result: Quoted = build_over_def_array(array, base_index, |bytes, bits, varname, bitsize, _|{\n    // let t = if bitsize == 1 { quote { bool }.as_type() } else { quote { u8 }.as_type() };\n    // params = params.push_back((varname, t));\n    // let pos = (bytes * 8 + bits as u32) as Field;\n    // let multiplier = 2.pow_32(pos);\n    let mut r = quote {};\n    if !first {\n      r = quote { , };\n    }\n    assert(bitsize > 0);\n    assert(bitsize <= 8);\n    if bitsize == 8 {\n      r = quote { $r $varname: $param_name[$bytes] };\n      // r = quote { $r $varname: ($param_name / $multiplier) as u8 };\n    } else {\n      let multiplier = 1 << bits;\n      if bitsize == 1 {\n        r = quote { $r $varname: ($param_name[$bytes] & $multiplier) != 0 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u1) == 1 };\n      } else {\n        let mask = std::wrapping_sub(1 << bitsize, 1);\n        r = quote { $r $varname: (( $param_name[$bytes] / $multiplier) & $mask ) as u8 };\n        // r = quote { $r $varname: (($param_name / $multiplier) as u8) & $mask as u8 };\n      }\n    }\n    first = false;\n    r\n  });\n  // f.set_parameters(params);\n\n  // let return_type = f.return_type();\n  // // f.set_return_type(return_type.as_type());\n  // f.set_return_data();\n  // f.set_return_public(true);\n  // // println(result);\n  // f.\nresult\n  // quote {  $result } };\n}\n\n// pub global ACTION_RESULT_COORDINATES_IDX_SELF: u8 = 0; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_TARGET: u8 = 1; // u2\n// pub global ACTION_RESULT_COORDINATES_IDX_INVISIBLE: u8 = 2; // u2\n\n// global YES: u8 = 1;\n// global NO: u8 = 0;\n// global MIN_STATUS: u8 = 0;\n// global MAX_STATUS: u8 = 15;\n\n// // pub type ActionDefinitionRegister = \n// pub fn build_action_def_requirements_none() -> ActionRequirement {\n//   build_action_def_requirements(\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1,\n//     MIN_STATUS,\n//     MAX_STATUS,\n//     0 as u8,\n//     255 as u8)\n// }\n// pub fn build_action_def_pre_calc_effects_idle() -> ActionPreCalcEffect {\n//   build_action_def_pre_calc_effect(\n//     WAIT,\n//     NO as u1,\n//     NO as u1,\n//     NO as u1)\n// }\n// // comptime fn no_requirements() -> CtString {\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1, \n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         0 as u8,\n// //         NO as u1)\n// // }\n// pub fn build_action_def_result_event_none() -> ActionResultEvent {\n//   build_action_def_result_event(\n//     0,\n//     0,\n//     ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//     NO_EVENT,\n//     NO_EVENT,\n//     0 as u8\n//   )\n// }\n// // comptime fn no_event() -> CtString {\n// //     build_action_event_def(NO_EVENT, NO_EVENT, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 0 as u8)\n// // }\n// pub fn build_wait_action_def() -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements_none(),\n//     build_action_def_pre_calc_effects_idle(),\n//     build_action_def_result_effects(\n//       0 as u8,\n//       0 as u8,\n//       1 as u8,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_wait_action_def() -> CtString {\n// //     build_action_def(\n// //         no_requirements(),\n// //         no_event(),\n// //         no_event(),\n// //         1 as u8,\n// //         0 as u8,\n// //         ACTION_RESULT_COORDINATES_IDX_SELF,\n// //         NO as u1,\n// //         WAIT\n// //     )\n// // }\n// // pub global WAIT_ACTION: ActionDefinition = comptime { let x = build_wait_action_def(); f\"[{x}]\".quoted_contents() };\n// pub fn build_sneak_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0 as u8,\n//       1 as u8),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0 as u8,\n//       0 as u8,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       YES as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_sneak_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     no_event(), // TODO: not sure if on-seen we should not send a move event instead - that way one could sneak and stay hidden, but not sneak while visible\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_move_action(energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       1),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_TARGET as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_MOVE,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_move_action(energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         1 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_MOVE, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     no_event(),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_TARGET,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_cast_action(this_action_id: u8, energy: u8, class: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_CAST,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_cast_action(this_action_id: u8, energy: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_CAST, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_ritual_action(cast_action_id: u8, energy: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       RITUAL_ROUNDS_FOR_WIN,\n//       MAX_STATUS,\n//       0,\n//       255),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_INVISIBLE,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         WIN,\n//         WIN_BY_RITUAL,\n//         255),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_ritual_action(this_action_id: u8, energy: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         255 as u8,\n// //         RITUAL_ROUNDS_FOR_WIN,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 255 as u8),\n// //     build_action_event_def(WIN, WIN_BY_RITUAL, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_INVISIBLE, 255 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       cast_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         evocation_type,\n//         radius),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_evocation_action(cast_action_id: u8, energy: u8, evocation_type: u8, range: u8, radius: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1), // TODO: Maybe set this to handle friendly fire???\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     build_action_event_def(RECEIVE_ATTACK, evocation_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, radius),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     cast_action_id)\n// // }\n// pub fn build_search_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         SEE_SEARCH_TRAP,\n//         0,\n//         1),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_search_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     build_action_event_def(SEE_SEARCH_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 1 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_attack_action(energy: u8, damage_type: u8, range: u8, damage: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, 0 as u8, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS, // should be max of shoot\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       this_action_id,\n//       YES as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_SELF,\n//         SEE_DRAW,\n//         class,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_draw_action(this_action_id: u8, energy: u8, range: u8, class: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(SEE_DRAW, class, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_SELF, 0 as u8),\n// //     no_event(),\n// //     1 as u8,\n// //     1 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     this_action_id)\n// // }\n// pub fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       min_cast_time,\n//       max_cast_time,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       draw_action_id,\n//       YES as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       YES as u1),\n//     [\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event(\n//         damage,\n//         damage_upcast,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         RECEIVE_ATTACK,\n//         damage_type,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_shoot_action(draw_action_id: u8, energy: u8, damage_type: u8, range: u8, damage: u8, damage_upcast: u8, min_cast_time: u8, max_cast_time: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         range,\n// //         min_cast_time,\n// //         max_cast_time,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(RECEIVE_ATTACK, damage_type, damage_upcast, damage, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     YES as u1,\n// //     draw_action_id)\n// // }\n// pub fn build_disarm_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       YES as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       1,\n//       1,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         DISARMED_TRAP,\n//         0,\n//         0),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_disarm_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         NO as u1),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     build_action_event_def(DISARMED_TRAP, NO as u1, 0 as u8, 0 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n// pub fn build_set_trap_action(energy: u8, range: u8) -> ActionDefinition {\n//   build_action_definition(\n//     build_action_def_requirements(\n//       YES as u1,\n//       YES as u1,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1,\n//       MIN_STATUS,\n//       MAX_STATUS,\n//       0,\n//       range),\n//     build_action_def_pre_calc_effect(\n//       0,\n//       NO as u1,\n//       YES as u1,\n//       NO as u1),\n//     build_action_def_result_effects(\n//       energy,\n//       0,\n//       0,\n//       ACTION_RESULT_COORDINATES_IDX_SELF as u1,\n//       NO as u1,\n//       NO as u1),\n//     [\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event_none(),\n//       build_action_def_result_event(\n//         0,\n//         0,\n//         ACTION_RESULT_COORDINATES_IDX_TARGET,\n//         ADD_OBSTACLE,\n//         TRAP,\n//         0),\n//       build_action_def_result_event_none()\n//     ])\n// }\n// // pub comptime fn build_set_trap_action(energy: u8, range: u8) -> CtString { build_action_def(\n// //     build_action_requirements_def(\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         YES as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         NO as u1,\n// //         range,\n// //         MIN_STATUS,\n// //         MAX_STATUS,\n// //         energy,\n// //         YES as u1),\n// //     no_event(),\n// //     build_action_event_def(ADD_OBSTACLE, TRAP, 0 as u8, 50 as u8, ACTION_RESULT_COORDINATES_IDX_TARGET, 0 as u8),\n// //     0 as u8,\n// //     0 as u8,\n// //     ACTION_RESULT_COORDINATES_IDX_SELF,\n// //     NO as u1,\n// //     WAIT)\n// // }\n\n// // pub fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // fn get_action_needs_target_free_space(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// // }\n// // fn get_action_needs_target_is_not_self(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// // }\n// // fn get_action_needs_status_visible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// // }\n// // fn get_action_needs_status_invisible(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// // }\n// // fn get_action_needs_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_sets_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_removes_status_hidden(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// // }\n// // fn get_action_max_range(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_MAX_RANGE]\n// // }\n// // fn get_action_needs_min_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MIN_STATUS]\n// // }\n// // fn get_action_needs_max_status(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_MAX_STATUS]\n// // }\n// // fn get_action_needed_energy(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDED_ENERGY]\n// // }\n// // fn get_action_unseen_event_is_internal(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_EVENT_IS_TRAP] == 1\n// // }\n// // fn get_action_result_event_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_event_not_seen_type(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// // }\n// // fn get_action_result_event_not_seen_subtype(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// // }\n// // fn get_action_result_event_not_seen_value_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_event_not_seen_value_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// // }\n// // fn get_action_result_event_not_seen_coord_idx(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// // }\n// // fn get_action_result_event_not_seen_radius(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// // }\n// // fn get_action_result_status_multiplier(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// // }\n// // fn get_action_result_status_fixed_addition(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// // }\n// // fn get_action_move_to_target(action: ActionDefinition) -> u1 {\n// //     action.register[action.base_index + ACTION_MOVE_TO_TARGET] as u1\n// // }\n// // fn get_action_is_continuous(action: ActionDefinition) -> bool {\n// //     action.register[action.base_index + ACTION_IS_CONTINUOUS] == 1\n// // }\n// // fn get_action_needs_previous_action(action: ActionDefinition) -> u8 {\n// //     action.register[action.base_index + ACTION_NEEDS_PREVIOUS_ACTION] as u8\n// // }\n\n// // pub global ACTION_DEFINITION_SIZE: u32 = (ACTION_REQUIREMENTS_FIELD_COUNT + 2 * ACTION_RESULT_EVENT_FIELD_COUNT + 5) as u32; // 2 bytes for move_to_target and status_multiplier\n// // pub global ACTION_DEFINITION_REGISTER_SIZE: u32 = ACTION_DEFINITION_SIZE * (1 + (MAX_ACTIONS_PER_CHARACTER - 1) * (CLASS_COUNT - 1));\n\n// // fn get_action_base_index(actor_id: u8, action_idx: u8) -> u16 {\n// //     if (action_idx == 0) | (action_idx as u32 >= MAX_ACTIONS_PER_CHARACTER) | (actor_id as u32 >= MAX_CHARACTERS) {\n// //         0 as u16\n// //     } else {\n// //         (actor_id as u16 * (MAX_ACTIONS_PER_CHARACTER - 1) as u16 + action_idx as u16) * ACTION_DEFINITION_SIZE as u16\n// //     }\n// // }\n\n// // pub struct ActionDefinitionRegister {\n// //   register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinitionRegister {\n// //   pub fn new(register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinitionRegister {\n// //     ActionDefinitionRegister {\n// //       register: register\n// //     }\n// //   }\n\n// //   pub fn resolve_action(self, action: Action) -> ActionDefinition {\n// //     ActionDefinition {\n// //       base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //       action: action,\n// //       register: self.register\n// //     }\n// //   }\n// // }\n\n// // pub struct ActionDefinition {\n// //     base_index: u16,\n// //     action: Action,\n// //     register: [u8; ACTION_DEFINITION_REGISTER_SIZE]\n// // }\n\n// // impl ActionDefinition {\n// //     pub fn new(action: Action, register: [u8; ACTION_DEFINITION_REGISTER_SIZE]) -> ActionDefinition {\n// //         ActionDefinition {\n// //             base_index: get_action_base_index(get_action_actor(action), get_action_type(action)),\n// //             action: action,\n// //             register: register\n// //         }\n// //     }\n// // }\n\n// // impl ResolvedAction for ActionDefinition {\n// //     fn get_action_needs_target_free_space(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: ActionDefinition) -> u1 {\n// //         self.register[self.base_index + ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: ActionDefinition) -> bool {\n// //         self.register[self.base_index + ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: ActionDefinition) -> u8 {\n// //         self.register[self.base_index + ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n\n// // pub struct TestActionDefinition {\n// //     pub register: [u8; ACTION_DEFINITION_SIZE],\n// //     pub action: Action,\n// // }\n\n// // impl ResolvedAction for TestActionDefinition {\n// //     fn get_action_needs_target_free_space(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_FREE_SPACE] == 1\n// //     }\n// //     fn get_action_needs_target_is_not_self(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_TARGET_IS_NOT_SELF] == 1\n// //     }\n// //     fn get_action_needs_status_visible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_VISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_invisible(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_INVISIBLE] == 1\n// //     }\n// //     fn get_action_needs_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_NEEDS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_sets_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_SETS_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_removes_status_hidden(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_REMOVES_STATUS_HIDDEN] == 1\n// //     }\n// //     fn get_action_max_range(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_MAX_RANGE]\n// //     }\n// //     fn get_action_needs_min_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MIN_STATUS]\n// //     }\n// //     fn get_action_needs_max_status(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_MAX_STATUS]\n// //     }\n// //     fn get_action_needed_energy(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDED_ENERGY]\n// //     }\n// //     fn get_action_unseen_event_is_internal(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_EVENT_IS_TRAP] == 1\n// //     }\n// //     fn get_action_result_event_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_event_not_seen_type(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_TYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_subtype(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_SUBTYPE]\n// //     }\n// //     fn get_action_result_event_not_seen_value_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_event_not_seen_value_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_VALUE_FIXED_ADDITION]\n// //     }\n// //     fn get_action_result_event_not_seen_coord_idx(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_COORD_IDX]\n// //     }\n// //     fn get_action_result_event_not_seen_radius(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_EVENT_NOT_SEEN_RADIUS]\n// //     }\n// //     fn get_action_result_status_multiplier(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_MULTIPLIER]\n// //     }\n// //     fn get_action_result_status_fixed_addition(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_RESULT_STATUS_FIXED_ADDITION]\n// //     }\n// //     fn get_action_move_to_target(self: TestActionDefinition) -> u1 {\n// //         self.register[ACTION_MOVE_TO_TARGET] as u1\n// //     }\n// //     fn get_action_is_continuous(self: TestActionDefinition) -> bool {\n// //         self.register[ACTION_IS_CONTINUOUS] == 1\n// //     }\n// //     fn get_action_needs_previous_action(self: TestActionDefinition) -> u8 {\n// //         self.register[ACTION_NEEDS_PREVIOUS_ACTION]\n// //     }\n\n// //     fn get_action_target_x(self) -> u8 {\n// //         get_action_target_x(self.action)\n// //     }\n// //     fn get_action_target_y(self) -> u8 {\n// //         get_action_target_y(self.action)\n// //     }\n// //     fn get_action_type(self) -> u8 {\n// //         get_action_type(self.action)\n// //     }\n// // }\n\n// // #[test]\n// // fn test_execute_action() {\n// //     let action = build_test_action_def!(build_move_action(4), quote { 1, 2, 3, 4 }); //new_action(1, 2, 3, 4);\n// //     let my_advance = 10;\n// //     let their_advance = 1;\n// //     let actor = Character {\n// //         id: 2,\n// //         x: 2,\n// //         y: 4,\n// //         target_x: 0,\n// //         target_y: 0,\n// //         health: 255,\n// //         damage_mod: 1,\n// //         last_action: WAIT,\n// //         class: MAGE,\n// //         is_hidden: 0 as u1,\n// //         has_been_seen: true,\n// //         status: 0,\n// //         actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]\n// //     };\n// //     let energy = 15;\n// //     let my_obstacles = get_default_obstacles(0);\n// //     let their_obstacles = get_default_obstacles(1);\n// //     let (valid, event, internal_event, c, result_energy) = execute_action(\n// //         action,\n// //         my_advance,\n// //         their_advance,\n// //         actor,\n// //         energy,\n// //         my_obstacles,\n// //         their_obstacles\n// //     );\n// //     assert(valid, \"valid\");\n// //     assert(event.actor_id == actor.id, f\"{event}.actorid is not {actor}.id\");\n// //     assert(event.event == SEE_MOVE, f\"{event} is not {SEE_MOVE}\");\n// //     assert(event.x == action.get_action_target_x(), f\"{event}.target_x is not action target x\");\n// //     assert(event.y == action.get_action_target_y(), f\"{event}.target_y is not action target y\");\n// //     assert(c.x == event.x, f\"{c}.x is not action target x\");\n// //     assert(internal_event.event == NO_EVENT, f\"expected no internal event, got {internal_event}\");\n// //     assert(result_energy == 11, f\"{result_energy} != 11\");\n// // }\n\n// // #[export]\n// // pub fn build_action_register(actions: [])\n\npub type CharacterActionDefinition = [u8; 32];\npub type CharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [CharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedCharacterActionDefinition = Field;\npub type SerializedCharacterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER];\npub type SerializedRosterActionDefinitions<let MAX_ACTIONS_PER_CHARACTER: u32, let MAX_CHARACTERS: u32> = [SerializedCharacterActionDefinition; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS];","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionDefinition.nr"},"91":{"source":"// pub type ActionResultEffects = (bool, bool, bool, bool);\n// pub comptime fn to_action_result_effect(set_hidden: bool, remove_hidden: bool, move_to_target: bool, continuous: bool) -> Quoted {\n//     quote { ($set_hidden, $remove_hidden, $move_to_target, $continuous ) }\n// }\n\n// pub comptime fn get_sets_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_removes_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_move_to_target_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_is_continuous_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse crate::actionRequirements::{get_action_def_requirements_base_index, get_action_def_requirements_byte_size};\nuse std::append::Append;\n\n\npub type ActionDefDefPreCalcEffect = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefPreCalcEffect> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_PRE_CALC_EFFECTS: [DEF_ROW<ActionDefDefPreCalcEffect>] = [\n    action_def_def(quote { pre_calc_effect_continues_action }, 3, |continued_action|quote { let continues_action: bool = $continued_action as u8 == actor_last_action; }),\n    action_def_def(quote { pre_calc_effect_is_continuous }, 1, |is_continuous|quote { let is_continuous: bool = $is_continuous as bool; }),\n    action_def_def(quote { pre_calc_effect_interrupts }, 1, |is_interrupting|quote { let is_interrupting: bool = $is_interrupting as bool; }),\n    action_def_def(quote { pre_calc_effect_allow_retargeting }, 1, |allows_retargetting|quote { let not_interrupted_through_retargeting: bool = $allows_retargetting as bool | ((action_target_x == actor_target_x) & (action_target_y == actor_target_y)); })\n];\npub comptime fn get_action_def_pre_calc_base_index() -> u32 {\n  get_action_def_requirements_byte_size()+get_action_def_requirements_base_index()\n}\n\npub comptime fn get_action_def_pre_calc_effects_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_PRE_CALC_EFFECTS)\n}\n\ncomptime fn derive_action_def_def_pre_calc_event_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n// }\n#[derive_action_def_def_pre_calc_event_struct]\npub struct ActionPreCalcEffect {\n  pub register: [u8; 32]\n}\nimpl ActionPreCalcEffect {\n  #[derive_action_def_pre_calc_effect_struct_new]\n  pub fn new() -> ActionPreCalcEffect {\n    ActionPreCalcEffect { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_pre_calc_effect_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n#[export]\n#[derive_action_def_def_pre_calc_effect_builder]\npub fn build_action_def_pre_calc_effect() -> pub ActionPreCalcEffect { ActionPreCalcEffect::new() }\n\npub comptime fn apply_action_pre_calc_effects(register: Quoted) -> Quoted {\n  let base_index = get_action_def_pre_calc_base_index();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_PRE_CALC_EFFECTS, base_index, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n  quote {\n    $result\n    is_not_interrupted = (\n      ((!is_continuous) as u8 * (!is_interrupting) as u8) + // that's the ID of the wait action => leave status, but not continuous\n      ((is_continuous) as u8 * continues_action as u8 * not_interrupted_through_retargeting as u8)\n    ) > 0;\n\n    actor_progress *= is_not_interrupted as u8;\n  }\n}\n\npub comptime fn set_action_def_pre_calc_effects_in_action_def(effects: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_pre_calc_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_pre_calc_effects_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $effects.register[$i]; });\n    // result = quote { $result $action_def += $effects.register[$i] as Field * $multiplier; };\n    // multiplier *= 2;\n  }\n  result\n}\n\ncomptime fn derive_frontend_action_def_pre_calc_effects_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n}\n#[derive_frontend_action_def_pre_calc_effects_struct]\n#[derive(Default)]\npub struct FrontendActionDefPreCalcEffects {}\n\n\npub comptime fn derive_frontend_action_def_pre_calc_effects_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_pre_calc_base_index(), ACTION_DEF_DEF_PRE_CALC_EFFECTS);\n  quote { FrontendActionDefPreCalcEffects { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionPreCalcEffect.nr"},"92":{"source":"use skplg::{UNREADABLE_BYTES_PER_FIELD, softassert};\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse std::append::Append;\nuse crate::{actionDefinition::derive_frontend_action_def_struct, actionDefinition::derive_frontend_action_def_struct_builder};\n\n    // fn get_action_req_target_free_space(self) -> bool;\n    // fn get_action_req_target_is_not_self(self) -> bool;\n    // fn get_action_req_status_visible(self) -> bool;\n    // fn get_action_req_status_invisible(self) -> bool;\n    // fn get_action_req_status_hidden(self) -> bool;\n    // fn get_action_req_max_range(self) -> u8;\n    // fn get_action_req_min_status(self) -> u8;\n    // fn get_action_req_max_status(self) -> u8;\n    // fn get_action_req_energy(self) -> u8;\n    // fn get_action_req_previous_action(self) -> u8;\npub type ActionDefDefRequirementCheck = (Quoted, Quoted);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, expr: Quoted, msg: Quoted) -> DEF_ROW<ActionDefDefRequirementCheck> {\n    (varname, bit_size, (expr, msg))\n}\n// comptime global ACTION_DEF_DEF_FIELD_COUNT: u32 = 11;\nglobal ACTION_DEF_DEF_REQUIREMENTS: [DEF_ROW<ActionDefDefRequirementCheck>] = [\n    action_def_def(quote { action_req_target_free_space }, 1, quote { could_move_to_target }, quote { f\"Target space cannot be moved to {action_target_x},{action_target_y}) cannot be moved to: {VIEW_DISTANCE},{my_obstacles},{their_obstacles}\" }),\n    action_def_def(quote { action_req_target_is_not_self }, 1, quote { (actor_x != action_target_x) | (actor_y != action_target_y) }, quote { f\"Target cannot be self ({action_target_x},{action_target_y})\" }),\n    action_def_def(quote { action_req_status_visible }, 1, quote { actor_is_in_view_range & !actor_is_hidden },  quote { f\"Character must be fully visible for action {action_type}: in_view_range: {actor_is_in_view_range} & !hidden {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_invisible }, 1, quote { !actor_is_in_view_range | actor_is_hidden }, quote { f\"Character must not be visible to perform action {action_type}: !in_view_range: {actor_is_in_view_range} || hidden: {actor_is_hidden} for enemy_advance {enemy_advance} @ {actor_x}\" }),\n    action_def_def(quote { action_req_status_hidden }, 1, quote { actor_is_hidden }, quote { f\"Character needs to be hidden to perform action {action_type}\" }),\n    // action_def_def(quote { action_req_previous_action }, 3, quote { true }, quote { f\"\" }),\n    action_def_def(quote { action_req_min_progress }, 4, quote { action_req_min_progress as u8 <= actor_progress as u8 }, quote { f\"Character needs min progress {action_req_min_progress} to perform action {action_type}, but only has {actor_progress}\" }),\n    action_def_def(quote { action_req_max_progress }, 4, quote { action_req_max_progress as u8 >= actor_progress as u8 }, quote { f\"Character cannot have a higher progress than {action_req_max_progress} to perform action {action_type}: got {actor_progress}\" }),\n    action_def_def(quote { action_req_status }, 4, quote { (action_req_status as u8 == 0 as u8) | (action_req_status as u8 == actor_progress as u8) }, quote { f\"Character can only perform action {action_type} while having status {action_req_status}. Invalid status {actor_status}\" }),\n    // action_def_def(quote { action_req_required_energy }, 4, quote { action_req_required_energy <= energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_req_required_energy}\" }),\n    action_def_def(quote { action_req_max_range }, 8, quote { distance as u16 <= (action_req_max_range as u16) * (action_req_max_range as u16) }, quote { f\"Character is out of range! Distance: {distance} > {action_req_max_range}: {{{actor_x},{actor_y}}} - {{{action_target_x},{action_target_y}}} with {action_req_max_range}\" }),\n];\npub comptime fn get_action_def_requirements_base_index() -> u32 {\n  UNREADABLE_BYTES_PER_FIELD as u32\n}\n\npub comptime fn get_action_def_requirements_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_REQUIREMENTS)\n}\n\ncomptime fn derive_action_def_def_req_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n// comptime fn derive_action_def_requirements_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_REQUIREMENTS);\n// }\n\n#[derive_action_def_def_req_struct]\npub struct ActionRequirement {\n  pub register: [u8; 32]\n}\nimpl ActionRequirement {\n  #[derive_action_def_requirements_struct_new()]\n  pub fn new() -> ActionRequirement {\n    ActionRequirement { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_req_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[export]\n#[derive_action_def_def_req_builder]\npub fn build_action_def_requirements() -> pub ActionRequirement { ActionRequirement::new() }\n\npub comptime fn validate_action_requirements(valid_varname: Quoted, register: Quoted) -> Quoted {\n  let mut result = build_over_def_array(ACTION_DEF_DEF_REQUIREMENTS, get_action_def_requirements_base_index(), |bytes, bits, varname, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    // let varname = f\"action_requirement_{i}_is_valid\".quoted_contents();\n    let (checkexpr, msg) = args;\n    let check = if bitsize == 1 { quote { !($varname as bool) | ($checkexpr) } } else { quote { $checkexpr } };\n    let sa = softassert(valid_varname, check, msg);\n    quote {\n      let $varname = $expr;\n      $sa\n    }\n  });\n  // println(result);\n  // quote { assert(1==1); }\n  result\n}\n\npub comptime fn set_action_def_requirements_in_action_def(requirements: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_requirements_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_requirements_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $requirements.register[$i]; });\n    // result = quote { $result $action_def += $requirements.register[$i] as Field * $multiplier; };\n    // multiplier *= 2.pow_32(8);\n  }\n  // println(result);\n  result\n}\n\ncomptime fn derive_frontend_action_def_requirements_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_REQUIREMENTS);\n}\n#[derive_frontend_action_def_requirements_struct]\n#[derive(Default)]\npub struct FrontendActionDefRequirements {}\n\n\npub comptime fn derive_frontend_action_def_requirements_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_requirements_base_index(), ACTION_DEF_DEF_REQUIREMENTS);\n  // println(content);\n  quote { FrontendActionDefRequirements { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionRequirements.nr"},"93":{"source":"// pub type ActionResultEffects = (bool, bool, bool, bool);\n// pub comptime fn to_action_result_effect(set_hidden: bool, remove_hidden: bool, move_to_target: bool, continuous: bool) -> Quoted {\n//     quote { ($set_hidden, $remove_hidden, $move_to_target, $continuous ) }\n// }\n\n// pub comptime fn get_sets_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_removes_status_hidden_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_move_to_target_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_is_continuous_of_action_result_effect(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse skplg::softassert;\nuse crate::actionPreCalcEffect::{get_action_def_pre_calc_base_index, get_action_def_pre_calc_effects_byte_size};\nuse std::append::Append;\n\npub type ActionDefDefPreCalcEffect = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefPreCalcEffect> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_RESULT_EFFECTS: [DEF_ROW<ActionDefDefPreCalcEffect>] = [\n    action_def_def(quote { action_result_required_energy }, 4, |action_required_energy|{\n      let check = softassert(quote { is_valid }, quote { action_required_energy <= result_energy }, quote { f\"Character has insufficient energy left to perform action {action_type}: {energy} < {action_required_energy}\" });\n      quote {\n        let action_required_energy = $action_required_energy;\n        $check\n        result_energy = std::wrapping_sub(result_energy, action_required_energy);\n      }\n    }),\n    action_def_def(quote { action_result_progress_increment }, 4, |progress_increment|quote { let action_result_effect_progress_increment: u32 = $progress_increment as u32; }),\n    action_def_def(quote { action_result_progress_multiplier }, 2, |progress_multiplier|quote { let action_result_effect_progress_multiplier: u32 = $progress_multiplier as u32; }),\n    action_def_def(quote { action_result_move_to_target }, 1, |move_to_target|quote { result_coords = coords[$move_to_target as u8]; }),\n    action_def_def(quote { action_result_hide }, 1, |hide|quote { let action_result_effect_hide: bool = $hide as bool; }),\n    action_def_def(quote { action_result_reveal }, 1, |leave_shadows|quote { let action_result_effect_leave_shadows: bool = $leave_shadows as bool; })\n];\npub comptime fn get_action_def_result_effect_base_index() -> u32 {\n  get_action_def_pre_calc_base_index() + get_action_def_pre_calc_effects_byte_size()\n}\n\npub comptime fn get_action_def_result_effects_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_RESULT_EFFECTS)\n}\n\ncomptime fn derive_action_def_def_result_effect_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n// }\n#[derive_action_def_def_result_effect_struct]\npub struct ActionResultEffect {\n  pub register: [u8; 32]\n}\nimpl ActionResultEffect {\n  //#[derive_action_def_result_effects_struct_new]\n  pub fn new() -> ActionResultEffect {\n    ActionResultEffect { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_result_effects_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[export]\n#[derive_action_def_def_result_effects_builder]\npub fn build_action_def_result_effects() -> pub ActionResultEffect { ActionResultEffect::new() }\n\npub comptime fn apply_action_result_effects(register: Quoted) -> Quoted {\n  let base_index = get_action_def_result_effect_base_index();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_RESULT_EFFECTS, base_index, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n// println(result);\n  quote {\n    $result\n\n    let result_progress_raw = actor_progress as u32 * action_result_effect_progress_multiplier + action_result_effect_progress_increment;\n    //softassert!(quote { is_valid }, quote { result_progress_raw <= MAX_PROGRESS as u32 }, quote { f\"Invalid result progress: {result_progress_raw} > {MAX_PROGRESS}\" });\n    result_progress = result_progress_raw as u8;\n\n    result_is_hidden = (result_is_hidden & !action_result_effect_leave_shadows) | action_result_effect_hide;\n    result_is_visible = !result_is_hidden & is_visible(enemy_advance, result_coords.0);\n  }\n}\n\npub comptime fn set_action_def_result_effects_in_action_def(effects: Quoted, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let base_index = get_action_def_result_effect_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  for i in 0..get_action_def_result_effects_byte_size() {\n    result = result.append(quote { $action_def[$base_index + $i] = $effects.register[$i]; });\n    // result = quote { $result $action_def += $effects.register[$i] as Field * $multiplier; };\n    // multiplier *= 2;\n  }\n  result\n}\n\ncomptime fn derive_frontend_action_def_result_effects_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_RESULT_EFFECTS);\n}\n#[derive_frontend_action_def_result_effects_struct]\n#[derive(Default)]\npub struct FrontendActionDefResultEffects {}\n\n\npub comptime fn derive_frontend_action_def_result_effects_struct_builder(param_name: Quoted) -> Quoted {\n  let content = derive_frontend_action_def_struct_builder(param_name, get_action_def_result_effect_base_index(), ACTION_DEF_DEF_RESULT_EFFECTS);\n  quote { FrontendActionDefResultEffects { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionResultEffect.nr"},"94":{"source":"// pub global ACTION_RESULT_EVENT_TYPE: u8 = 0;\n// pub global ACTION_RESULT_EVENT_SUBTYPE: u8 = 1;\n// pub global ACTION_RESULT_EVENT_VALUE_MULTIPLIER: u8 = 2;\n// pub global ACTION_RESULT_EVENT_VALUE_FIXED_ADDITION: u8 = 3;\n// pub global ACTION_RESULT_EVENT_COORD_IDX: u8 = 4;\n// pub global ACTION_RESULT_EVENT_RADIUS: u8 = 5;\n// pub comptime fn to_action_result_event(event_type: Quoted, subtype: Quoted, val_mul: Quoted, val_add: Quoted, coord_idx: Quoted, radius: Quoted) -> Quoted {\n//     quote { ($event_type, $subtype, $val_mul, $val_add, $coord_idx, $radius)}\n// }\n// pub comptime fn get_type_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.0 }\n// }\n// pub comptime fn get_subtype_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.1 }\n// }\n// pub comptime fn get_value_multiplier_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.2 }\n// }\n// pub comptime fn get_value_addition_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.3 }\n// }\n// pub comptime fn get_coord_idx_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.4 }\n// }\n// pub comptime fn get_radius_of_action_result_event_type(varname: Quoted) -> Quoted {\n//     quote { $varname.5 }\n// }\n// pub type ActionResultEventDefinition = (u8, u8, u8, u8, u8, u8);\n\nuse skplg::{softassert};\nuse crate::actionDefinition::{DEF_ROW, build_over_def_array, derive_action_def_def_struct, derive_action_def_def_builder, get_def_register_value, get_action_def_def_register_size};\nuse crate::actionDefinition::{derive_frontend_action_def_struct, derive_frontend_action_def_struct_builder};\nuse crate::actionResultEffect::{get_action_def_result_effect_base_index, get_action_def_result_effects_byte_size};\n\npub type ActionDefDefResultEventRow = (fn (Quoted) -> Quoted,);\ncomptime fn action_def_def(varname: Quoted, bit_size: u8, handler: fn (Quoted) -> Quoted) -> DEF_ROW<ActionDefDefResultEventRow> {\n    (varname, bit_size, (handler,))\n}\nglobal ACTION_DEF_DEF_RESULT_EVENTS: [DEF_ROW<ActionDefDefResultEventRow>] = [\n    action_def_def(quote { result_event_value_fixed_addition }, 8, |fixed_addition|quote { result_event_value += $fixed_addition as u32; }),\n    action_def_def(quote { result_event_value_scaled_by_progress }, 4, |factor|quote { result_event_value += ($factor as u32) * (actor_progress as u32); }),\n    action_def_def(quote { result_event_coords_idx }, 2, |coords_idx|{\n     let check = softassert(quote { is_valid }, quote { $coords_idx < 3 }, quote { f\"Invalid event coord idx: {result_event_coords_idx} does not fit in u8!\" });\n      quote {\n        let result_event_coords_idx: u8 = $coords_idx;\n        $check\n        result_event_coords = coords[result_event_coords_idx & 3];\n      }\n    }),\n    action_def_def(quote { result_event_type }, 4, |event_type|quote { result_event_type = $event_type; }),\n    action_def_def(quote { result_event_subtype }, 8, |event_subtype|quote { result_event_subtype = $event_subtype; }),\n    action_def_def(quote { result_event_radius }, 6, |event_radius|quote { result_event_radius = $event_radius; })\n];\ncomptime fn get_action_def_result_event_base_index() -> u32 {\n  get_action_def_result_effect_base_index() + get_action_def_result_effects_byte_size()\n}\n\npub comptime fn get_action_def_result_event_byte_size() -> u32 {\n  get_action_def_def_register_size(ACTION_DEF_DEF_RESULT_EVENTS)\n}\n\n\ncomptime fn derive_action_def_def_result_event_struct(s: StructDefinition) {\n  derive_action_def_def_struct(s, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n// comptime fn derive_action_def_result_event_struct_new(f: FunctionDefinition) {\n//   derive_action_def_def_struct_new(f, ACTION_DEF_DEF_RESULT_EVENTS);\n// }\n#[derive_action_def_def_result_event_struct]\npub struct ActionResultEvent {\n  pub register: [u8; 32]\n}\nimpl ActionResultEvent {\n  #[derive_action_def_result_event_struct_new]\n  pub fn new() -> ActionResultEvent {\n    ActionResultEvent { register: &[].as_array() }\n  }\n}\n\ncomptime fn derive_action_def_def_result_event_builder(f: FunctionDefinition) {\n  derive_action_def_def_builder(f, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n#[export]\n#[derive_action_def_def_result_event_builder]\npub fn build_action_def_result_event() -> pub ActionResultEvent { ActionResultEvent::new() }\n\npub comptime fn build_result_event(event_idx: u32, events_collection_varname: Quoted, valid_varname: Quoted, register: Quoted) -> Quoted {\n  let base_index = get_action_def_result_event_base_index();\n  let event_data_start_idx = base_index + event_idx * get_action_def_result_event_byte_size();\n  let mut result = build_over_def_array(ACTION_DEF_DEF_RESULT_EVENTS, event_data_start_idx, |bytes, bits, _, bitsize, args|{\n    let expr = get_def_register_value(register, bytes, bits, bitsize);\n    \n    //let varname = f\"${varname}${event_idx}\".quoted_contents();\n    // let (checkexpr, msg) = args;\n    let (handler) = args;\n    \n    handler(expr)\n  });\n\n  //let value_valid_msg = f\"Invalid event value ({event_idx}): result_event_value does not fit in u8!\";\n  // let value_valid = softassert(valid_varname, quote { result_event_value <= 255 as u32 }, quote { f\"Invalid event value ({event_idx}): result_event_value does not fit in u8!\" });\n  let full_result = quote {\n    let event_idx = $event_idx as u8;\n    let mut result_event_type: u8 = 0;\n    let mut result_event_subtype: u8 = 0;\n    let mut result_event_coords: (u8,u8) = (NOWHERE, NOWHERE);\n    let mut result_event_value: u32 = 0;\n    let mut result_event_radius: u8 = 0;\n    $result\n    // $value_valid\n    if (result_event_value > 255) {\n      result_event_value = 255;\n    }\n\n    $events_collection_varname.push(build_subtype_value_event(\n      result_event_type,\n      actor_id,\n      result_event_coords.0,\n      result_event_coords.1,\n      result_event_value as u8,\n      result_event_subtype,\n      result_event_radius\n    ));\n  };\n  // println(full_result);\n  full_result\n}\n\npub comptime fn set_action_def_result_event_in_action_def(event: Quoted, event_count: u32, action_def: Quoted) -> Quoted {\n  let mut result = quote {};\n  let mut base_index = get_action_def_result_event_base_index();\n  // let mut multiplier = 2.pow_32(base_index as Field * 8);\n  // println(\"start\");\n  for event_idx in 0..event_count {\n    let idx = event_idx * get_action_def_result_event_byte_size();\n    for i in 0..get_action_def_result_event_byte_size() {\n      let destination_idx = base_index + idx + i;\n      result = quote { $result $action_def[$destination_idx] = $event[$event_idx].register[$i]; };\n      // result = quote { $result $action_def += $event[$event_idx].register[$i] as Field * $multiplier; };\n      // multiplier *= 2;\n    }\n  }\n  //println(result);\n  result\n}\n\ncomptime fn derive_frontend_action_def_result_event_struct(s: StructDefinition) {\n  derive_frontend_action_def_struct(s, ACTION_DEF_DEF_RESULT_EVENTS);\n}\n#[derive_frontend_action_def_result_event_struct]\n#[derive(Default)]\npub struct FrontendActionDefResultEvent {}\n\n\npub comptime fn derive_frontend_action_def_result_event_struct_builder(param_name: Quoted, event_idx: u32) -> Quoted {\n  let idx = get_action_def_result_event_base_index() + event_idx * get_action_def_result_event_byte_size();\n  let content = derive_frontend_action_def_struct_builder(param_name, idx, ACTION_DEF_DEF_RESULT_EVENTS);\n  quote { FrontendActionDefResultEvent { $content } }\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplam/src/actionResultEvent.nr"}},"names":["calculate_action"],"brillig_names":["directive_integer_quotient","directive_invert"]}