{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4439316767201492109,"abi":{"parameters":[{"name":"serialized_obstacles","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"array","length":29,"type":{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"76":{"source":"use arenalib::{ WIDTH, HEIGHT, WIDTH_MASK, VIEW_DISTANCE, MAX_OBSTACLES, MAX_ENEMY_OBSTACLES };\nuse crate::obstacle::{ Obstacle, get_obstacle_y, get_obstacle_x, is_obstacle_traversible };\nuse skplg::NOWHERE;\nuse std::collections::bounded_vec;\n\n// pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> bool {\n//     // assert(curr_x < WIDTH);\n//     // assert(curr_y < HEIGHT);\n//     // assert(x < WIDTH);\n//     // assert(y < HEIGHT);\n//     // validating coordinates is not the job of this function\n//     // only avoid overflows!\n\n\n//     let shifted_curr_x = std::wrapping_add(curr_x, 1);\n//     let shifted_curr_y = std::wrapping_add(curr_y, 1);\n//     let shifted_x = std::wrapping_add(x, 1);\n//     let shifted_y = std::wrapping_add(y, 1);\n\n//     ((shifted_curr_x == shifted_x) & (std::wrapping_add(shifted_curr_y, 1) >= shifted_y) & (shifted_curr_y <= std::wrapping_add(shifted_y, 1))) |\n//     ((shifted_curr_y == shifted_y) & (std::wrapping_add(shifted_curr_x, 1) >= shifted_x) & (shifted_curr_x <= std::wrapping_add(shifted_x, 1)))\n// }\n\n// global DISTANCE_TABLE_HEIGHT: u32 = HEIGHT as u32;\n// global DISTANCE_TABLE_WIDTH: u32 = WIDTH as u32;\n\n// unconstrained fn distance_sqrt(x: u32) -> u32 {\n//     let mut result: u32 = 0;\n//     for i in 0..DISTANCE_TABLE_WIDTH {\n//         if i * i == x {\n//             result = i;\n//             break;\n//         }\n//     }\n//     result\n// }\n\n// fn d(a: u8, b: u8) -> u8 {\n//     let d = a as i32 - b as i32;\n//     let d2 = d * d;\n//     assert(d2 >= 0);\n//     let d2u = d2 as u32;\n//     let result = unsafe {\n//         let sq = distance_sqrt(d2u);\n//         assert(sq * sq == d2u);\n//         sq\n//     };\n//     assert(result < DISTANCE_TABLE_WIDTH);\n//     comptime { assert(DISTANCE_TABLE_WIDTH <= 256) };\n//     result as u8\n// }\n// global DISTANCE_TABLE: [[u8; DISTANCE_TABLE_WIDTH]; DISTANCE_TABLE_HEIGHT] = [\n//     [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n//     [ 2,  2,  3,  4,  5,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ],\n//     [ 3,  3,  3,  4,  4,  5,  6,  7,  8,  9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20 ,21 ,22 ,23 ,24 ,25 ,26 ,27 ,28 ,29 ],\n// ]\n\nglobal MAX_DISTANCE: u32 = 0xff * 0xff;\npub type DISTANCE = u16;\nfn get_distance_part(curr: u8, target: u8) -> DISTANCE_PART_ROLLED_OUT {\n  let d = if curr > target { curr - target } else { target - curr } as u32;\n  d * d\n}\npub fn get_distance(curr_x: u8, curr_y: u8, x: u8, y: u8) -> DISTANCE {\n    // assert(curr_x < WIDTH);\n    // assert(curr_y < HEIGHT);\n    // assert(x < WIDTH);\n    // assert(y < HEIGHT);\n    // validating coordinates is not the job of this function\n    // only avoid overflows!\n\n    // let dx = unsafe {\n    //     let diff_\n    //     distance_sqrt(x)\n    // }\n\n    let dx = get_distance_part(curr_x, x);\n    let dy = get_distance_part(curr_y, y);\n\n    // let dx = curr_x as i16 - x as i16;\n    // let dy = curr_y as i16 - y as i16;\n  get_distance_from_parts(dx, dy)\n}\n// NOTE: Leaving it for now, but no actual performance benefit from splitting this\npub type DISTANCE_PART_ROLLED_OUT = u32;\nfn get_distance_from_parts(x: DISTANCE_PART_ROLLED_OUT, y: DISTANCE_PART_ROLLED_OUT) -> DISTANCE {\n  let distance = x + y;\n  if distance > MAX_DISTANCE {\n    MAX_DISTANCE as u16\n  } else {\n    distance as u16\n  }\n}\n\n\npub fn is_visible(enemy_advance: u8, x: u8) -> bool {\n    //(x >= enemy_advance) == (side == 0)\n    x >= enemy_advance\n}\n\n// TODO: This is for the future - fireballs, etc. only if we have line of sight\n// pub fn is_visible(curr_x: u8, curr_y: u8, x: u8, y: u8, map: &Map) -> bool {\n//     assert(curr_x < WIDTH);\n//     assert(curr_y < HEIGHT);\n//     assert(x < WIDTH);\n//     assert(y < HEIGHT);\n\n//     let mut x = curr_x as f32;\n//     let mut y = curr_y as f32;\n//     let x2 = x + 0.5;\n//     let y2 = y + 0.5;\n//     let dx = x2 - x;\n//     let dy = y2 - y;\n//     let mut t = 0.0;\n//     let mut max_t = 1.0;\n//     let mut x = x;\n//     let mut y = y;\n\n//     while t < max_t {\n//         let x = x + dx * t;\n//         let y = y + dy * t;\n//         let x = x as u8;\n//         let y = y as u8;\n\n//         if map.is_wall(x, y) {\n//             return false;\n//         }\n\n//         t += 0.1;\n//     }\n\n//     true\n// }\n\npub fn their_x_to_mine(x: u8) -> (bool, u8) {\n    if x == NOWHERE {\n        (true, NOWHERE)\n    } else {\n        (x < WIDTH, std::wrapping_sub(WIDTH - 1, x) & WIDTH_MASK)\n    }\n}\n\npub fn is_distance_within_viewing_range(distance: u16) -> bool {\n  distance <= (VIEW_DISTANCE as u16 * VIEW_DISTANCE as u16)\n}\n\npub fn is_tile_free_or_invisible(x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n  let mut can = true;\n  for i in 0..MAX_OBSTACLES {\n      if !is_obstacle_traversible(obstacles[i]) & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n      if !is_obstacle_traversible(their_obstacles[i]) & (get_obstacle_x(their_obstacles[i]) == x) & (get_obstacle_y(their_obstacles[i]) == y) {\n          can = false;\n      }\n  }\n  can\n}\n\nglobal W: u32 = WIDTH as u32;\nglobal H: u32 = HEIGHT as u32;\nunconstrained fn _get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] {\n  let mut map = [[0; H]; W];\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n    if (x != NOWHERE) & (y != NOWHERE) {\n      assert(x < WIDTH);\n      assert(y < HEIGHT);\n      if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n        map[x][y] += 1;\n      }\n    }\n  }\n  map\n}\n\nunconstrained fn _to_obstacle_collision_array(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [(u8, u8, bool); MAX_ENEMY_OBSTACLES * 2] {\n  let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i] = (x,y,is_obstacle_traversible(obstacle));\n\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    let obstacle = their_obstacles[i];\n    let x = get_obstacle_x(obstacle);\n    let y = get_obstacle_y(obstacle);\n\n    o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n    // if (x != NOWHERE) & (y != NOWHERE) {\n    //   assert(x < WIDTH);\n    //   assert(y < HEIGHT);\n    //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n    //     o.push((x,y));\n    //   }\n    // }\n  }\n  o\n}\n\npub fn get_free_map(obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> [[u8; H]; W] { // missing own chars\n  // Safety: verifying all map elements afterwards\n  let map = unsafe { _get_free_map(obstacles, their_obstacles) };\n  \n  // Safety: verifying all below\n  //let o = unsafe { _to_obstacle_collision_array(obstacles, their_obstacles) };\n   //let mut o = [(NOWHERE, NOWHERE, true); 58];\n\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n\n          if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //o[i] = (x,y,is_obstacle_traversible(obstacle));\n          // assert(o[i].0 == x);\n          // assert(o[i].1 == y);\n          // assert(o[i].2 == is_obstacle_traversible(obstacle));\n\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        for i in 0..MAX_ENEMY_OBSTACLES {\n          let obstacle = their_obstacles[i];\n          let x = get_obstacle_x(obstacle);\n          let y = get_obstacle_y(obstacle);\n if !is_obstacle_traversible(obstacle) {\n            assert(map[x][y] > 0);\n          }\n          //  o[i + MAX_ENEMY_OBSTACLES] = (x,y,is_obstacle_traversible(obstacle));\n\n          // assert(o[i + MAX_ENEMY_OBSTACLES].0 == x);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].1 == y);\n          // assert(o[i + MAX_ENEMY_OBSTACLES].2 == is_obstacle_traversible(obstacle));\n          // if (x != NOWHERE) & (y != NOWHERE) {\n          //   assert(x < WIDTH);\n          //   assert(y < HEIGHT);\n          //   if !is_obstacle_traversible(obstacle) {//} & (get_obstacle_x(obstacles[i]) == x) & (get_obstacle_y(obstacles[i]) == y) {\n          //     o.push((x,y));\n          //   }\n          // }\n        }\n        let mut sum: u32 = 0;\n  for x in 0..WIDTH {\n    for y in 0..HEIGHT {\n      sum += map[x][y] as u32;\n      // let val = map[x][y];\n      // if !val {\n      //   let mut found_obstacle = false;\n\n      //   for i in 0..58 {\n      //     if (x == o[i].0) & (y == o[i].1) & o[i].2 {\n      //       found_obstacle = true;\n      //     }\n      //   }\n\n      //   assert(found_obstacle);\n      // }\n    }\n  }\n  let mut obstacle_sum: u32 = 0;\n  for i in 0..MAX_ENEMY_OBSTACLES {\n    obstacle_sum += (!is_obstacle_traversible(obstacles[i])) as u32 + (!is_obstacle_traversible(their_obstacles[i])) as u32;\n  }\n  assert(sum == obstacle_sum);\n\n  map\n}\n\npub fn can_move_to(distance: u16, x: u8, y: u8, obstacles: [Obstacle; MAX_ENEMY_OBSTACLES], their_obstacles: [Obstacle; MAX_ENEMY_OBSTACLES]) -> bool {\n    let mut can = is_distance_within_viewing_range(distance); //x <= advance;\n    can &= is_tile_free_or_invisible(x, y, obstacles, their_obstacles);\n\n    can\n}\n// pub fn their_x_to_mine(side: u1, x: i8) -> i8 {\n//     let mul = side as i8;\n//     mul * 31 + 16 + x\n// }\n\n// x * s -16 + y = 0 if s == 0 => y = 16\n// x * s -16 + y = 31 if s == 1 => x = 31\n// y = 31 * s + 16 + x\n// s = 0:\n// x = -16 => y = 0\n// x = 15 => y = 31\n// s = 1:\n// x = -16 => y = 31\n// x = 15 => y = 0\n\n// pub fn serialize_x(x: i8) -> (bool, u8) {\n//     let valid = (x >= -(WIDTH / 2) as i8) & (x < (WIDTH / 2) as i8);\n//     (valid, (x + (WIDTH / 2) as i8) as u8)\n// }\n\n// pub fn deserialize_x(x: u8) -> (bool, i8) {\n//     let valid = x < WIDTH;\n//     (valid, x as i8 - (WIDTH / 2) as i8)\n// }","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/map.nr"},"77":{"source":"// use crate::MAX_OBSTACLES;\n// use crate::{ HEIGHT, WIDTH };\n// use crate::{ EMPTY, WALL, WATER };\n// use crate::{ MAX_EVENTS }; // MAX_CHARACTERS\n// // use crate::{ RECEIVE_ATTACK };\n// // use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\n// use crate::{ SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\n// use crate::event::Event;\n// use crate::map::{ is_visible }; //is_neighbor\n// use dep::std;\n\n// pub struct Obstacle {\n//     pub id: u8,\n//     pub x: u8,             // 5 bit\n//     pub y: u8,             // 4 bit\n//     pub health: u8,        // 8 bit\n//     pub obstacle_type: u8, // 4 bit\n// }\n\n// pub impl Obstacle {\n//     pub fn serialize(self) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         assert(self.y < 0x10, f\"Obstacle y is too large\");\n//         assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n\n//         let packed_y = self.obstacle_type * 0x10 + self.y;\n//         [ self.x, packed_y, self.health]\n//     }\n\n//     pub fn is_obstacle_traversible(self) -> bool {\n//         (self.obstacle_type >= NON_EMPTY_WALKABLE_TILE_MIN) | (self.obstacle_type == EMPTY)\n//     }\n\n//     pub fn parse_their_obstacles(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let health = field[2];\n//         let o = Obstacle {\n//             id: id,\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn parse_obstacle(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let mut health = field[2];\n//         if (obstacle_type == WALL) | (obstacle_type == WATER) {\n//             let mut damage = 0;\n//             for i in 0..MAX_EVENTS {\n//                 damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n//             }\n//             if damage > (health as u16) {\n//                 health = 0;\n//             } else {\n//                 health -= (damage as u8);\n//             }\n//         }\n//         let o = Obstacle {\n//             id: id, // + (MAX_CHARACTERS as u8),\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//             //was_alive: was_alive,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         (self.x < WIDTH) & (self.y < HEIGHT)\n//     }\n\n//     pub fn parse_their_obstacles(serialized_obstacles: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_their_obstacles(id, serialized_obstacle));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn parse_my_obstacles(serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], events: [Event; MAX_EVENTS]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_obstacle(id, serialized_obstacle, events));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn serialize_obstacles(side: u1, enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n//         let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n//         for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//             let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n//                 if is_visible(side, enemy_advance, obstacle.x) {\n//                     let serialized_obstacle = obstacle.serialize();\n//                     for k in 0..3 {\n//                         serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n//                     }\n//                 }\n//             }\n//             serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n//         }\n//         serialized_obstacles\n//     }\n\n//     pub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n//         // assert(side < 2, f\"Side is too large {side}\");\n//         let x = |x| x * (((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n//         [\n//             new_obstacle( 0, x(0), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 1, x(1), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 2, x(3), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 3, x(4), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 4, x(5), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle( 5, x(5), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle( 6, x(5), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle( 7, x(5), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 8, x(4), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 9, x(3), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(10, x(1), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(11, x(0), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(12, x(7), y: 0, obstacle_type: 200, WALL),\n//             new_obstacle(13, x(7), y: 1, obstacle_type: 200, WALL),\n//             new_obstacle(14, x(7), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle(15, x(7), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle(16, x(7), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle(17, x(7), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle(18, x(6), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(19, x(7), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(20, x(5), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(21, x(6), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(22, x(7), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(23, x(8), y: 9, obstacle_type: 255, WATER),\n//         ]\n//     }\n// }\n\n\nuse arenalib::MAX_OBSTACLES;\nuse arenalib::{ HEIGHT, WIDTH };\nuse arenalib::{ EMPTY, WALL, WATER };\nuse arenalib::{ MAX_EVENTS, MAX_HEALTH, MAX_OBSTACLE_TYPE, MAX_ENEMY_OBSTACLES }; // MAX_CHARACTERS\n// use crate::{ RECEIVE_ATTACK };\n// use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\nuse arenalib::{ SerializedArenaEnemyObstacles, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\nuse arenalib::NON_EMPTY_WALKABLE_TILE_MIN;\nuse arenalib::SerializedArenaObstacles;\nuse crate::event::Event;\nuse crate::map::{ is_visible, their_x_to_mine }; //is_neighbor\nuse dep::std;\nuse skplg::{softassert, NOWHERE};\nuse arenalib::SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE;\nuse arenalib::MAX_CHARACTERS;\n\n// pub type Obstacle = [u8; 5];\npub struct Obstacle {\n    pub id: u8,\n    pub x: u8,             // 5 bit\n    pub y: u8,             // 4 bit\n    pub health: u8,        // 8 bit\n    pub obstacle_type: u8, // 4 bit\n}\npub fn get_obstacle_id(obstacle: Obstacle) -> u8 {\n    obstacle.id //obstacle[0]\n}\npub fn get_obstacle_x(obstacle: Obstacle) -> u8 {\n    obstacle.x //[1]\n}\npub fn get_obstacle_y(obstacle: Obstacle) -> u8 {\n    obstacle.y //[2]\n}\npub fn get_obstacle_health(obstacle: Obstacle) -> u8 {\n    obstacle.health //[3]\n}\npub fn get_obstacle_type(obstacle: Obstacle) -> u8 {\n    obstacle.obstacle_type //[4]\n}\n\n#[export]\npub fn new_obstacle(id: u8, x: u8, y: u8, health: u8, obstacle_type: u8) -> pub (bool, Obstacle) {\n  let valid = ((x < WIDTH) | (x == NOWHERE)) & ((y < HEIGHT) | (y == NOWHERE)) & (health <= MAX_HEALTH) & (obstacle_type <= MAX_OBSTACLE_TYPE) & (id as u32 < (MAX_OBSTACLES + MAX_CHARACTERS));\n    // let mut valid = true;\n    // softassert!(quote { valid }, quote { (x < WIDTH) | (x == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid x: {x} >= {WIDTH}\" });\n    // softassert!(quote { valid }, quote { (y < HEIGHT) | (y == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid y: {y} >= {HEIGHT}\" });\n    // softassert!(quote { valid }, quote { health <= MAX_HEALTH }, quote { f\"Cannot create Obstacle: Invalid health: {health} > {MAX_HEALTH}\" });\n    // softassert!(quote { valid }, quote { obstacle_type <= MAX_OBSTACLE_TYPE }, quote { f\"Cannot create Obstacle: Invalid obstacle type: {obstacle_type} > {MAX_OBSTACLE_TYPE}\" }); //TODO: not sure if this or is_valid???\n    // (valid, [ id, x, y, health, obstacle_type ])\n    (valid, Obstacle { id: id, x: x, y: y, health: health, obstacle_type: obstacle_type })\n}\n\n#[test]\nfn test_new_obstacle() {\n  let (val, o) = new_obstacle(0, 0, 2, 0xc8, 0x06);\n  assert(val);\n  assert(o.id == 0);\n}\n\n// #[export]\n// pub struct FrontendObstacle {\n//   pub id: u8,\n//   pub x: u8,\n//   pub y: u8,\n\n// }\n\npub fn serialize_obstacle(obstacle: Obstacle) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n    // we could assert here, since obstacles can only be create with new_obstacle?!\n    // assert(self.y < 0x10, f\"Obstacle y is too large\");\n    // assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n    comptime {\n        let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let packed_y = get_obstacle_type(obstacle) * 0x10 + get_obstacle_y(obstacle);\n                [ get_obstacle_x(obstacle), packed_y, get_obstacle_health(obstacle)]\n            }\n        } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n                [ get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_health(obstacle), get_obstacle_type(obstacle)]\n            }\n        } else {\n            quote {\n                assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n            }\n        };\n        q\n    }\n}\n\npub fn is_obstacle_traversible(obstacle: Obstacle) -> bool {\n    (get_obstacle_type(obstacle) >= NON_EMPTY_WALKABLE_TILE_MIN) | (get_obstacle_type(obstacle) == EMPTY)\n}\n\npub fn parse_their_obstacle(id: u8, fld: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> (bool, Obstacle) {\n    comptime {\n        assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n    }\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let mut valid = true;\n    let x_raw = fld[0];\n    let (x_parsed_valid, x_parsed) = their_x_to_mine(x_raw);\n    softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to convert their x to mine of their obstacle {id}: {x_raw}\" });\n    let y = fld[1] & 0x0F;\n    let obstacle_type = (fld[1]) / 0x10;\n    let health = fld[2];\n    let (obstacle_valid, obstacle) = new_obstacle(id, x_parsed, y, health, obstacle_type);\n    softassert!(quote { valid }, quote { obstacle_valid }, quote { f\"Failed to create new obstacle {id}, {x_parsed}, {y}, {health}, {obstacle_type}\" });\n    (valid, obstacle)\n    // let o = Obstacle {\n    //     id: id,\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn parse_obstacle(id: u8, f: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> (bool, Obstacle) {\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let x = f[0];\n    // let mut y = f[1];\n    // let mut obstacle_type = f[1];\n    // comptime {\n    //     let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n    //         quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let y = f[1] & 0x0F;\n                let obstacle_type = (f[1]) / 0x10;\n    //         }\n    //     } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n    //         quote {\n    //             assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n    //             y = f[1];\n    //             obstacle_type = f[3];\n    //         }\n    //     } else {\n    //         quote {\n    //             assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n    //         }\n    //     };\n    //     q\n    // }\n    // let y = f[1]; // & 0x0F;\n    // let obstacle_type = f[3]; //f[1] / 0x10;// (f[1] & 0xF0) / 0x10;\n    let mut health = f[2];\n    //if (obstacle_type == WALL) | (obstacle_type == WATER) {\n        let mut damage = 0;\n        for i in 0..MAX_EVENTS {\n            damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n        }\n        if damage > (health as u16) {\n            health = 0;\n        } else {\n            health -= (damage as u8);\n        }\n    //}\n    new_obstacle(id, x, y, health, obstacle_type)\n    // let o = Obstacle {\n    //     id: id, // + (MAX_CHARACTERS as u8),\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    //     //was_alive: was_alive,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn is_obstacle_valid(obstacle: Obstacle) -> bool {\n    (get_obstacle_x(obstacle) < WIDTH) & (get_obstacle_y(obstacle) < HEIGHT)\n}\n\n#[export]\npub fn parse_their_obstacles(serialized_obstacles: SerializedArenaEnemyObstacles) -> (bool, [Obstacle; MAX_ENEMY_OBSTACLES]) {\n  let (dummy_obstacle_valid, dummy_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, 255, 0);\n  assert(dummy_obstacle_valid);\n    let mut obstacles: [Obstacle; MAX_ENEMY_OBSTACLES] = [dummy_obstacle; MAX_ENEMY_OBSTACLES];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n            obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j] = obstacle; //s.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    let serialized_obstacle_field = serialized_obstacles[SERIALIZED_OBSTACLES_ARRAY_SIZE].to_be_bytes::<32>();\n    assert(serialized_obstacle_field.len() == 32);\n    for j in 0..MAX_CHARACTERS {\n      let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n      // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n      let id = (MAX_OBSTACLES + j) as u8;\n      let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n      obstacles[MAX_OBSTACLES + j] = obstacle; //s.push_back(obstacle);\n      valid_result = valid_result & valid;\n    }\n    (valid_result, obstacles)\n}\n\npub fn parse_my_obstacles(serialized_obstacles: SerializedArenaObstacles, events: [Event; MAX_EVENTS]) -> (bool, [Obstacle; MAX_OBSTACLES]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            //let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_obstacle(id, serialized_obstacle, events);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles.as_array())\n}\n\n#[export]\npub fn serialize_my_obstacles_for_me(obstacles: [Obstacle; MAX_OBSTACLES]) -> pub [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            let serialized_obstacle = serialize_obstacle(obstacle);\n            for k in 0..3 {\n                serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\n\npub fn serialize_my_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let serialized_obstacle = serialize_obstacle(obstacle);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\npub fn serialize_their_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) {\n    let mut valid_result = true;\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let parsed_x = their_x_to_mine(get_obstacle_x(obstacle));\n                valid_result = valid_result & parsed_x.0;\n                let mirrored_obstacle = new_obstacle(\n                    get_obstacle_id(obstacle),\n                    parsed_x.1,\n                    get_obstacle_y(obstacle),\n                    get_obstacle_health(obstacle),\n                    get_obstacle_type(obstacle)\n                );\n                valid_result = valid_result & mirrored_obstacle.0;\n                let serialized_obstacle = serialize_obstacle(mirrored_obstacle.1);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    (valid_result, serialized_obstacles)\n}\n\nfn get_x_of_side(side: u1, x: u8) -> u8 {\n    x * ((side as u8 + 1) as u1) as u8 + side as u8 * (WIDTH - 1 - x)\n}\n\n#[test]\nfn test_x() {\n    let x8s0 = get_x_of_side(0, 8);\n    assert(x8s0 == 8, f\"{x8s0} != 8\");\n    let x8s1 = get_x_of_side(1, 8);\n    assert(x8s1 == 23, f\"{x8s1} != 23\");\n}\n\npub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n    // assert(side < 2, f\"Side is too large {side}\");\n    let x = |x| get_x_of_side(side, x); //(((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n    [\n        new_obstacle( 0, x(0), 2, 200, WALL).1,\n        new_obstacle( 1, x(1), 2, 200, WALL).1,\n        new_obstacle( 2, x(3), 2, 200, WALL).1,\n        new_obstacle( 3, x(4), 2, 200, WALL).1,\n        new_obstacle( 4, x(5), 3, 200, WALL).1,\n        new_obstacle( 5, x(5), 4, 200, WALL).1,\n        new_obstacle( 6, x(5), 5, 200, WALL).1,\n        new_obstacle( 7, x(5), 7, 200, WALL).1,\n        new_obstacle( 8, x(4), 7, 200, WALL).1,\n        new_obstacle( 9, x(3), 7, 200, WALL).1,\n        new_obstacle(10, x(1), 7, 200, WALL).1,\n        new_obstacle(11, x(0), 7, 200, WALL).1,\n        new_obstacle(12, x(7), 0, 200, WALL).1,\n        new_obstacle(13, x(7), 1, 200, WALL).1,\n        new_obstacle(14, x(7), 2, 200, WALL).1,\n        new_obstacle(15, x(7), 3, 200, WALL).1,\n        new_obstacle(16, x(7), 4, 200, WALL).1,\n        new_obstacle(17, x(7), 5, 200, WALL).1,\n        new_obstacle(18, x(6), 8, 255, WATER).1,\n        new_obstacle(19, x(7), 8, 255, WATER).1,\n        new_obstacle(20, x(5), 9, 255, WATER).1,\n        new_obstacle(21, x(6), 9, 255, WATER).1,\n        new_obstacle(22, x(7), 9, 255, WATER).1,\n        new_obstacle(23, x(8), 9, 255, WATER).1,\n        // new_obstacle(24, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(25, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(26, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(27, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(28, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(29, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(30, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(31, x(0), 0, 255, EMPTY).1,\n    ]\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/obstacle.nr"}},"names":["parse_their_obstacles"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}