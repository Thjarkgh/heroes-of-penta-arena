{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17085309147182912689,"abi":{"parameters":[{"name":"chars","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"character::Character","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"class","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"progress","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"has_been_seen","type":{"kind":"boolean"}},{"name":"is_hidden","type":{"kind":"integer","sign":"unsigned","width":1}},{"name":"target_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"target_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"damage_mod","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"last_action","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"actions","type":{"kind":"array","length":7,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}}]}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"array","length":30,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"72":{"source":"\nuse arenalib::ARCHER;\nuse arenalib::KNIGHT;\nuse arenalib::MAGE;\nuse arenalib::RITUALIST;\nuse arenalib::ROGUE;\nuse arenalib::WIDTH;\nuse arenalib::HEIGHT;\nuse arenalib::{ CLASS_COUNT, PROGRESS_COUNT };\nuse arenalib::{ WAIT }; //, ATTACK_MELEE, ATTACK_FIREBALL, ATTACK_RANGED, MAX_FIREBALL_ROUNDS_FOR_CAST, MIN_FIREBALL_ROUNDS_FOR_CAST, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT };\nuse arenalib::{ MAX_CHARACTERS, MAX_EVENTS, MAX_OBSTACLES, MAX_ACTIONS_PER_CHARACTER };\nuse arenalib::{ WIDTH_MASK, HEIGHT_MASK, CLASS_MASK, PROGRESS_MASK };\nuse arenalib::{ WIDTH_BITS, HEIGHT_BITS, CLASS_BITS, PROGRESS_BITS };\nuse crate::event::Event;\nuse crate::map::is_visible;\nuse crate::obstacle::Obstacle;\nuse crate::obstacle::new_obstacle;\nuse skplg::{NOWHERE, debug, softassert};\nuse arenalib::{ActionDefinition};\nuse arenalib::{SerializedArenaCharacterRoster, SerializedArenaActionDefinitions, SerializedArenaCharacterActionDefinitions, SerializedArenaCharacterActionDefinition};\n// use arenalib::{TRAP, ADD_OBSTACLE, WIN_BY_RITUAL, RITUAL_ROUNDS_FOR_WIN};\nuse arenalib::get_test_action_register;\nuse crate::event::{build_subtype_value_event, serialize_events};\nuse arenalib::NO_EVENT;\nuse arenalib::get_wait_action_def;\n\n\npub global SERIALIZED_CHARACTER_BYTES: u32 = 6;\npub type SerializedCharacter = [u8; SERIALIZED_CHARACTER_BYTES];\n\n// use skplam::{build_wait_action_def, build_shoot_action, build_draw_action, build_move_action, build_attack_action, build_cast_action, build_evocation_action, build_search_action, build_set_trap_action, build_sneak_action, build_ritual_action, build_disarm_trap_action};\n\n// this should be more efficient: for all the following: order is: UNKNOWN_CLASS, ARCHER, RITUALIST, ROGUE, KNIGHT, MAGE\nglobal class_damage_melee: [u8; 6] = [ 0, 32, 8, 24, 40, 16 ];\nglobal class_damage_ranged: [u8; 6] = [ 0, 24, 40, 16, 32, 8 ];\nglobal class_damage_fireball: [u8; 6] = [ 0, 0, 100, 50, 0, 100 ];\nglobal class_damage: [[u8; 6]; 3] = [ class_damage_melee, class_damage_ranged, class_damage_fireball ];\nglobal class_energy_per_attack: [u8; 6] = [ 0, 7, 7, 7, 6, 7 ];\nglobal class_energy_per_cast: [u8; 6] = [ 0, 255, 12, 255, 255, 6 ];\nglobal class_energy_per_disarm: [u8; 6] = [ 0, 255, 255, 12, 255, 255 ];\nglobal class_energy_per_move: [u8; 6] = [ 0, 3, 4, 3, 4, 4 ];\nglobal class_energy_per_ritual: [u8; 6] = [ 0, 255, 12, 255, 255, 255 ];\nglobal class_energy_per_search: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_sneak: [u8; 6] = [ 0, 255, 255, 6, 255, 255 ];\nglobal class_energy_per_draw: [u8; 6] = [ 0, 9, 255, 255, 255, 255 ];\nglobal class_energy_per_shoot: [u8; 6] = [ 0, 6, 255, 255, 255, 255 ];\nglobal resistances: [u16; 8 * 3] = [\n     0,  75, 100, 85,  50, 100, 20,  0, //,  255, 255, 0, 0, 0, 255, 255, 255 ], // Melee vs dummy, archer, ritualist, thief, knight, mage, wall, water, unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n     0,  80, 100, 90,  25, 100,  5,  0, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Ranged vs dummy, archer, ritualist, thief, knight, mage, wall, water\n     0,  80, 100, 90, 100,  90, 60, 50, // 255, 255, 0, 0, 0, 255, 255, 255 ], // Fireball vs dummy, archer, ritualist, thief, knight, mage, wall, water\n];\n\nglobal trap_resistances: [u16; 8] = [ 0,  75, 100, 50,  75, 90, 5, 0]; //,  255, 255, 255, 255, 255, 255, 255, 255 ]; // Trap vs dummy, archer, ritualist, thief, knight, mage\n\n\n//global x: ActionDefinition = build_set_trap_action(1 as u8, 1 as u8);\n// TODO: move to character!\n// global ARCHER: u8 = 1;    WAIT, MOVE, ATTACK, DRAW, SHOOT\n// global RITUALIST: u8 = 2; WAIT, MOVE, ATTACK, CAST, RITUAL\n// global ROGUE: u8 = 3;     WAIT, MOVE, ATTACK, SNEAK, SEARCH, DISARM_TRAP, SET_TRAP\n// global KNIGHT: u8 = 4;    WAIT, MOVE, ATTACK\n// global MAGE: u8 = 5;      WAIT, MOVE, ATTACK, CAST, CAST_FIREBALL\n// global ACTION_DEFINITIONS: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER * CLASS_COUNT] = [\n//     // [[0 as u8; ACTION_DEFINITION_SIZE]; MAX_ACTIONS_PER_CHARACTER], // 0 for no action\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n//     [0 as u8; ACTION_DEFINITION_SIZE],\n    \n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ARCHER]),\n//         build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//         build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//         build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[RITUALIST]),\n//         build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//         build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//         build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[ROGUE]),\n//         build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//         build_sneak_action(class_energy_per_sneak[ROGUE]),\n//         build_search_action(class_energy_per_search[ROGUE], 1),\n//         build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[KNIGHT]),\n//         build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//         WAIT_ACTION,\n//     // ],\n//     // [\n//         WAIT_ACTION,\n//         build_move_action(class_energy_per_move[MAGE]),\n//         build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//         build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//         build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, FIREBALL_ROUNDS_FOR_CAST, FIREBALL_ROUNDS_FOR_CAST),\n//         WAIT_ACTION,\n//         WAIT_ACTION\n//     // ]\n// ];\n// global \n// pub fn get_test_action_register() -> [u8; ACTION_DEFINITION_REGISTER_SIZE] {\n//     build_action_def_reg!([\n//         [\n//             build_move_action(class_energy_per_move[ARCHER]),\n//             build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER]),\n//             build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER),\n//             build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT), // archer\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[RITUALIST]),\n//             build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST]),\n//             build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST),\n//             build_ritual_action(3, class_energy_per_ritual[RITUALIST]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[ROGUE]),\n//             build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE]),\n//             build_sneak_action(class_energy_per_sneak[ROGUE]),\n//             build_search_action(class_energy_per_search[ROGUE], 1),\n//             build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1),\n//             build_set_trap_action(class_energy_per_disarm[ROGUE], 1),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[KNIGHT]),\n//             build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT]),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//             build_wait_action_def(),\n//         ],\n//         [\n//             build_move_action(class_energy_per_move[MAGE]),\n//             build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE]),\n//             build_cast_action(3, class_energy_per_cast[MAGE], MAGE),\n//             build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST),\n//             build_wait_action_def(),\n//             build_wait_action_def()\n//         ]\n//     ])\n// }\n// pub fn get_test_action_register() -> SerializedArenaActionDefinitions {\n//   let action_builder = arena_action_def_builder;\n//      [\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ARCHER], ATTACK_MELEE, 1, class_damage[0][ARCHER])),\n//             std::field::bytes32_to_field(action_builder.build_draw_action(3, class_energy_per_draw[ARCHER], 10, ARCHER)),\n//             std::field::bytes32_to_field(action_builder.build_shoot_action(3, class_energy_per_shoot[ARCHER], ATTACK_RANGED, 8, class_damage[1][ARCHER], 2, MIN_DRAW_ROUNDS_FOR_SHOOT, MAX_DRAW_ROUNDS_FOR_SHOOT)), // arche),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n            \n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[RITUALIST], ATTACK_MELEE, 1, class_damage[0][RITUALIST])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[RITUALIST], RITUALIST, 255)),\n//             std::field::bytes32_to_field(action_builder.build_ritual_action(3, class_energy_per_ritual[RITUALIST], RITUAL_ROUNDS_FOR_WIN, WIN_BY_RITUAL)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[ROGUE], ATTACK_MELEE, 1, class_damage[0][ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_sneak_action(class_energy_per_sneak[ROGUE])),\n//             std::field::bytes32_to_field(action_builder.build_search_action(class_energy_per_search[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_disarm_trap_action(class_energy_per_disarm[ROGUE], 1)),\n//             std::field::bytes32_to_field(action_builder.build_set_trap_action(class_energy_per_disarm[ROGUE], 1, ADD_OBSTACLE, TRAP)),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[KNIGHT])),\n//            std::field::bytes32_to_field( action_builder.build_attack_action(class_energy_per_attack[KNIGHT], ATTACK_MELEE, 1, class_damage[0][KNIGHT])),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n\n//             std::field::bytes32_to_field(action_builder.build_move_action(class_energy_per_move[MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_attack_action(class_energy_per_attack[MAGE], ATTACK_MELEE, 1, class_damage[0][MAGE])),\n//             std::field::bytes32_to_field(action_builder.build_cast_action(3, class_energy_per_cast[MAGE], MAGE, 7)),\n//             std::field::bytes32_to_field(action_builder.build_evocation_action(3, class_energy_per_cast[MAGE], ATTACK_FIREBALL, 6, 1,class_damage[2][MAGE], 5, MIN_FIREBALL_ROUNDS_FOR_CAST, MAX_FIREBALL_ROUNDS_FOR_CAST)),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def()),\n//             std::field::bytes32_to_field(action_builder.build_wait_action_def())\n//         ]\n// }\n\n// struct CharacterClass {\n//     class: u8,\n//     damage: u8,\n//     energy_per_attack: u8,\n//     energy_per_cast: u8,\n//     energy_per_disarm: u8,\n//     energy_per_move: u8,\n//     energy_per_ritual: u8,\n//     energy_per_search: u8,\n//     energy_per_sneak: u8,\n// }\n\npub struct Character {\n    pub id: u8,\n    pub x: u8, // 5 bit\n    pub y: u8, // 4 bit\n    pub class: u8, // 3 bit\n    pub progress: u8, // 0 = idle, 1-15 = continuing action => 4 bit\n    pub health: u8,\n    pub has_been_seen: bool,\n    pub is_hidden: u1,\n    pub target_x: u8,\n    pub target_y: u8,\n    pub damage_mod: u8,\n    pub last_action: u8,\n    pub status: u8,\n    // pub wait_action: ActionDefinition,\n    pub actions: [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1], // BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER>,\n}\n\n// pub fn resolve_action(action: u8, class: u8) -> ActionDefinition {\n//     let mut idx = class as u32 * MAX_ACTIONS_PER_CHARACTER + action as u32;\n//     if idx >= (ACTION_DEFINITIONS.len()) {\n//         idx = 0;\n//     }\n//     // assert(action as u32 < MAX_ACTIONS_PER_CHARACTER);\n//     // assert(class as u32 < CLASS_COUNT);\n//     ACTION_DEFINITIONS[idx]\n// }\n//     pub fn resolve_action(action: Action) -> ActionDefinition {\n//         // let idx = get_action_base_index(self.get_id(), action);\n//         ActionDefinition::new(action, ACTION_DEFINITIONS)\n// //        (idx, ACTION_DEFINITIONS)\n//         //resolve_action(action, self.class)\n//         // let mut a = action as u32;\n//         // if a >= self.actions.len() { a = 0; }\n//         // self.actions[a] //.get_unchecked(a)\n//     }\n//global wait_action: ActionDefinition = buld_wait_action_def();\n\n// global wait_action: ActionDefinition = action_builder.build_wait_action_def();\n\nimpl Character {\n    // pub fn new(id: u8 x: u8, y: u8, class: u8, status: u8, health: u8, has_been_seen: u8)\n    /// May throw\n\n\n    pub fn get_id(self) -> u8 {\n        self.id\n    }\n\n    pub fn get_x(self) -> u8 {\n        self.x\n    }\n\n    pub fn get_y(self) -> u8 {\n        self.y\n    }\n\n    pub fn get_class(self) -> u8 {\n        self.class\n    }\n\n    pub fn get_progress(self) -> u8 {\n        self.progress\n    }\n\n    pub fn get_status(self) -> u8 {\n        self.status\n    }\n\n    pub fn get_health(self) -> u8 {\n        self.health\n    }\n\n    pub fn get_has_been_seen(self) -> bool {\n        self.has_been_seen\n    }\n\n    pub fn get_target_x(self) -> u8 {\n        self.target_x\n    }\n\n    pub fn get_target_y(self) -> u8 {\n        self.target_y\n    }\n\n    pub fn get_is_hidden(self) -> u1 {\n      self.is_hidden\n    }\n\n    pub fn get_damage_mod(self) -> u8 {\n      self.damage_mod\n    }\n\n    pub fn get_action(self, action_idx: u8) -> (bool, ActionDefinition) {\n      /*if action_idx == 0 {\n        (true, self.wait_action)\n      } else */if action_idx <= MAX_ACTIONS_PER_CHARACTER as u8 {\n        (true, self.actions[action_idx])\n      } else {\n        (false, self.actions[0])\n      }\n    }\n\n    // pub fn get_energy_per_attack(self) -> u8 {\n    //     class_energy_per_attack[self.class]\n    // }\n\n    // pub fn get_energy_per_cast(self) -> u8 {\n    //     class_energy_per_cast[self.class]\n    // }\n\n    // pub fn get_energy_per_disarm(self) -> u8 {\n    //     class_energy_per_disarm[self.class]\n    // }\n\n    // pub fn get_energy_per_move(self) -> u8 {\n    //     class_energy_per_move[self.class]\n    // }\n\n    // pub fn get_energy_per_ritual(self) -> u8 {\n    //     class_energy_per_ritual[self.class]\n    // }\n\n    // pub fn get_energy_per_search(self) -> u8 {\n    //     class_energy_per_search[self.class]\n    // }\n\n    // pub fn get_energy_per_sneak(self) -> u8 {\n    //     class_energy_per_sneak[self.class]\n    // }\n\n    // pub fn get_energy_per_draw(self) -> u8 {\n    //     class_energy_per_draw[self.class]\n    // }\n\n    // pub fn get_energy_per_shoot(self) -> u8 {\n    //     class_energy_per_shoot[self.class]\n    // }\n\n    // pub fn get_damage(self, attack_type: u8) -> u8 {\n    //     self.damage_mod + class_damage[attack_type][self.class]\n    // }\n\n    pub fn get_last_action(self) -> u8 {\n      self.last_action\n    }\n\n    // pub fn can_sneak(self) -> bool {\n    //     class_energy_per_sneak[self.class] != 255\n    // }\n\n    // pub fn can_ritual(self) -> bool {\n    //     class_energy_per_ritual[self.class] != 255\n    // }\n\n    // pub fn can_cast_fireball(self) -> bool {\n    //     class_energy_per_cast[self.class] != 255\n    // }\n\n    pub fn can_shoot(self) -> bool {\n        self.class == ARCHER\n    }\n    // pub fn can_disarm(self) -> bool {\n    //     class_energy_per_disarm[self.class] != 255\n    // }\n\n    // pub fn can_search(self) -> bool {\n    //     class_energy_per_search[self.class] != 255\n    // }\n\n    fn is_pos_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_target_valid(x: u8, y: u8) -> bool { ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) & (y == 255)) }\n    fn is_class_valid(class: u8) -> bool { class as u32 <= CLASS_COUNT }\n    fn is_status_valid(status: u8) -> bool { status < PROGRESS_COUNT }\n\n    pub fn is_valid(self) -> bool {\n        Character::is_pos_valid(self.x, self.y) &\n        Character::is_target_valid(self.target_x, self.target_y) &\n        Character::is_class_valid(self.class) &\n        Character::is_status_valid(self.progress)\n    }\n\n    pub fn serialize(self) -> (SerializedCharacter, SerializedArenaCharacterActionDefinitions) {\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n        assert(self.is_valid());\n        let packed_x = self.x + (self.class << WIDTH_BITS);\n        let packed_y = self.y + (self.progress << HEIGHT_BITS);\n        let packed_target_x = (self.target_x & WIDTH_MASK) + ((self.is_hidden as u8) << WIDTH_BITS);\n        let packed_target_y = (self.target_y & HEIGHT_MASK) + ((self.last_action as u8) << HEIGHT_BITS);\n\n        // let serialized_action_defs = self.actions.map(|a|std::field::bytes32_to_field(a));\n        let serialized_action_defs = [\n          std::field::bytes32_to_field(self.actions[1]),\n          std::field::bytes32_to_field(self.actions[2]),\n          std::field::bytes32_to_field(self.actions[3]),\n          std::field::bytes32_to_field(self.actions[4]),\n          std::field::bytes32_to_field(self.actions[5]),\n          std::field::bytes32_to_field(self.actions[6])\n        ];\n        \n        ([packed_x, packed_y, self.health, packed_target_x, packed_target_y, self.damage_mod], serialized_action_defs)\n    }\n\n    pub fn to_obstacle(self) -> (bool, Obstacle) {\n        comptime {\n            assert(MAX_CHARACTERS < (255 - MAX_OBSTACLES));\n        }\n        assert(self.is_valid());\n        new_obstacle(self.id + (MAX_OBSTACLES as u8), self.x, self.y, self.health, self.class)\n        // Obstacle {\n        //     id: self.id + (MAX_CHARACTERS as u8),\n        //     x: self.x,\n        //     y: self.y,\n        //     obstacle_type: self.class,\n        //     health: self.health,\n        //     //was_alive: \n        // }\n    }\n\n    pub fn move(self, x: u8, y: u8) -> Character {\n        let mut c = self;\n        c.x = x;\n        c.y = y;\n        c\n    }\n\n    pub fn take_damage(self, attack_type: u8, dmg: u8) -> Character {\n        let damage_after_resistances = get_attack_damage_to_tile(attack_type, dmg as u32, self.class);\n        let mut c = self;\n        if damage_after_resistances > (c.health as u32) {\n            c.health = 0;\n        } else {\n            c.health -= (damage_after_resistances as u8);\n        }\n        c\n    }\n\n    pub fn set_status(self, status: u8) -> Character {\n        assert(status < PROGRESS_COUNT);\n        let mut c = self;\n        c.progress = status;\n        c\n    }\n\n    pub fn create_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n        // let mut actions: BoundedVec<ActionDefinition, 6> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..6 {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions.push(ACTION_DEFINITIONS[idx + i]);\n        //     }\n        // }\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: 0,\n            health: 0,\n            has_been_seen: false,\n            is_hidden: 0,\n            target_x: 255,\n            target_y: 255,\n            damage_mod: 0,//: class_damage[class],\n            last_action: WAIT,\n            status: 0, // TODO: status\n            actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1]// BoundedVec::new()\n        };\n        assert(c.is_valid());\n        c\n    }\n\n    pub fn parse(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool, Character) {\n        // these asserts could be disabled for production\n        comptime {\n            assert(WIDTH <= WIDTH_MASK + 1);\n            assert(HEIGHT <= HEIGHT_MASK + 1);\n            assert(CLASS_COUNT <= (CLASS_MASK + 1) as u32);\n            assert(PROGRESS_COUNT <= PROGRESS_MASK + 1);\n            assert(WIDTH_BITS + CLASS_BITS <= 8);\n            assert(HEIGHT_BITS + PROGRESS_BITS <= 8);\n            assert(WIDTH_BITS + 1 <= 8);\n        }\n\n      let (is_valid, c) = parse_unconstrained(id, data, actions_data, wait_action, events, enemy_advance);\n      // assert(c.)\n\n        assert(c.is_valid());\n        (is_valid, c)\n    }\n}\n\nfn parse_unconstrained(id: u8, data: Field, actions_data: SerializedArenaActionDefinitions, wait_action: ActionDefinition, events: [Event; MAX_EVENTS], enemy_advance: u8) -> (bool,Character) {\n          let mut is_valid = true;\n\n        let split: [u8; 32] = data.to_be_bytes::<32>();\n        assert(split.len() == 32);\n        let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n        let y_packed = split[2 + id * 6 + 1]; // 4 bit y, 4 bit status\n        let mut health = split[2 + id * 6 + 2] as u16;\n        let target_x_packed = split[2 + id * 6 + 3]; // 5 bit target x, 1 bit hidden, 1 bit has target, 1 bit unused\n        let target_y_packed = split[2 + id * 6 + 4]; // 4 bit target y, 4 bit last action\n        let damage_mod = split[2 + id * 6 + 5]; // last byte: for the moment, use to save damage_mod (buffs, etc)\n\n        let x = x_packed & WIDTH_MASK;\n        let y = y_packed & HEIGHT_MASK;\n        let mut class = (x_packed >> WIDTH_BITS) & CLASS_MASK;\n        if !Character::is_class_valid(class) {\n            debug!(quote { println(f\"Invalid class {class}\"); });\n            class = 0;\n            is_valid = false;\n        }\n\n        let progress = (y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n        softassert!(quote { is_valid }, quote { Character::is_status_valid(progress) }, quote { f\"Invalid status {progress} during character parsing {id}\" });\n\n        let target_x = target_x_packed & WIDTH_MASK;\n        let target_y = target_y_packed & HEIGHT_MASK;\n        let last_action = (target_y_packed >> HEIGHT_BITS) & PROGRESS_MASK;\n\n        let is_visible = is_visible(enemy_advance, x); //((target_x_packed >> 5) & 1) as u1;\n        let is_hidden = ((target_x_packed >> WIDTH_BITS) & 1) as u1;\n\n        let mut damage: u16 = 0;\n        for i in 0..MAX_EVENTS {\n            let event = events[i];\n            damage += event.get_applied_damage_to_my_asset(x, y, class);\n            // if events[i].actor_id == id {\n            //     let event = events[i];\n            //     if event.actor_id == id {\n            //         damage += event.get_applied_damage_to_my_asset(x, y, class);\n            //     }\n            // }\n        }\n        if damage > health {\n            health = 0;\n        } else {\n            health -= damage;\n        }\n\n        // let mut actions = [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]; //: BoundedVec<ActionDefinition, MAX_ACTIONS_PER_CHARACTER> = BoundedVec::new();\n        // let idx = class as u32 * MAX_ACTIONS_PER_CHARACTER;\n        // for i in 1..MAX_ACTIONS_PER_CHARACTER {\n        //     if (ACTION_DEFINITIONS[idx + i][ACTION_IS_CONTINUOUS] != 0) | (ACTION_DEFINITIONS[idx + 1][ACTION_RESULT_STATUS_MULTIPLIER] != 1) {\n        //         actions[i] = ACTION_DEFINITIONS[idx + i];\n        //     }\n        // }\n\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            progress: progress,\n            health: health as u8,\n            has_been_seen: is_visible, // TODO \n            is_hidden: is_hidden,\n            target_x: target_x,\n            target_y: target_y,\n            damage_mod: damage_mod,\n            last_action: last_action,\n            actions: [\n              wait_action,\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 1].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 2].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 3].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 4].to_be_bytes::<32>(),\n              actions_data[id * MAX_ACTIONS_PER_CHARACTER as u8 + 5].to_be_bytes::<32>()\n            ],\n            status: 0 // TODO: status\n        };\n        (is_valid, c)\n}\n\n// unconstrained fn create_character_unconstrained(\n//   id: u8,\n//   x: u8,\n//   y: u8,\n//   class: u8,\n//   progress: u8,\n//   health: u8,\n//   has_been_seen: u8\n// )\n\nfn select_action_defs_of_character(actions: SerializedArenaActionDefinitions, char_id: u32) -> [ActionDefinition; MAX_ACTIONS_PER_CHARACTER + 1] {\n  let mut result: [SerializedArenaCharacterActionDefinition] = &[std::field::bytes32_to_field(get_wait_action_def())];\n  let offset = char_id * MAX_ACTIONS_PER_CHARACTER;\n  for i in 0..MAX_ACTIONS_PER_CHARACTER {\n    result = result.push_back(actions[offset + i]);\n  }\n  result.as_array().map(|f|f.to_be_bytes())\n}\n\npub fn get_default_characters(side: u8) -> [Character; MAX_CHARACTERS] {\n    assert(side < 2, f\"Side is too large {side}\");\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n    let default_actions = get_test_action_register();\n\n    let x = |x| x * ((side + 1) % 2) + (WIDTH - 1 - x) * side;\n    [\n        Character { id: 0, x: x(2), y: 2, class: ARCHER, health: 100, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 1), status: 0 },\n        Character { id: 1, x: x(2), y: 3, class: RITUALIST, health: 60, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 2), status: 0 },\n        Character { id: 2, x: x(2), y: 4, class: ROGUE, health: 80, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 3), status: 0 },\n        Character { id: 3, x: x(2), y: 5, class: KNIGHT, health: 120, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 4), status: 0 },\n        Character { id: 4, x: x(2), y: 6, class: MAGE, health: 40, progress: 0, target_x: 0, target_y: 0, has_been_seen: false, damage_mod: 0, is_hidden: 0, last_action: WAIT, actions: select_action_defs_of_character(default_actions, 5), status: 0 },\n    ]\n}\n\n#[export]\npub fn parse_characters(data: SerializedArenaCharacterRoster, actions_data: SerializedArenaActionDefinitions, events: [Event; MAX_EVENTS], enemy_advance: u8) -> pub (bool, [Character; MAX_CHARACTERS]) {\n    comptime { assert(MAX_CHARACTERS == 5); }\n\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut is_valid = true;\n\n    let wait_action = get_wait_action_def();\n\n    // no need to optimize, compiler automatically rolls this out\n    // let mut result: [Character; MAX_CHARACTERS] = [Character::create_character(0, 0, 0, 0), Character::create_character(1, 0, 0, 0), Character::create_character(2, 0, 0, 0), Character::create_character(3, 0, 0, 0), Character::create_character(4, 0, 0, 0)];\n    // for i in 0..(MAX_CHARACTERS as u8) {\n    //     let (curr_valid, curr_c) = Character::parse(i, data, actions_data, wait_action, events, enemy_advance);\n    //     is_valid &= curr_valid;\n    //     result[i] = curr_c;\n    // }\n\n        let (curr_valid, curr_c0) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[0] = curr_c0;\n        let (curr_valid, curr_c1) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[1] = curr_c1;\n        let (curr_valid, curr_c2) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[2] = curr_c2;\n        let (curr_valid, curr_c3) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[3] = curr_c3;\n        let (curr_valid, curr_c4) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n        is_valid &= curr_valid;\n        // result[4] = curr_c4;\n    let result = [curr_c0, curr_c1, curr_c2, curr_c3, curr_c4];\n    (is_valid, result)\n}\n\npub fn get_test_my_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    // let wait_action = arena_action_def_builder.build_wait_action_def();\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 100,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\npub fn get_test_their_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class as u32 < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        progress: 0,\n        health: 255,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 255,\n        target_y: 255,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    }\n}\n\n#[test]\nfn test_serialize_character() {\n    let mut character = Character {\n        id: 4,\n        x: 21,\n        y: 9,\n        class: 5,\n        progress: 9,\n        health: 129,\n        has_been_seen: false,\n        is_hidden: 0,\n        target_x: 31,\n        target_y: 9,\n        damage_mod: 0,\n        last_action: WAIT,\n        actions: [[0 as u8; 32]; MAX_ACTIONS_PER_CHARACTER + 1],\n        status: 0\n    };\n    let (field, _) = character.serialize();\n    assert(field[0] == (21 | (5 << 5)));\n    assert(field[1] == (9 | (9 << 4)));\n    assert(field[2] == 129);\n    assert(field[3] == 31); // TODO: why?\n    assert(field[4] == 9);\n    assert(field[5] == 0);\n}\n\n#[test]\nfn test_parse_character() {\n    let dummy_events = Event::get_test_dummy_events();\n    let data_array: [u8; 32] = [\n        0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        191 as u8, 249 as u8, 255 as u8, 255 as u8, 9 as u8, 255 as u8,\n        181 as u8, 153 as u8, 129 as u8, 127 as u8, 9 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n    ];\n    let data: Field = std::field::bytes32_to_field(data_array);\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    println(data);\n    assert(data == 0xbff9ffff09ffb599817f0900000000000000, f\"Failed assumption: data: {data} != 0xbff9ffff09ffb599817f0900000000000000\");\n    let (character_valid, character) = Character::parse(3, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_valid);\n    assert(character.get_id() == 3);\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 9);\n    assert(character.get_class() == 5);\n    assert(character.get_progress() == 9);\n    assert(character.get_health() == 129);\n    assert(character.get_has_been_seen());\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n\n    let (character_max_valid, character_max) = Character::parse(2, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_max_valid);\n    assert(character_max.get_id() == 2);\n    assert(character_max.get_x() == 31);\n    assert(character_max.get_y() == 9);\n    assert(character_max.get_class() == 5);\n    assert(character_max.get_progress() == 15);\n    assert(character_max.get_health() == 255);\n    assert(character_max.get_has_been_seen());\n    assert(character_max.get_target_x() == 31);\n    assert(character_max.get_target_y() == 9);\n\n    let (character_min_valid, character_min) = Character::parse(0, data, dummy_actions, wait_action, dummy_events, 20);\n    assert(character_min_valid);\n    assert(character_min.get_id() == 0);\n    assert(character_min.get_x() == 0);\n    assert(character_min.get_y() == 0);\n    assert(character_min.get_class() == 0);\n    assert(character_min.get_progress() == 0);\n    assert(character_min.get_health() == 0);\n    assert(character_min.get_has_been_seen() == false);\n    assert(character_min.get_target_x() == 0);\n    assert(character_min.get_target_y() == 0);\n}\n\n#[test]\nfn test_parse_character_as_in_game() {\n    let wait_action = get_wait_action_def();\n    let dummy_actions = [wait_action; MAX_ACTIONS_PER_CHARACTER * MAX_CHARACTERS].map(|x|std::field::bytes32_to_field(x));\n    let data: Field = 0x1602ff1f09001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00;\n    let (character_valid, character) = Character::parse(0, data, dummy_actions, wait_action, Event::get_test_dummy_events(), 20);\n    assert(character_valid);\n    assert(character.get_id() == 0);\n    assert(character.get_x() == 22, character.get_x());\n    assert(character.get_y() == 2, character.get_y());\n    assert(character.get_class() == 0, character.get_class());\n    assert(character.get_progress() == 0, character.get_progress());\n    assert(character.get_health() == 255);\n    assert(character.get_has_been_seen() == true);\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 9);\n}\n\n#[export]\npub fn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> pub (Field, SerializedArenaActionDefinitions) {\n    let mut result: [u8; 32] = [0; 32];\n    let mut actions: SerializedArenaActionDefinitions = [0; 30]; //&[].as_array();\n    for i in 0..MAX_CHARACTERS {\n        let (serialized_char_bytes, serialized_actions) = chars[i].serialize();\n        for j in 0..6 {\n            result[2 + i * 6 + j] = serialized_char_bytes[j];\n        }\n        for k in 0..MAX_ACTIONS_PER_CHARACTER {\n          actions[i * MAX_ACTIONS_PER_CHARACTER + k] = serialized_actions[k];\n        }\n    }\n    \n    (std::field::bytes32_to_field(result), actions)\n}\n\n/**\n* For now we will only take class into account.\n*/\npub fn get_attack_damage_to_tile(attack_type: u8, damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * resistances[attack_type * 8 + (class & 7)] as u32 / 100) as u32\n}\n\npub fn get_trap_damage_to_tile(damage: u32, class: u8) -> u32 {\n    debug!(quote { assert(class <= arenalib::MAX_DAMAGEABLE_TILE); });\n    (damage * trap_resistances[class & 7] as u32 / 100) as u32\n}\n\n#[test]\nfn test_parse_character_round0() {\n  // let actions_data = .map(|f|f.to_be_bytes::<32>()).map(|f|std::field::bytes32_to_field(f));\n  let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n  let enemy_advance = 0x00;\n  let events = [\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0),\n    build_subtype_value_event(NO_EVENT, 4, NOWHERE, NOWHERE, 0, NO_EVENT, 0)\n  ];\n  let serialized_events = serialize_events(events);\n   println(f\"events: {serialized_events}\");\n\n  let parsed = parse_characters(data, [\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071020100a000020100a00000020000000002000000000000000,\n    0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n    0x023100081b161118120a010018120a01000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071008100a000008100a00000020000000002000000000000000,\n    0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n    0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300314002000000000100300000020000000002000000000000000,\n    0x02f0000110071018100a000018100a00000020000000002000000000000000,\n    0x09f0000130060c002000000000200000000020000000002000000000000000,\n    0xf00001100610001005000100100500010020000000002000000000000000,\n    0xf00001301c0100100d000000100d00000020000000002000000000000000,\n    0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110061028100a000028100a00000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0x03f00001300414002000000000100300000020000000002000000000000000,\n    0x02f0000110071010100a000010100a00000020000000002000000000000000,\n    0xf000071b1611002000000000000705000020000000002000000000000000,\n    0x6300061b161164150a020164150a02010020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000,\n    0xf0003f000001002000000000200000000020000000002000000000000000\n], events, enemy_advance);\n\n  assert(parsed.0);\n}","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/character.nr"}},"names":["serialize_chars"],"brillig_names":["directive_integer_quotient","directive_invert"]}