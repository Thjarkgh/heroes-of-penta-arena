{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":834670145587040670,"abi":{"parameters":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7ZzbSuNQFED/Jc95yN7n7q8Mg1StUiit1DowiP8+5xSbMjUUV5jOg+wXaexZIc2KDSy2eeselnevT7erzeP2pbv58datt/eL/Wq7qVtvXTj86uV5sWlbL/vFbt/dFJ9j3y03D4eX6b3vHlfrZXeT0vvPvoscSRzJHClTSHDhgwg+j0CJ7/3nvYdx5/m0VEvbtwyTxxOH497ry3h2PCIzGJ3BuBmMv+bJmr6qko5Icnp+QHEGk2YweQZTppmhjIz4M0aHK55gnb6ychpOiDs/IJ3BuBmMn8FMXzA5uJEJ+ZyJVzvBdeNut1qvV0+3f31ZDu1HmT4nF2wVj4mAiYiJhImMiUIJGQaOCEeUI44jniOBI5EjiSOZI9y+cPvC7Qu3L9y+cPvC7Qu3L9y+cPvC7Su3r9y+cvvK7Su3r9y+cvvK7Su3r9y+4/Ydt++4fcftO27fcfuO23fcvuP2HbfvuX3P7Xtu33P7ntv33L7n9j2377l9z+0Hbj9w+4HbD9x+4PYDtx+4/cDtB24/cPuR24/cfuT2I7cfuf3I7UduP3L7kduP3H7i9hO3n7j9xO0nbj9x+4nbT9x+4vYTt5+5/cztZ24/c/uZ28/cfub2M7efuf3M7Rduv0zaz6IfSPbhE6IccRzxHAkMqRtyaJBWFK0oWlG0omhF0YqiFUUrip0VRSuKVhStKFpRtKJoRdGKohVFK4pWFL+IcPvfpig2JOIIqW2hNR9rPhCx5mPNx5qPNZ8vItZ8rPlY87Hm8zXEmo81H2s+1nys+Vjz+X/N5zLC7fPRLuGzXcKHu4RPdwkf7xI+36V8vkv5fJfy+S7l8106eI7g4qdD5EjiSOZIwSnSHVKktQVrC9YWrC1YW7C2YG3B2oK1BWsLnbUFawvWFqwtWFv4t23hMhI5kjiSOcLt8zki5XNEyueIlM8RKZ8jUj5HpHyOSPkckfI5IuVzRMrniJTPESmfI1I+R6R8jkj5HJEq74rKu6LyrqgFI9Ot70KKrFu/FrvV4m69bA+LbG++bu6Pz46sm/vfz8d3jk+XfN5t75cPr7tle87k6RGTzW8e+jK0u1Y7jnqD7OtdYvz/78MC6YucFuS6wI2zmW1B8b0M/riifjP19c9zTKZthUjoRcO4xGmvLtWPUj/OHw==","file_map":{"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"77":{"source":"// use crate::MAX_OBSTACLES;\n// use crate::{ HEIGHT, WIDTH };\n// use crate::{ EMPTY, WALL, WATER };\n// use crate::{ MAX_EVENTS }; // MAX_CHARACTERS\n// // use crate::{ RECEIVE_ATTACK };\n// // use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\n// use crate::{ SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\n// use crate::event::Event;\n// use crate::map::{ is_visible }; //is_neighbor\n// use dep::std;\n\n// pub struct Obstacle {\n//     pub id: u8,\n//     pub x: u8,             // 5 bit\n//     pub y: u8,             // 4 bit\n//     pub health: u8,        // 8 bit\n//     pub obstacle_type: u8, // 4 bit\n// }\n\n// pub impl Obstacle {\n//     pub fn serialize(self) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         assert(self.y < 0x10, f\"Obstacle y is too large\");\n//         assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n\n//         let packed_y = self.obstacle_type * 0x10 + self.y;\n//         [ self.x, packed_y, self.health]\n//     }\n\n//     pub fn is_obstacle_traversible(self) -> bool {\n//         (self.obstacle_type >= NON_EMPTY_WALKABLE_TILE_MIN) | (self.obstacle_type == EMPTY)\n//     }\n\n//     pub fn parse_their_obstacles(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let health = field[2];\n//         let o = Obstacle {\n//             id: id,\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn parse_obstacle(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let mut health = field[2];\n//         if (obstacle_type == WALL) | (obstacle_type == WATER) {\n//             let mut damage = 0;\n//             for i in 0..MAX_EVENTS {\n//                 damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n//             }\n//             if damage > (health as u16) {\n//                 health = 0;\n//             } else {\n//                 health -= (damage as u8);\n//             }\n//         }\n//         let o = Obstacle {\n//             id: id, // + (MAX_CHARACTERS as u8),\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//             //was_alive: was_alive,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         (self.x < WIDTH) & (self.y < HEIGHT)\n//     }\n\n//     pub fn parse_their_obstacles(serialized_obstacles: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_their_obstacles(id, serialized_obstacle));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn parse_my_obstacles(serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], events: [Event; MAX_EVENTS]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_obstacle(id, serialized_obstacle, events));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn serialize_obstacles(side: u1, enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n//         let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n//         for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//             let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n//                 if is_visible(side, enemy_advance, obstacle.x) {\n//                     let serialized_obstacle = obstacle.serialize();\n//                     for k in 0..3 {\n//                         serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n//                     }\n//                 }\n//             }\n//             serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n//         }\n//         serialized_obstacles\n//     }\n\n//     pub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n//         // assert(side < 2, f\"Side is too large {side}\");\n//         let x = |x| x * (((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n//         [\n//             new_obstacle( 0, x(0), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 1, x(1), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 2, x(3), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 3, x(4), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 4, x(5), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle( 5, x(5), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle( 6, x(5), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle( 7, x(5), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 8, x(4), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 9, x(3), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(10, x(1), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(11, x(0), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(12, x(7), y: 0, obstacle_type: 200, WALL),\n//             new_obstacle(13, x(7), y: 1, obstacle_type: 200, WALL),\n//             new_obstacle(14, x(7), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle(15, x(7), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle(16, x(7), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle(17, x(7), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle(18, x(6), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(19, x(7), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(20, x(5), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(21, x(6), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(22, x(7), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(23, x(8), y: 9, obstacle_type: 255, WATER),\n//         ]\n//     }\n// }\n\n\nuse arenalib::MAX_OBSTACLES;\nuse arenalib::{ HEIGHT, WIDTH };\nuse arenalib::{ EMPTY, WALL, WATER };\nuse arenalib::{ MAX_EVENTS, MAX_HEALTH, MAX_OBSTACLE_TYPE }; // MAX_CHARACTERS\n// use crate::{ RECEIVE_ATTACK };\n// use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\nuse arenalib::{ SerializedArenaEnemyObstacles, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\nuse arenalib::NON_EMPTY_WALKABLE_TILE_MIN;\nuse arenalib::SerializedArenaObstacles;\nuse crate::event::Event;\nuse crate::map::{ is_visible, their_x_to_mine }; //is_neighbor\nuse dep::std;\nuse skplg::softassert;\n\n// pub type Obstacle = [u8; 5];\npub struct Obstacle {\n    pub id: u8,\n    pub x: u8,             // 5 bit\n    pub y: u8,             // 4 bit\n    pub health: u8,        // 8 bit\n    pub obstacle_type: u8, // 4 bit\n}\npub fn get_obstacle_id(obstacle: Obstacle) -> u8 {\n    obstacle.id //obstacle[0]\n}\npub fn get_obstacle_x(obstacle: Obstacle) -> u8 {\n    obstacle.x //[1]\n}\npub fn get_obstacle_y(obstacle: Obstacle) -> u8 {\n    obstacle.y //[2]\n}\npub fn get_obstacle_health(obstacle: Obstacle) -> u8 {\n    obstacle.health //[3]\n}\npub fn get_obstacle_type(obstacle: Obstacle) -> u8 {\n    obstacle.obstacle_type //[4]\n}\n\n#[export]\npub fn new_obstacle(id: u8, x: u8, y: u8, health: u8, obstacle_type: u8) -> pub (bool, Obstacle) {\n    let mut valid = true;\n    softassert!(quote { valid }, quote { x < WIDTH }, quote { f\"Cannot create Obstacle: Invalid x: {x} >= {WIDTH}\" });\n    softassert!(quote { valid }, quote { y < HEIGHT }, quote { f\"Cannot create Obstacle: Invalid y: {y} >= {HEIGHT}\" });\n    softassert!(quote { valid }, quote { health <= MAX_HEALTH }, quote { f\"Cannot create Obstacle: Invalid health: {health} > {MAX_HEALTH}\" });\n    softassert!(quote { valid }, quote { obstacle_type <= MAX_OBSTACLE_TYPE }, quote { f\"Cannot create Obstacle: Invalid obstacle type: {obstacle_type} > {MAX_OBSTACLE_TYPE}\" }); //TODO: not sure if this or is_valid???\n    // (valid, [ id, x, y, health, obstacle_type ])\n    (valid, Obstacle { id: id, x: x, y: y, health: health, obstacle_type: obstacle_type })\n}\n\n// #[export]\n// pub struct FrontendObstacle {\n//   pub id: u8,\n//   pub x: u8,\n//   pub y: u8,\n\n// }\n\npub fn serialize_obstacle(obstacle: Obstacle) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n    // we could assert here, since obstacles can only be create with new_obstacle?!\n    // assert(self.y < 0x10, f\"Obstacle y is too large\");\n    // assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n    comptime {\n        let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let packed_y = get_obstacle_type(obstacle) * 0x10 + get_obstacle_y(obstacle);\n                [ get_obstacle_x(obstacle), packed_y, get_obstacle_health(obstacle)]\n            }\n        } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n                [ get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_health(obstacle), get_obstacle_type(obstacle)]\n            }\n        } else {\n            quote {\n                assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n            }\n        };\n        q\n    }\n}\n\npub fn is_obstacle_traversible(obstacle: Obstacle) -> bool {\n    (get_obstacle_type(obstacle) >= NON_EMPTY_WALKABLE_TILE_MIN) | (get_obstacle_type(obstacle) == EMPTY)\n}\n\npub fn parse_their_obstacle(id: u8, fld: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> (bool, Obstacle) {\n    comptime {\n        assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n    }\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let mut valid = true;\n    let x_raw = fld[0];\n    let (x_parsed_valid, x_parsed) = their_x_to_mine(x_raw);\n    softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to convert their x to mine of their obstacle {id}: {x_raw}\" });\n    let y = fld[1] & 0x0F;\n    let obstacle_type = (fld[1]) / 0x10;\n    let health = fld[2];\n    let (obstacle_valid, obstacle) = new_obstacle(id, x_parsed, y, health, obstacle_type);\n    softassert!(quote { valid }, quote { obstacle_valid }, quote { f\"Failed to create new obstacle {id}, {x_parsed}, {y}, {health}, {obstacle_type}\" });\n    (valid, obstacle)\n    // let o = Obstacle {\n    //     id: id,\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn parse_obstacle(id: u8, f: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> (bool, Obstacle) {\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let x = f[0];\n    // let mut y = f[1];\n    // let mut obstacle_type = f[1];\n    // comptime {\n    //     let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n    //         quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let y = f[1] & 0x0F;\n                let obstacle_type = (f[1]) / 0x10;\n    //         }\n    //     } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n    //         quote {\n    //             assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n    //             y = f[1];\n    //             obstacle_type = f[3];\n    //         }\n    //     } else {\n    //         quote {\n    //             assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n    //         }\n    //     };\n    //     q\n    // }\n    // let y = f[1]; // & 0x0F;\n    // let obstacle_type = f[3]; //f[1] / 0x10;// (f[1] & 0xF0) / 0x10;\n    let mut health = f[2];\n    //if (obstacle_type == WALL) | (obstacle_type == WATER) {\n        let mut damage = 0;\n        for i in 0..MAX_EVENTS {\n            damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n        }\n        if damage > (health as u16) {\n            health = 0;\n        } else {\n            health -= (damage as u8);\n        }\n    //}\n    new_obstacle(id, x, y, health, obstacle_type)\n    // let o = Obstacle {\n    //     id: id, // + (MAX_CHARACTERS as u8),\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    //     //was_alive: was_alive,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn is_obstacle_valid(obstacle: Obstacle) -> bool {\n    (get_obstacle_x(obstacle) < WIDTH) & (get_obstacle_y(obstacle) < HEIGHT)\n}\n\npub fn parse_their_obstacles(serialized_obstacles: SerializedArenaEnemyObstacles) -> (bool, [Obstacle]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles)\n}\n\npub fn parse_my_obstacles(serialized_obstacles: SerializedArenaObstacles, events: [Event; MAX_EVENTS]) -> (bool, [Obstacle]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            //let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_obstacle(id, serialized_obstacle, events);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles)\n}\n\n#[export]\npub fn serialize_my_obstacles_for_me(obstacles: [Obstacle; MAX_OBSTACLES]) -> pub [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            let serialized_obstacle = serialize_obstacle(obstacle);\n            for k in 0..3 {\n                serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\n\npub fn serialize_my_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let serialized_obstacle = serialize_obstacle(obstacle);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\npub fn serialize_their_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) {\n    let mut valid_result = true;\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let parsed_x = their_x_to_mine(get_obstacle_x(obstacle));\n                valid_result = valid_result & parsed_x.0;\n                let mirrored_obstacle = new_obstacle(\n                    get_obstacle_id(obstacle),\n                    parsed_x.1,\n                    get_obstacle_y(obstacle),\n                    get_obstacle_health(obstacle),\n                    get_obstacle_type(obstacle)\n                );\n                valid_result = valid_result & mirrored_obstacle.0;\n                let serialized_obstacle = serialize_obstacle(mirrored_obstacle.1);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    (valid_result, serialized_obstacles)\n}\n\nfn get_x_of_side(side: u1, x: u8) -> u8 {\n    x * ((side as u8 + 1) as u1) as u8 + side as u8 * (WIDTH - 1 - x)\n}\n\n#[test]\nfn test_x() {\n    let x8s0 = get_x_of_side(0, 8);\n    assert(x8s0 == 8, f\"{x8s0} != 8\");\n    let x8s1 = get_x_of_side(1, 8);\n    assert(x8s1 == 23, f\"{x8s1} != 23\");\n}\n\npub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n    // assert(side < 2, f\"Side is too large {side}\");\n    let x = |x| get_x_of_side(side, x); //(((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n    [\n        new_obstacle( 0, x(0), 2, 200, WALL).1,\n        new_obstacle( 1, x(1), 2, 200, WALL).1,\n        new_obstacle( 2, x(3), 2, 200, WALL).1,\n        new_obstacle( 3, x(4), 2, 200, WALL).1,\n        new_obstacle( 4, x(5), 3, 200, WALL).1,\n        new_obstacle( 5, x(5), 4, 200, WALL).1,\n        new_obstacle( 6, x(5), 5, 200, WALL).1,\n        new_obstacle( 7, x(5), 7, 200, WALL).1,\n        new_obstacle( 8, x(4), 7, 200, WALL).1,\n        new_obstacle( 9, x(3), 7, 200, WALL).1,\n        new_obstacle(10, x(1), 7, 200, WALL).1,\n        new_obstacle(11, x(0), 7, 200, WALL).1,\n        new_obstacle(12, x(7), 0, 200, WALL).1,\n        new_obstacle(13, x(7), 1, 200, WALL).1,\n        new_obstacle(14, x(7), 2, 200, WALL).1,\n        new_obstacle(15, x(7), 3, 200, WALL).1,\n        new_obstacle(16, x(7), 4, 200, WALL).1,\n        new_obstacle(17, x(7), 5, 200, WALL).1,\n        new_obstacle(18, x(6), 8, 255, WATER).1,\n        new_obstacle(19, x(7), 8, 255, WATER).1,\n        new_obstacle(20, x(5), 9, 255, WATER).1,\n        new_obstacle(21, x(6), 9, 255, WATER).1,\n        new_obstacle(22, x(7), 9, 255, WATER).1,\n        new_obstacle(23, x(8), 9, 255, WATER).1,\n        // new_obstacle(24, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(25, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(26, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(27, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(28, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(29, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(30, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(31, x(0), 0, 255, EMPTY).1,\n    ]\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/obstacle.nr"},"96":{"source":"pub global NOWHERE: u8 = 255;\npub global UNREADABLE_BYTES_PER_FIELD: u32 = 1;\npub comptime global DEBUG: bool = true;\npub comptime fn debug(stmt: Quoted) -> Quoted {\n    let debug_result = if DEBUG { stmt } else { quote {} };\n    debug_result\n}\npub comptime fn debugmsg<T>(msg: T) -> Quoted {\n    debug!(quote { println($msg); })\n}\npub comptime fn softassert(varname: Quoted, check: Quoted, msg: Quoted) -> Quoted {\n    let result = if DEBUG {\n        quote {\n            $varname &= $check;\n            if !($check) {\n                println($msg);\n            }\n        }\n    } else {\n        quote {\n            $varname &= $check;\n        }\n    };\n    result\n}\n\n////////////////////\n\n// global WIDTH_MASK: u8 = 31;\n// global CLASS_MASK: u8 = 7;\n// global WIDTH_BITS: u8 = 5;\n// global MAX_CHARACTERS: u32 = 5;\n// struct Character {\n//     pub x: u8, // 5 bit\n//     pub class: u8, // 3 bit\n//     pub actions: [[u8; 32]; 7],\n// }\n// impl Character {\n//     fn is_class_valid(class: u8) -> bool {\n//         class as u32 <= 5\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         let mut valid = true;\n//         let x = self.x;\n//         let class = self.class;\n//         println(x);\n//         valid &= Character::is_class_valid(class);\n//         valid\n//     }\n\n//     fn parse(\n//         id: u8,\n//         data: Field,\n//         actions_data: [Field; 30],\n//         wait_action: [u8; 32],\n//     ) -> (bool, Character) {\n//         let mut is_valid = true;\n\n//         let split: [u8; 32] = data.to_be_bytes::<32>();\n//         assert(split.len() == 32);\n//         let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n\n//         let x = x_packed & WIDTH_MASK;\n//         let mut class = (x_packed >> WIDTH_BITS) & CLASS_MASK;\n//         if !Character::is_class_valid(class) {\n//             class = 0;\n//             is_valid = false;\n//         }\n\n//         let c = Character {\n//             x: x,\n//             class: class,\n//             actions: [\n//                 wait_action,\n//                 actions_data[id * 6 as u8].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 1].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 2].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 3].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 4].to_be_bytes::<32>(),\n//                 actions_data[id * 6 as u8 + 5].to_be_bytes::<32>(),\n//             ],\n//         };\n//         (is_valid, c)\n//     }\n// }\n\n// fn create_character(x: u8, class: u8) -> Character {\n//     let c = Character { x: x, class: class, actions: [[0 as u8; 32]; 7] };\n//     assert(c.is_valid());\n//     c\n// }\n// fn parse_characters(data: Field, actions_data: [Field; 30]) -> (bool, [Character; MAX_CHARACTERS]) {\n//     let mut is_valid = true;\n\n//     let wait_action = [\n//         0 as u8, 0 as u8, 240 as u8, 0 as u8, 63 as u8, 0 as u8, 0 as u8, 1 as u8, 0 as u8,\n//         32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n//         32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n//         0 as u8, 0 as u8, 0 as u8,\n//     ];\n\n//     // no need to optimize, compiler automatically rolls this out\n//     let mut result: [Character; MAX_CHARACTERS] = [\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//         create_character(0, 0),\n//     ];\n//     for i in 0..(MAX_CHARACTERS as u8) {\n//         let (curr_valid, curr_c) = Character::parse(i, data, actions_data, wait_action);\n//         is_valid &= curr_valid;\n//         result[i] = curr_c;\n//     }\n\n//     // let (curr_valid, curr_c) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[0] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[1] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[2] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[3] = curr_c;\n//     // let (curr_valid, curr_c) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n//     // is_valid &= curr_valid;\n//     // result[4] = curr_c;\n//     (is_valid, result)\n// }\n\n// #[test]\n// fn test_parse_character_round0() {\n//     let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n\n//     let parsed = parse_characters(\n//         data,\n//         [\n//             0x03f00001300314002000000000100300000020000000002000000000000000,\n//             0x02f0000110071020100a000020100a00000020000000002000000000000000,\n//             0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n//             0x023100081b161118120a010018120a01000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110071008100a000008100a00000020000000002000000000000000,\n//             0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n//             0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300314002000000000100300000020000000002000000000000000,\n//             0x02f0000110071018100a000018100a00000020000000002000000000000000,\n//             0x09f0000130060c002000000000200000000020000000002000000000000000,\n//             0xf00001100610001005000100100500010020000000002000000000000000,\n//             0xf00001301c0100100d000000100d00000020000000002000000000000000,\n//             0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110061028100a000028100a00000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0x03f00001300414002000000000100300000020000000002000000000000000,\n//             0x02f0000110071010100a000010100a00000020000000002000000000000000,\n//             0xf000071b1611002000000000000705000020000000002000000000000000,\n//             0x6300061b161164150a020164150a02010020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//             0xf0003f000001002000000000200000000020000000002000000000000000,\n//         ],\n//     );\n//     assert(parsed.0);\n// }\n\n// // #[test]\n// // fn test_create_character_0() {\n// //   let data = 0x2912640000004b03190000006c04142000008a0464000000aa47640b340a;\n// //   let enemy_advance = 0x08;\n// //   let events = [0 as u8, 0 as u8, 0 as u8, 0 as u8];\n// //   println(events);\n\n// //   let actions_data = [\n// //     0x03f00001300314002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071020100a000020100a00000020000000002000000000000000,\n// //     0x02f0000a3b1901002000000000000801000020000000002000000000000000,\n// //     0x023100081b161118120a010018120a01000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071008100a000008100a00000020000000002000000000000000,\n// //     0xf0003f1b1c11002000000000000702000020000000002000000000000000,\n// //     0xff003f1b1c1100200e013f00000e013f0020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300314002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071018100a000018100a00000020000000002000000000000000,\n// //     0x09f0000130060c002000000000200000000020000000002000000000000000,\n// //     0xf00001100610001005000100100500010020000000002000000000000000,\n// //     0xf00001301c0100100d000000100d00000020000000002000000000000000,\n// //     0x0bf00001100c00002000000000200000000010040a00002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110061028100a000028100a00000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0x03f00001300414002000000000100300000020000000002000000000000000,\n// //     0x02f0000110071010100a000010100a00000020000000002000000000000000,\n// //     0xf000071b1611002000000000000705000020000000002000000000000000,\n// //     0x6300061b161164150a020164150a02010020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000,\n// //     0xf0003f000001002000000000200000000020000000002000000000000000\n// // ];\n// //   comptime { assert(5 <= 5); }\n\n// //     let enemy_advance = if enemy_advance >= 32 { 0 } else { 32 - enemy_advance - 1 };\n// //     let mut is_valid = true;\n\n// //     let wait_action = [0 as u8, 0 as u8, 240 as u8, 0 as u8, 63 as u8, 0 as u8, 0 as u8, 1 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 32 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8];\n\n// // let mut result: [Character; 5] = [create_character(0, 0, 0, 0), create_character(1, 0, 0, 0), create_character(2, 0, 0, 0), create_character(3, 0, 0, 0), create_character(4, 0, 0, 0)];\n// //     //for i in 0..(5 as u8) {\n// //         let (curr_valid, curr_c) = Character::parse(0, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[0] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(1, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[1] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(2, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[2] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(3, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[3] = curr_c;\n// //         let (curr_valid, curr_c) = Character::parse(4, data, actions_data, wait_action, events, enemy_advance);\n// //         is_valid &= curr_valid;\n// //         result[4] = curr_c;\n// //    // }\n// //     assert(is_valid);\n// //     // assert(result[0].x == 0);\n// // }\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skplg/src/lib.nr"}},"names":["new_obstacle"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient"]}