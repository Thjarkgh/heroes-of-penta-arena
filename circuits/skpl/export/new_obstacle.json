{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1416877306215136424,"abi":{"parameters":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"struct","path":"obstacle::Obstacle","fields":[{"name":"id","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"health","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"obstacle_type","type":{"kind":"integer","sign":"unsigned","width":8}}]}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VZ227CMAxNL2yDchnQcnvfe9ILtG/8ytDa//+EYS2WsjRjmnqChiXk4gb3+PgiqwTiSw7Xz5u+Dq6fSGuSF8sWOGyhwxY5bLG2xdp3KPrCzz1rLYeJCmC+WumAi/GtpDS5SLSe2glJjCSwbapJNSXySGIhj2XZnvJWFepd5s2lrmRZXY61qlVVVx95XRRtXdan5tKcZKPKolVd1RRtRyJVAvDVaWBTYHJjg1tbfBblQD5zE+/MJ2ByHlp+h4KfATHOgYXli8O5w+9QDuc4jPKekzmE+eqODrheJvNC61cmhKfwQvQnMx3yPZlDXCGphcA10CswufeczEA+v03mpU/A5Bw9mZdAjCvxvyczcbcS+Mm8wmH0EjetYnNg7XCOkCveGhivDw4XunbQHCKHcQqM9y8bwlDcEQq36joHXC8bQqb1hgnhbSAT/Q2BDv22ISBJHLohZEBcG3By0Y1NgycV+KLe4jDKezZjDMuXvFsz7rTeMyHceDvRb0Y65LsZY4Frxh0Q1x6cXHQz0uDZCnxRH4TfDW0oPsrxwQOfI3DcLOgtCBnz04PEjHtjLdXzg8SMexck1cuDxAzbbq8xjx8kZtgScY15Ao55ZMTN/2pRjmLD/qT1SF9Tf1G9Ef8TB2+8T4y1nhj+gfnP2X/ix798Fn0x402sexx/7Phd8MP30NK3zt56FThz3GOfa61NvBzH2NKZ4RfdqySpH//OXGXGdWrFafJ9BmFgf7w/j0RfQusen7V7JsDjUzaWyPEsFq6Z1LAxn5+FGUEXQh8AAA==","debug_symbols":"ndRLCoMwEAbgu2TtwrwTr1JKiRpLIESJWijSu9dKFQmW4uwyM3yzCH8yodqW4/3mQtP2qLhMyLeVGVwb5mpCfGn1nQmfqh9MHFChOc8zZEO9HPUrQ43zFhVSvq4ZEueJPE/UeaKPiWAbkSIhOAcYDDDk2Ci6GU1TQwGGAQwHmB8h0Go1AuepkQCjAOZHDtjOkMSQHGCOcyCw2AxNc0AIwFCAYQDD/94Blak5zoFgeDOSp0YCjAIYfd7Q/zlI3vZclNF57+63/cc6tx8mOlN6+y2bMVS76fDs1snqu9hWth6j/WxaZvP6Nw==","file_map":{"77":{"source":"// use crate::MAX_OBSTACLES;\n// use crate::{ HEIGHT, WIDTH };\n// use crate::{ EMPTY, WALL, WATER };\n// use crate::{ MAX_EVENTS }; // MAX_CHARACTERS\n// // use crate::{ RECEIVE_ATTACK };\n// // use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\n// use crate::{ SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\n// use crate::NON_EMPTY_WALKABLE_TILE_MIN;\n// use crate::event::Event;\n// use crate::map::{ is_visible }; //is_neighbor\n// use dep::std;\n\n// pub struct Obstacle {\n//     pub id: u8,\n//     pub x: u8,             // 5 bit\n//     pub y: u8,             // 4 bit\n//     pub health: u8,        // 8 bit\n//     pub obstacle_type: u8, // 4 bit\n// }\n\n// pub impl Obstacle {\n//     pub fn serialize(self) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         assert(self.y < 0x10, f\"Obstacle y is too large\");\n//         assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n\n//         let packed_y = self.obstacle_type * 0x10 + self.y;\n//         [ self.x, packed_y, self.health]\n//     }\n\n//     pub fn is_obstacle_traversible(self) -> bool {\n//         (self.obstacle_type >= NON_EMPTY_WALKABLE_TILE_MIN) | (self.obstacle_type == EMPTY)\n//     }\n\n//     pub fn parse_their_obstacles(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let health = field[2];\n//         let o = Obstacle {\n//             id: id,\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn parse_obstacle(id: u8, field: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> Obstacle {\n//         assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n//         //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n//         let x = field[0];\n//         let y = field[1] & 0x0F;\n//         let obstacle_type = (field[1] & 0xF0) / 0x10;\n//         let mut health = field[2];\n//         if (obstacle_type == WALL) | (obstacle_type == WATER) {\n//             let mut damage = 0;\n//             for i in 0..MAX_EVENTS {\n//                 damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n//             }\n//             if damage > (health as u16) {\n//                 health = 0;\n//             } else {\n//                 health -= (damage as u8);\n//             }\n//         }\n//         let o = Obstacle {\n//             id: id, // + (MAX_CHARACTERS as u8),\n//             x: x,\n//             y: y,\n//             health: health,\n//             obstacle_type: obstacle_type,\n//             //was_alive: was_alive,\n//         };\n//         assert(o.is_valid());\n//         o\n//     }\n\n//     pub fn is_valid(self) -> bool {\n//         (self.x < WIDTH) & (self.y < HEIGHT)\n//     }\n\n//     pub fn parse_their_obstacles(serialized_obstacles: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_their_obstacles(id, serialized_obstacle));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn parse_my_obstacles(serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], events: [Event; MAX_EVENTS]) -> [Obstacle] {\n//         let mut obstacles: [Obstacle] = &[];\n//         for i in 0..serialized_obstacles.len() {\n//             let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes();\n//             assert(serialized_obstacle_field.len() == 32);\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n//                 let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n//                 obstacles = obstacles.push_back(Obstacle::parse_obstacle(id, serialized_obstacle, events));\n//             }\n//         }\n//         obstacles\n//     }\n\n//     pub fn serialize_obstacles(side: u1, enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n//         let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n//         for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n//             let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n//             for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n//                 let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n//                 if is_visible(side, enemy_advance, obstacle.x) {\n//                     let serialized_obstacle = obstacle.serialize();\n//                     for k in 0..3 {\n//                         serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n//                     }\n//                 }\n//             }\n//             serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n//         }\n//         serialized_obstacles\n//     }\n\n//     pub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n//         // assert(side < 2, f\"Side is too large {side}\");\n//         let x = |x| x * (((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n//         [\n//             new_obstacle( 0, x(0), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 1, x(1), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 2, x(3), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 3, x(4), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle( 4, x(5), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle( 5, x(5), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle( 6, x(5), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle( 7, x(5), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 8, x(4), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle( 9, x(3), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(10, x(1), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(11, x(0), y: 7, obstacle_type: 200, WALL),\n//             new_obstacle(12, x(7), y: 0, obstacle_type: 200, WALL),\n//             new_obstacle(13, x(7), y: 1, obstacle_type: 200, WALL),\n//             new_obstacle(14, x(7), y: 2, obstacle_type: 200, WALL),\n//             new_obstacle(15, x(7), y: 3, obstacle_type: 200, WALL),\n//             new_obstacle(16, x(7), y: 4, obstacle_type: 200, WALL),\n//             new_obstacle(17, x(7), y: 5, obstacle_type: 200, WALL),\n//             new_obstacle(18, x(6), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(19, x(7), y: 8, obstacle_type: 255, WATER),\n//             new_obstacle(20, x(5), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(21, x(6), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(22, x(7), y: 9, obstacle_type: 255, WATER),\n//             new_obstacle(23, x(8), y: 9, obstacle_type: 255, WATER),\n//         ]\n//     }\n// }\n\n\nuse arenalib::MAX_OBSTACLES;\nuse arenalib::{ HEIGHT, WIDTH };\nuse arenalib::{ EMPTY, WALL, WATER };\nuse arenalib::{ MAX_EVENTS, MAX_HEALTH, MAX_OBSTACLE_TYPE, MAX_ENEMY_OBSTACLES }; // MAX_CHARACTERS\n// use crate::{ RECEIVE_ATTACK };\n// use crate::{ ATTACK_MELEE, ATTACK_RANGED, ATTACK_FIREBALL };\nuse arenalib::{ SerializedArenaEnemyObstacles, SERIALIZED_OBSTACLE_BYTE_SIZE, SERIALIZED_OBSTACLES_PER_FIELD, SERIALIZED_OBSTACLES_ARRAY_SIZE };\nuse arenalib::NON_EMPTY_WALKABLE_TILE_MIN;\nuse arenalib::SerializedArenaObstacles;\nuse crate::event::Event;\nuse crate::map::{ is_visible, their_x_to_mine }; //is_neighbor\nuse dep::std;\nuse skplg::{softassert, NOWHERE};\nuse arenalib::SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE;\nuse arenalib::MAX_CHARACTERS;\n\n// pub type Obstacle = [u8; 5];\npub struct Obstacle {\n    pub id: u8,\n    pub x: u8,             // 5 bit\n    pub y: u8,             // 4 bit\n    pub health: u8,        // 8 bit\n    pub obstacle_type: u8, // 4 bit\n}\npub fn get_obstacle_id(obstacle: Obstacle) -> u8 {\n    obstacle.id //obstacle[0]\n}\npub fn get_obstacle_x(obstacle: Obstacle) -> u8 {\n    obstacle.x //[1]\n}\npub fn get_obstacle_y(obstacle: Obstacle) -> u8 {\n    obstacle.y //[2]\n}\npub fn get_obstacle_health(obstacle: Obstacle) -> u8 {\n    obstacle.health //[3]\n}\npub fn get_obstacle_type(obstacle: Obstacle) -> u8 {\n    obstacle.obstacle_type //[4]\n}\n\n#[export]\npub fn new_obstacle(id: u8, x: u8, y: u8, health: u8, obstacle_type: u8) -> pub (bool, Obstacle) {\n  let valid = ((x < WIDTH) | (x == NOWHERE)) & ((y < HEIGHT) | (y == NOWHERE)) & (health <= MAX_HEALTH) & (obstacle_type <= MAX_OBSTACLE_TYPE);\n    // let mut valid = true;\n    // softassert!(quote { valid }, quote { (x < WIDTH) | (x == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid x: {x} >= {WIDTH}\" });\n    // softassert!(quote { valid }, quote { (y < HEIGHT) | (y == NOWHERE) }, quote { f\"Cannot create Obstacle: Invalid y: {y} >= {HEIGHT}\" });\n    // softassert!(quote { valid }, quote { health <= MAX_HEALTH }, quote { f\"Cannot create Obstacle: Invalid health: {health} > {MAX_HEALTH}\" });\n    // softassert!(quote { valid }, quote { obstacle_type <= MAX_OBSTACLE_TYPE }, quote { f\"Cannot create Obstacle: Invalid obstacle type: {obstacle_type} > {MAX_OBSTACLE_TYPE}\" }); //TODO: not sure if this or is_valid???\n    // (valid, [ id, x, y, health, obstacle_type ])\n    (valid, Obstacle { id: id, x: x, y: y, health: health, obstacle_type: obstacle_type })\n}\n\n#[test]\nfn test_new_obstacle() {\n  let (val, o) = new_obstacle(0, 0, 2, 0xc8, 0x06);\n  assert(val);\n  assert(o.id == 0);\n}\n\n// #[export]\n// pub struct FrontendObstacle {\n//   pub id: u8,\n//   pub x: u8,\n//   pub y: u8,\n\n// }\n\npub fn serialize_obstacle(obstacle: Obstacle) -> [u8; SERIALIZED_OBSTACLE_BYTE_SIZE] {\n    // we could assert here, since obstacles can only be create with new_obstacle?!\n    // assert(self.y < 0x10, f\"Obstacle y is too large\");\n    // assert(self.obstacle_type < 0x10, f\"Obstacle type is too large\");\n    comptime {\n        let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let packed_y = get_obstacle_type(obstacle) * 0x10 + get_obstacle_y(obstacle);\n                [ get_obstacle_x(obstacle), packed_y, get_obstacle_health(obstacle)]\n            }\n        } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n            quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n                [ get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_health(obstacle), get_obstacle_type(obstacle)]\n            }\n        } else {\n            quote {\n                assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n            }\n        };\n        q\n    }\n}\n\npub fn is_obstacle_traversible(obstacle: Obstacle) -> bool {\n    (get_obstacle_type(obstacle) >= NON_EMPTY_WALKABLE_TILE_MIN) | (get_obstacle_type(obstacle) == EMPTY)\n}\n\npub fn parse_their_obstacle(id: u8, fld: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE]) -> (bool, Obstacle) {\n    comptime {\n        assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n    }\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let mut valid = true;\n    let x_raw = fld[0];\n    let (x_parsed_valid, x_parsed) = their_x_to_mine(x_raw);\n    softassert!(quote { valid }, quote { x_parsed_valid }, quote { f\"Failed to convert their x to mine of their obstacle {id}: {x_raw}\" });\n    let y = fld[1] & 0x0F;\n    let obstacle_type = (fld[1]) / 0x10;\n    let health = fld[2];\n    let (obstacle_valid, obstacle) = new_obstacle(id, x_parsed, y, health, obstacle_type);\n    softassert!(quote { valid }, quote { obstacle_valid }, quote { f\"Failed to create new obstacle {id}, {x_parsed}, {y}, {health}, {obstacle_type}\" });\n    (valid, obstacle)\n    // let o = Obstacle {\n    //     id: id,\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn parse_obstacle(id: u8, f: [u8; SERIALIZED_OBSTACLE_BYTE_SIZE], events: [Event; MAX_EVENTS]) -> (bool, Obstacle) {\n    //assert((id as u64) >= MAX_CHARACTERS, f\"Obstacle id is lower than minimum {id}\");\n    let x = f[0];\n    // let mut y = f[1];\n    // let mut obstacle_type = f[1];\n    // comptime {\n    //     let q = if SERIALIZED_OBSTACLE_BYTE_SIZE == 3 {\n    //         quote {\n                assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 3, f\"Obstacle byte size is not 3\");\n                let y = f[1] & 0x0F;\n                let obstacle_type = (f[1]) / 0x10;\n    //         }\n    //     } else if SERIALIZED_OBSTACLE_BYTE_SIZE == 4 {\n    //         quote {\n    //             assert(SERIALIZED_OBSTACLE_BYTE_SIZE == 4, f\"Obstacle byte size is not 4\");\n    //             y = f[1];\n    //             obstacle_type = f[3];\n    //         }\n    //     } else {\n    //         quote {\n    //             assert((SERIALIZED_OBSTACLE_BYTE_SIZE == 3) | (SERIALIZED_OBSTACLE_BYTE_SIZE == 4), f\"Invalid obstacle byte size {SERIALIZED_OBSTACLE_BYTE_SIZE}\");\n    //         }\n    //     };\n    //     q\n    // }\n    // let y = f[1]; // & 0x0F;\n    // let obstacle_type = f[3]; //f[1] / 0x10;// (f[1] & 0xF0) / 0x10;\n    let mut health = f[2];\n    //if (obstacle_type == WALL) | (obstacle_type == WATER) {\n        let mut damage = 0;\n        for i in 0..MAX_EVENTS {\n            damage += events[i].get_applied_damage_to_my_asset(x, y, obstacle_type);\n        }\n        if damage > (health as u16) {\n            health = 0;\n        } else {\n            health -= (damage as u8);\n        }\n    //}\n    new_obstacle(id, x, y, health, obstacle_type)\n    // let o = Obstacle {\n    //     id: id, // + (MAX_CHARACTERS as u8),\n    //     x: x,\n    //     y: y,\n    //     health: health,\n    //     obstacle_type: obstacle_type,\n    //     //was_alive: was_alive,\n    // };\n    // assert(o.is_valid());\n    // o\n}\n\npub fn is_obstacle_valid(obstacle: Obstacle) -> bool {\n    (get_obstacle_x(obstacle) < WIDTH) & (get_obstacle_y(obstacle) < HEIGHT)\n}\n\npub fn parse_their_obstacles(serialized_obstacles: SerializedArenaEnemyObstacles) -> (bool, [Obstacle; MAX_ENEMY_OBSTACLES]) {\n  let (dummy_obstacle_valid, dummy_obstacle) = new_obstacle(0, NOWHERE, NOWHERE, 255, 0);\n  assert(dummy_obstacle_valid);\n    let mut obstacles: [Obstacle; MAX_ENEMY_OBSTACLES] = [dummy_obstacle; MAX_ENEMY_OBSTACLES];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE);\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n            obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j] = obstacle; //s.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    let serialized_obstacle_field = serialized_obstacles[SERIALIZED_OBSTACLES_ARRAY_SIZE].to_be_bytes::<32>();\n    assert(serialized_obstacle_field.len() == 32);\n    for j in 0..MAX_CHARACTERS {\n      let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n      // let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n      let id = (MAX_OBSTACLES + j) as u8;\n      let (valid, obstacle) = parse_their_obstacle(id, serialized_obstacle);\n      obstacles[MAX_OBSTACLES + j] = obstacle; //s.push_back(obstacle);\n      valid_result = valid_result & valid;\n    }\n    (valid_result, obstacles)\n}\n\npub fn parse_my_obstacles(serialized_obstacles: SerializedArenaObstacles, events: [Event; MAX_EVENTS]) -> (bool, [Obstacle; MAX_OBSTACLES]) {\n    let mut obstacles: [Obstacle] = &[];\n    let mut valid_result = true;\n    assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    for i in 0..serialized_obstacles.len() {\n        let serialized_obstacle_field: [u8; 32] = serialized_obstacles[i].to_be_bytes::<32>();\n        assert(serialized_obstacle_field.len() == 32);\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2]];\n            //let serialized_obstacle = [serialized_obstacle_field[2 + j * 3], serialized_obstacle_field[2 + j * 3 + 1], serialized_obstacle_field[2 + j * 3 + 2], serialized_obstacle_field[2 + j * 3 + 2]];\n            let id = (i * SERIALIZED_OBSTACLES_PER_FIELD + j) as u8;\n            let (valid, obstacle) = parse_obstacle(id, serialized_obstacle, events);\n            obstacles = obstacles.push_back(obstacle);\n            valid_result = valid_result & valid;\n        }\n    }\n    (valid_result, obstacles.as_array())\n}\n\n#[export]\npub fn serialize_my_obstacles_for_me(obstacles: [Obstacle; MAX_OBSTACLES]) -> pub [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            let serialized_obstacle = serialize_obstacle(obstacle);\n            for k in 0..3 {\n                serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\n\npub fn serialize_my_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] {\n  let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let serialized_obstacle = serialize_obstacle(obstacle);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    serialized_obstacles\n}\npub fn serialize_their_obstacles(enemy_advance: u8, obstacles: [Obstacle; MAX_OBSTACLES]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) {\n    let mut valid_result = true;\n    let enemy_advance = if enemy_advance >= WIDTH { 0 } else { WIDTH - enemy_advance - 1 };\n    let mut serialized_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let mut serialized_obstacle_field: [u8; 32] = [0; 32];\n        for j in 0..SERIALIZED_OBSTACLES_PER_FIELD {\n            let obstacle = obstacles[i * SERIALIZED_OBSTACLES_PER_FIELD + j];\n            if is_visible(enemy_advance, get_obstacle_x(obstacle)) {\n                let parsed_x = their_x_to_mine(get_obstacle_x(obstacle));\n                valid_result = valid_result & parsed_x.0;\n                let mirrored_obstacle = new_obstacle(\n                    get_obstacle_id(obstacle),\n                    parsed_x.1,\n                    get_obstacle_y(obstacle),\n                    get_obstacle_health(obstacle),\n                    get_obstacle_type(obstacle)\n                );\n                valid_result = valid_result & mirrored_obstacle.0;\n                let serialized_obstacle = serialize_obstacle(mirrored_obstacle.1);\n                for k in 0..3 {\n                    serialized_obstacle_field[2 + j * 3 + k] = serialized_obstacle[k];\n                }\n            }\n        }\n        serialized_obstacles[i] = std::field::bytes32_to_field(serialized_obstacle_field);\n    }\n    (valid_result, serialized_obstacles)\n}\n\nfn get_x_of_side(side: u1, x: u8) -> u8 {\n    x * ((side as u8 + 1) as u1) as u8 + side as u8 * (WIDTH - 1 - x)\n}\n\n#[test]\nfn test_x() {\n    let x8s0 = get_x_of_side(0, 8);\n    assert(x8s0 == 8, f\"{x8s0} != 8\");\n    let x8s1 = get_x_of_side(1, 8);\n    assert(x8s1 == 23, f\"{x8s1} != 23\");\n}\n\npub fn get_default_obstacles(side: u1) -> [Obstacle; MAX_OBSTACLES] {\n    // assert(side < 2, f\"Side is too large {side}\");\n    let x = |x| get_x_of_side(side, x); //(((side as u8) + 1) % 2) + (WIDTH - 1 - x) * (side as u8);\n    [\n        new_obstacle( 0, x(0), 2, 200, WALL).1,\n        new_obstacle( 1, x(1), 2, 200, WALL).1,\n        new_obstacle( 2, x(3), 2, 200, WALL).1,\n        new_obstacle( 3, x(4), 2, 200, WALL).1,\n        new_obstacle( 4, x(5), 3, 200, WALL).1,\n        new_obstacle( 5, x(5), 4, 200, WALL).1,\n        new_obstacle( 6, x(5), 5, 200, WALL).1,\n        new_obstacle( 7, x(5), 7, 200, WALL).1,\n        new_obstacle( 8, x(4), 7, 200, WALL).1,\n        new_obstacle( 9, x(3), 7, 200, WALL).1,\n        new_obstacle(10, x(1), 7, 200, WALL).1,\n        new_obstacle(11, x(0), 7, 200, WALL).1,\n        new_obstacle(12, x(7), 0, 200, WALL).1,\n        new_obstacle(13, x(7), 1, 200, WALL).1,\n        new_obstacle(14, x(7), 2, 200, WALL).1,\n        new_obstacle(15, x(7), 3, 200, WALL).1,\n        new_obstacle(16, x(7), 4, 200, WALL).1,\n        new_obstacle(17, x(7), 5, 200, WALL).1,\n        new_obstacle(18, x(6), 8, 255, WATER).1,\n        new_obstacle(19, x(7), 8, 255, WATER).1,\n        new_obstacle(20, x(5), 9, 255, WATER).1,\n        new_obstacle(21, x(6), 9, 255, WATER).1,\n        new_obstacle(22, x(7), 9, 255, WATER).1,\n        new_obstacle(23, x(8), 9, 255, WATER).1,\n        // new_obstacle(24, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(25, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(26, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(27, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(28, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(29, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(30, x(0), 0, 255, EMPTY).1,\n        // new_obstacle(31, x(0), 0, 255, EMPTY).1,\n    ]\n}\n","path":"/home/andreas/git_repositories/heroes-of-penta-arena/circuits/skpl/src/obstacle.nr"}},"names":["new_obstacle"],"brillig_names":["directive_integer_quotient","directive_invert"]}