{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8255409921515214511,"abi":{"parameters":[{"name":"my_chars","type":{"kind":"field"},"visibility":"private"},{"name":"my_char_actions","type":{"kind":"array","length":899,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"my_obstacles","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"secret_be_bytes","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"1Z3djlbH0YXvhWMf7Prv9q18iiJs4wgJgYXxJ0VW7j3b1hDFmiRzMl7v02cMbOjaglrVb816WL+++eHdd7/87a/vP/746ec33/7fr28+fPr+7Zf3nz7eX/36Zof9/pM///T2429f//zl7ecvb741C+tv3rz7+MPvP47+xzdvfnz/4d2bb3v945tnj/e+7Onp3jb/etj+08PLM58eXt7+7w//5Zu7IKcVFLSCklZQ0QpqWkFDK2jRCtqwgvKiFURT6qQpddKUOmlKnTSlTppSJ02pk6bUSVPqoil10ZS6aEpdNKUumlIXTamLptRFU+qiKXXRlLppSt00pW6aUjdNqZum1P0aSj2e6+np8c5nZ7TgjBGcsV7ljL2/nhH2/Iz9558xl+AME5zhgjPiz/93NSk4Q9Dn04K/jxGcIejzEfT5EvT5EvT5EvT5EvT5EvT5EvT5EszzJZjnS9DnS9DnW9DnW9DnW9DnOwRnpOCMEpwhmOdb0Od7Cc7Yf/oZdl2X4hBTHPLnt/p9SCgOScUhpTikFYeM4pClOGQLDrFLcYii480Vh4TikFQcUopDFB1vio43RcebouNd0fFuikMUM94VM94VM94VHe+tOGQUhyzFIYpbfSg6PhQdH4qOD0XHh6LjQ3GrD8WMD8WMD8WMD0XHp+JzfCpu9am41afiVp+Kjk9Fx6ei41PR8ano+FTc6ksx40sx40sx40vR8ZWKQxS3+lLc6ktxqy9Fx5ei41vR8a3o+FZ0fCtu9Z2KQxQzvhUzvhUd34rP8a241Y/iVj+KW/0oOn4UHT+Kjh9Fx4+i40dxqx/FjB/FjF+KGb8UHb8Un+OX4lYvMNndhyhu9UvR8UvR8UvR8UvR8VvR8Vtxq9+KGb8VM15gt7sPUXT8VnyO34pb/Vbc6hWeO7sEHW+XKQ5xxSGhOCQVh5TikFYcMopDluIQRcfbpTjEFIe44pBQHKLoeFN0vMJzZwrPnSk8d6bw3JnCc2cKz50pPHfmio5/Jc/dC4eU4pBWHDKKQxQd74qOV3juTOG5M4XnzhSeO1N47kzhuTOF585C0fGxFIcobvUKz50pPHeWio5PRccrPHem8NyZwnNnCs+dKTx3pvDcmcJzZ6Xo+FJ8jld47kzhuTOF585K0fGl6HiF584UnjtTeO5M4bkzhefOFJ47U3jurBUd34rP8QrPnSk8d6bw3NkoOn4UHa/w3JnCc2cKz50pPHem8NyZwnNnCs+djaLjl+JzvMJzZwrPnSk8d7YUHb8UHa/w3JnCc2cKz50pPHem8NyZwnNnCs+dbUXHv5Ln7oVDFLd6hefOFJ4724qO34KOd4XnzhWeO1d47lzhufMrFYeU4pBWHCLoeL+W4hDBrd4VnjtXeO7cFB1vio5XeO5c4blzhefOFZ47V3juXOG5c4Xnzl3R8e6KQ0JxSCoOKcUhio53RccrPHeu8Ny5wnPnCs+dKzx3rvDcucJz56Ho+GjFIYpbvcJz5wrPnaei41PR8QrPnSs8d67w3LnCc+cKz50rPHeu8Nx5Kjq+FJ/jFZ47V3juXOG581J0fCk6XuG5c4XnzhWeO1d47lzhuXOF584VnjtvRce/kufuhUMUt3qF584VnjtvRce3ouMVnjtXeO5c4blzhefOFZ47V3juXOG581F0/Cg+xys8d67w3LnCc+dL0fFL0fEKz50rPHeu8Ny5wnPnCs+dKzx3rvDc+VZ0/FZ8jld47lzhuXOF5863ouO3ouMVnjtXeO5C4bkLhecuFJ67UHju4krFIYKOj6sVh4zikKU4RHCrD0W2bJii4xWeu1B47kLhuQuF5y4UnrtQeO5C4bkLU3S8X4pDTHGIKw4JxSGKjndFxys8d6Hw3IXCcxcKz10oPHeh8NyFwnMXoej4V/LcvXCI4lav8NyFwnMXimzZCEXHKzx3ofDchcJzFwrPXSg8d6Hw3IXCcxep6PhUfI5XeO5C4bkLhecuFNmyUYqOV3juQuG5C4XnLhSeu1B47kLhuQuF5y5a0fGt+Byv8NyFwnMXCs9dKLJlQ+G5C8X/cxeK/+cuFNmyociWDYXnLkbR8aPo+FF0/Cg+xys8d6H4f+5CkS0bimzZWIrP8a/juUuvr4ekz/ND/kvHZ/i/Dinz/32I11xf/3ndP44XHu992dPTve0PNT1/eHnm08PL25+/QJ7+AnX6C/TpLzCnv8A6/QX24S/w33yf57yAnf4CfvoLnD6J9+mTeJ8+iffpk3ifPon36ZN4Hz6J8zp8Eud1+CTO6/BJnNfhkzivwydxXodP4rwOn8R5HT6J8zp8Eud1+iS20yexnT6J7fRJbKdPYjt9Etvpk9hOn8T2gEn8wrcL0xawps2rya9H1PQ/v62YbsCaHFhTAGtKYE0F7LsG1gTUcV/Af0+bV1MAdTyAOh5AHQ+gjgdQxwOo4wHU8QDqeADv4wG8jydQxxOo4wnU8QTqeAJ1PAtYUwNrGmBNwPt4AnW8LmBNBqzJgTUFsCagjhdQxwuo4wXU8QLqeAH3Kg28jzfwPt7A+3gDdbwTWBNwr9LAvUoD9yoN1PEG6vgAdXyAOj5AHR/gXmWA9/EB3scHeB8foI4PcD8+wL3KAu5VFnCvsoA6voA6voA6voA6voA6voB7lQW8jy/gfXwD7+MbqOMbuB/fwL3KTmBNwL3KBur4Bur4Bur45ul4XTwdr4u3V6mLdx+vi3cfr4t3H6+Lp+N18fbjdfH2KnXx9ip18fYqZUAdN6COG1DHDajjBtRx4+1Vynj38TLefbyMdx8vIM9ZztuPl/P2KuW8vUo5b69SQJ6zHKjjDtRxB+o4kOcsIM9ZQJ6zgDxnAXnOCqCOP4bnfKEm4F4FyHMWkOesAOp4AHUcyHMWkOcsIM9ZQJ6zgDxnAXnOAvKclUAdT+B+HMhzFpDnLCDPWQXU8QLqOJDnLCDPWUCes4A8ZwF5zgLynAXkOauBOt7A/TiQ5ywgz1lAnrMaqOMN1HEgz1lAnrOAPGcBec4C8pwF5DkLyHPWAHV8gPtxIM9ZQJ6zgDxnLaCOL6COA3nOAvKcBeQ5C8hzFpDnLCDPWUCesxZQxzdwPw7kOQvIcxaQ56wN1PEN1HEgz1lAnrOAPGcBec4G8pwN5DkbyHP2xdPxvhJYE2+v0kCes4E8Z188He8LqONAnrOBPGcDec4G8pwN5DkbyHM2kOdsYD5nA/M5G8hzNpDnbCDP2cB8zgbmczaQ52wgz9lAnrOBPGcDec4G8pwN5Dk7gDoevP14A3nOBvKcDeQ5O4A6HkAdB/KcDeQ5G8hzNpDnbCDP2UCes4E8ZydQxxO4HwfynA3kORvIc3YBdbyAOg7kORvIczaQ52wgz9lAnrOBPGcDec4uoI43cD8O5DkbyHM2kOfsBup4A3UcyHM2kOdsIM/ZQJ6zgTxnA3nOBvKcPUAdfwzP+UJNwL0KkOdsIM/ZA9TxAeo4kOdsIM/ZQJ6zgTxnA3nOBvKcDeQ5ewF1fAH340Ces4E8ZwN5zt5AHd9AHQfynA3kORvIczaQ52wgz9lAnnOAPOdcPB2fi7cfHyDPOVcCa+LtVebi6fhcPB0fIM85QJ5zgDznAHnOAfKcA+Q5B8hzjgF13Hj78QHynAPkOQfIc44DddyBOg7kOQfIcw6Q5xwgzzlAnnOAPOcAec5xoI4Hbz8+QJ5zgDznAHnOCaCOB1DHgTznAHnOAfKcA+Q5B8hzDpDnHCDPOQnU8cfwnC/UBNyrAHnOAfKck0AdT6COA3nOAfKcA+Q5B8hzDpDnHCDPOUCecwqo4wXcjwN5zgHynAPkOaeBOt5AHQfynAPkOQfIcw6Q5xwgzzlAnnOAPOcMUMcHuB8H8pwD5DkHyHPOAHV8gDoO5DkHyHMOkOccIM85QJ5zgDznAHnOWUAdX8D9OJDnHCDPOUCeczZQxzdQx4E85wB5zgHynAPkOQfIcw6Q5xwgzzmbp+Pr4u3HF5DnXECecwF5znXxdHxdPB1fQJ5zAXnOBeQ5F5DnXECecwF5zgXkOZcBdfwxPOcLNfH2KgvIcy4gz7kMqONAnnMB8zkXMJ9zOfA+7kAdB/Kcy4E67kAdd6COO28/voA85wLmc64A3scDeB8P3n58PYTnTK+vNaXP85oeoOO9L3t6urf9oabnD9/TL58evgXen79An/4Cc/oLrNNfYB/+Ao8AVl/3Bez0F/DTXyBOf4E8/QVOn8R5+iTO0ydxnj6J8/RJXKdP4jp9Etfpk7hOn8SPwKRf9wVOn8R1+iSu0ydxnT6J6/RJ3KdP4j59Evfpk7hPn8SPAN1f9wVOn8R9+iTu0ydxnz6JG/id0QE6XIAk/wImM68Bfmf0MST/CzUBHedAkn8Bk5nXAB0uA9RxIMm/gCT/ApL8C0jyLyDJv4DJzAuYzLyAJP8CkvwLSPIvYDLzAiYzLyDJv4Ak/wKS/AtI8i8gyb+AJP8CkvwLmMy8gcnMG0jybyDJv4Ek/74SWBOPHNpAkn8DSf4NJPk3kOTfQJJ/A0n+DST5NzCZeQOTmTeQ5N9Akn8DSf4NTGbeQJJ/A5OZNzCZeQOTmTcwmXkDSf4NTGbewGTmDUxm3sBk5g0k+TcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQOTmTcwmXkDk5k3MJl5A5OZNzCZeQN5zg1MZt7AZOYNTGbewGTmDeQ5NzCZeQOTmTcwmXkDec4N5Dk3kOfcQJ5zA3nODUxm3sBk5g3kOTeQ59xAnnMDk5k3MJl5A3nODeQ5N5Dn3ECecwN5zg3kOTeQ59y8ZGa/eMnMd024vcpdE26vcteE26vcNeF0/K4Jp+N3TTgdv2vC6fhdE07H75pwexW/eDznXRPuPn7XhLuP3zUBdZyXzHzXhNur3DXh9ip3Tbi9yl0TUMcNqOM8nvOuCajjPJ7zrgm3V7lrAt7HeTznXRPwPs5LZr5rwu3H75qAexUez3nXBNyr8JKZ75qAOs7jOe+agDrO4znvmoB7FR7PedcEvI/zeM67JqCOJ3A/zuM575oSWBNwr5JAHU+gjvN4zrsmoI7zeM67JuBehcdz3jUB7+M8nvOuCajjBdyP83jOuybgXoXHc/rVQB1voI7zeM67JqCO83jOuybgXoXHc941Ae/jPJ7zrgmo47x8zrsm4F6Fx3PeNQH3Krx8zrsmoI7zeM67JqCO83jOuybgXoXHc941Ae/jPJ7zrgmo44/hOV+oCbhX4fGcd03AvcoC6vgC6jiP57xrAuo4j+e8awLuVXg8510T8D7O4znvmoA6voH7cSDPaUCe04A8p108HbeLp+N28XTcgDynAXlOA/KcBuQ5DchzGpDnNAPquPH24wbkOQ3IcxqQ5zQD6rgBdRzIcxqQ5zQgz2lAntOAPKcBeU4D8pzmQB133n7cgDynAXlOA/KcFkAdD6COA3lOA/KcBuQ5DchzGpDnNCDPaUCe0wKo4wncjwN5TgPynAbkOS2BOp5AHQfynAbkOQ3IcxqQ5zQgz2lAntOAPKcVUMcfw3O+UBNwrwLkOQ3Ic1oBdbyAOg7kOQ3IcxqQ5zQgz2lAntOAPKcBeU5roI43cD8O5DkNyHMakOe0Aer4AHUcyHMakOc0IM9pQJ7TgDynAXlOA/KctoA6voD7cSDPaUCe04A8py2gji+gjgN5TgPynAbkOQ3IcxqQ5zQgz2lAntM2UMc3cD8O5DkNyHMakOf0i6fjfvF03IE8pwN5Tr94Ou5AntOBPKcDeU4H8px+AXXcePtxB/KcDuQ5HchzugF13IA6DuQ5HchzOpDndCDP6UCe04E8pwN5Tnegjj+G53yhJt5exYE8pwN5TnegjjtQx4E8pwN5TgfynA7kOR3IczqQ53Qgz+kB1PHg7ccdyHM6kOd0IM/pCdTxBOo4kOd0IM/pQJ7TgTynA3lOB/KcDuQ5vYA6XsD9OJDndCDP6UCe0wuo4wXUcSDP6UCe04E8pwN5TgfynA7kOR3Ic3oDdbyB+3Egz+lAntOBPKcPUMeBPKcD8zkdmM/pj+E5X6gJqONAntMHqOMD1PEB6vgC7seBPKcD8zl9Ae/jj+E5X6gJuB9/CM+ZXl9rSp/nNT1Ax3tf9vR0b/tDTc8fXve3X54eXvcn5OcvsE5/gX34CzwCK33dF7DTX8BPf4E4/QXy9Beo01+gT3+B0yfxPn0S78MncVyHT+K4Dp/EcR0+ieM6fBLHdfgkjuvwSRzX4ZM4rsMncVyHT+K4Tp/EdvokttMnsZ0+ie30SfwIHP11X+D0SWynT2I7fRLb6ZPYTp/Efvokdt53RsN5DpcAkvwBTGYO531nNJzncAnnOc4DSPIHMJk5gudwiQDqOJDkDyDJH0CSP4AkfwBJ/gAmMwcwmTmAJH8ASf4AkvwBTGYOYDJzAEn+AJL8AST5A0jyB5DkDyDJH0CSP4DJzAFMZg4gyR9Akj+AJH8Ak5kDmMwcQJI/gCR/AEn+AJL8AST5A0jyB5DkD2AycwCTmQNI8geQ5A8gyR/AZOYAkvwBTGYOYDJzAJOZA5jMHECSP4DJzAFMZg5gMnMAk5kDSPIHMJk5gMnMAUxmDmAycwCTmQOYzBzAZOYAJjMHMJk5gMnMAUxmDmAycwCTmQOYzBzAZOYAJjMHMJk5gMnMCUxmTmAycwKTmROYzJwXT8cTmMycwGTmBCYzJzCZOYHJzAlMZk5gMnMCk5kTmMycwGTmBCYzJzCZOYHJzAlMZk5gMnMCk5kTmMycwGTmBPKcCUxmTmAycwKTmROYzJxAnjOBycwJTGZOYDJzAnnOBPKcCeQ5E8hzJpDnTGAycwKTmRPIcyaQ50wgz5nAZOYEJjMnkOdMIM+ZQJ4zgTxnAnnOBPKcCeQ5E5jMnMBk5gTynAnkORPIcyYwmTmBycwJ5DkTyHMmkOdMIM+ZQJ4zgTxnAnnOBCYzJzCZOYE8ZwJ5zgTynAlMZs4B6jiQ50wgz5lAnjOBPGcCec4E8pwJ5DkTmMycwGTmBPKcCeQ5E8hzJjCZOYHJzAnkORPIcyaQ50wgz5lAnjOBPGcCec7cQB1/DM/5Qk3AvQqQ50wgz5kbqOObp+MF5DkLyHMWkOcsIM9ZF+8+XkCes4A8Z108Ha+Ltx8vIM9ZQJ6zgDxnGVDHDajjQJ6zgDxnAXnOAvKcBeQ5C8hzFpDnLGA+ZwHzOQvIcxaQ5ywgz1nAfM4C5nMWkOcsIM9ZQJ6zgDxnAXnOAvKcBeQ5K4A6Hrz9eAF5zgLynAXkOSuBOp5AHQfynAXkOQvIcxaQ5ywgz1lAnrOAPGclUMcLuB8H8pwF5DkLyHNWAXW8gDoO5DkLyHMWkOcsIM9ZQJ6zgDxnAXnOaqCOP4bnfKEm4F4FyHMWkOesBup4A3UcyHMWkOcsIM9ZQJ6zgDxnAXnOAvKcNUAdH+B+HMhzFpDnLCDPWQuo4wuo40Ces4A8ZwF5zgLynAXkOQvIcxaQ56wN1PEN3I8Dec4C8pwF5DlrA3V8A3UcyHMWkOdsIM/ZQJ6zgTxnA3nOvnj38b54Ot4Xbz/eQJ6zgTxnA3nONqCOG1DHgTxnA3nOBvKcDeQ5G8hzNpDnbCDP2QbUceftxxvIczaQ52wgz9kO1HEH6jiQ52wgz9lAnrOBPGcDec4G8pwN5Dk7gDr+GJ7zhZqAexUgz9lAnrMDqOMB1HEgz9lAnrOBPGcDec4G8pwN5DkbyHN2AnU8gftxIM/ZQJ6zgTxnF1DHC6jjQJ6zgTxnA3nOBvKcDeQ5G8hzNpDn7AbqeAP340Ces4E8ZwN5zm6gjjdQx4E8ZwN5zgbynA3kORvIczaQ52wgz9kD1PEB7seBPGcDec4G8py9gDq+gDoO5DkbyHM2kOdsIM/ZQJ6zgTxnA3nOXkAd38D9OJDnbCDP2UCeszdQxzdQx4E8ZwN5zgbynA3kOQfIcw6Q5xwgzzkXT8fnSmBNvL3KAHnOAfKcc/F0fC6gjgN5zgHynAPkOQfIcw6Q5xwgzzlAnnMMqOPG248PkOccIM85QJ5zHKjjQJ5zgPmcA8znHAfexx2o40Cecxyo4wHU8QDqePD24wPkOQeYzzkBvI8H8D4evP34PITnTK+vNaXP85peRcc7/eub/4aq/eHxv9xffPf5/YcP7//21w+fvn/75f2njz/fv/n+6f9/+/n92+8+vHv68sdfPn7/b7/65e8/ff2Vr7//p8+fvn/3wy+f3/32J/3+a/cf/08=","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"68":{"source":"mod common;\nmod action;\nuse action::{ new_action, parse_actions, serialize_actions };\nuse action::execute_action;\nmod character;\nuse character::{ Character, get_test_action_register };\nuse character::parse_characters;\nmod event;\npub use event::Event;\nmod obstacle;\nuse obstacle::Obstacle;\npub use obstacle::{ new_obstacle, parse_my_obstacles, parse_their_obstacles, get_obstacle_x, get_obstacle_y, get_obstacle_id, get_obstacle_type, get_obstacle_health, serialize_my_obstacles, get_default_obstacles };\nmod map;\nuse dep::std;\nuse obstacle::serialize_obstacle;\nuse obstacle::serialize_their_obstacles;\n// use action::ACTION_TARGET_X;\n// use action::ACTION_TARGET_Y;\n// use action::ACTION_TYPE;\nuse action::get_action_target_y;\nuse action::get_action_target_x;\nuse action::get_action_type;\nmod actionDefinition;\nuse actionDefinition::{ ActionDefinitionRegister };\npub use actionDefinition::ACTION_DEFINITION_REGISTER_SIZE;\nuse obstacle::serialize_my_obstacles_for_me;\nuse map::is_visible;\n\nmod ResolvedAction;\n\n\n\n// #[export]\n// pub fn ext_can_move_to(x: u8, y: u8, obstacles: [Obstacle; MAX_OBSTACLES], their_obstacles: [Obstacle]) -> bool {\n//     assert(MAX_OBSTACLES == 24);\n//     let mut my_obstacles_parsed = Obstacle::parse_my_obstacles(my_obstacles, events).as_array();\n//     // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n//     // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n//     let enemy_objects_parsed = Obstacle::parse_their_obstacles(enemy_objects);\n\n//     let mut can = true;\n//     for i in 0..MAX_OBSTACLES {\n//         if !obstacles[i].is_traversible() & (obstacles[i].x == x) & (obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     for i in 0..their_obstacles.len() {\n//         if !their_obstacles[i].is_traversible() & (their_obstacles[i].x == x) & (their_obstacles[i].y == y) {\n//             can = false;\n//         }\n//     }\n//     can\n// }\n\npub comptime global DEBUG: bool = false;\npub comptime fn debug(stmt: Quoted) -> Quoted {\n    let debug_result = if DEBUG {\n        stmt\n    } else { quote {} };\n    debug_result\n}\npub comptime fn debugmsg<T>(msg: T) -> Quoted {\n    debug!(quote { println($msg); })\n}\npub comptime fn softassert(varname: Quoted, check: Quoted, msg: Quoted) -> Quoted {\n    let result = if DEBUG {\n        quote {\n            $varname &= $check;\n            if !($check) {\n                println($msg);\n            }\n        }\n    } else {\n        quote {\n            $varname &= $check;\n        }\n    };\n    result\n}\n\n// MAP\nglobal WIDTH_BITS: u8 = 5;\nglobal WIDTH_MASK: u8 = (1 << WIDTH_BITS) - 1;\nglobal WIDTH: u8 = 1 << WIDTH_BITS;\nglobal HEIGHT_BITS: u8 = 4;\nglobal HEIGHT_MASK: u8 = (1 << HEIGHT_BITS) - 1;\nglobal HEIGHT: u8 = 10;\nglobal NOWHERE: u8 = 255;\n\n// CLASSES\n//global UNKNOWN_CLASS: u8 = 0;\nglobal ARCHER: u8 = 1;\nglobal RITUALIST: u8 = 2;\nglobal ROGUE: u8 = 3;\nglobal KNIGHT: u8 = 4;\nglobal MAGE: u8 = 5;\nglobal CLASS_BITS: u8 = 3;\nglobal CLASS_MASK: u8 = (1 << CLASS_BITS) - 1;\nglobal CLASS_COUNT: u32 = 6;\nglobal MAX_ACTIONS_PER_CHARACTER: u32 = 7;\n\n// ACTIONS\nglobal WAIT: u8 = 0;\n//global SNEAK: u8 = 1;\n//global MOVE: u8 = 2;          // => SEE_COLUMN (depr: MOVE)\n//global RITUAL: u8 = 3;        // => SEE_RITUAL | WIN\n//global SEARCH: u8 = 4;        // => SEE_SEARCH_TRAP\n//global ATTACK: u8 = 5;        // => RECEIVE_ATTACK | DESTROY // affects my obstacles; TODO: with more attack types might also affect other own characters\n//global CAST: u8 = 6;          // => SEE_CAST // affects my obstacles; TODO: with more attack types might also affect other own characters\n//global CAST_FIREBALL: u8 = 7; // => RECEIVE_ATTACK // affects other characters if status == FIREBALL_ROUNDS_FOR_CAST\n//global DRAW: u8 = 8;          // => SEE_DRAW\n//global SHOOT: u8 = 9;         // => RECEIVE_ATTACK\n//global TRIGGER_TRAP = 9;  // => TRIGGERED_TRAP ?????????\n//global DISARM_TRAP: u8 = 10;  // => DESTROY\n//global SET_TRAP: u8 = 11;\nglobal ACTION_COUNT: u32 = 12;\n\n// EVENTS\nglobal NO_EVENT: u8 = 0 ;\n// global DESTROY: u8 = 1;          // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //use coordinates to determine tile or trap that got destroyed and update map\n//global DISCOVER = 2;         // actor_id = their_char or their_object when receive - handle to update enemy positions, got health & class (this is for all chars, not just the active one)\n//global SEE_COLUMN = 2 ;      // y = the column the player sees => update objects list\nglobal SEE_MOVE: u8 = 3 ;        // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client //handle to update enemy positions => DISCOVER\n//global SEE_SPELL = 4 ;       // actor_id = their_char when receive - need to handle effect via coordinates, => RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle my obstacles\nglobal SEE_SEARCH_TRAP: u8 = 5 ; // actor_id = their_char when receive - need to create found trap event if there is a trap nearby => FOUND_TRAP\n// global SEE_RITUAL: u8 = 6 ;      // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\nglobal SEE_CAST: u8 = 7;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\nglobal SEE_DRAW: u8 = 8;         // actor_id = their_char when receive - no need to handle, only important to have on-chain for the client\n//global RECEIVE_DAMAGE = 9;   // actor_id = their_char or their_object when receive - no need to handle, only important to have on-chain for the client\nglobal RECEIVE_ATTACK: u8 = 10;  // actor_id = 0 when receive - need to handle damage => // no need to events ... health of visible assets gets sent anyway and invisible ones will be updated during discovery //RECEIVE_DAMAGE | DESTROY | LOSE // also need to handle in my obstacles\nglobal TRIGGERED_TRAP: u8 = 11;  // actor_id = my_char when receive - need to handle damage (for now, later on we might want to handle other effects as well) => RECEIVE_DAMAGE\n// global FOUND_TRAP: u8 = 12;      // actor_id = my_char when receive - no need to handle, only important to have on-chain for the client\nglobal DISARMED_TRAP: u8 = 13;      // actor_id = their-char when receive - need to remove my trap from the map\nglobal WIN: u8 = 14;\n// global LOSE: u8 = 15;\nglobal ADD_OBSTACLE: u8 = 4;\nglobal EVENT_COUNT: u8 = 16;\n\n// SUBTYPES:\nglobal WIN_BY_RITUAL: u8 = 1;\n\n// ATTACKS\nglobal ATTACK_MELEE: u8 = 0;\nglobal ATTACK_RANGED: u8 = 1;\nglobal ATTACK_FIREBALL: u8 = 2;\n// global ATTACK_COUNT: u8 = 3;\n// TODO: instead of enum, use a global array of structs with damage, range, etc.\n\n\n// TILES\nglobal EMPTY: u8 = 0;\nglobal WALL: u8 = 6;\nglobal WATER: u8 = 7;\n// global UNKNOWN_CLASS_TILE: u8 = 8;\nglobal NON_EMPTY_WALKABLE_TILE_MIN: u8 = 9;\n// global FLAG: u8 = 9;\nglobal TRAP: u8 = 10;\n// global TRAP_USED: u8 = 11;\n// global TRAP_FOUND: u8 = 12;\n// global BODY: u8 = 13;\n// global BODY_LOOTED: u8 = 14;\n// global FOG: u8 = 15;\nglobal MAX_OBSTACLE_TYPE: u8 = 0x0f;\n// global TILE_COUNT: u8 = 16;\n// unknown_class, flag, trap, trap_used, trap_found, body, body_looted, fog\n// STATUS\nglobal RITUAL_ROUNDS_FOR_WIN: u8 = 15;\nglobal MIN_FIREBALL_ROUNDS_FOR_CAST: u8 = 3;\nglobal MAX_FIREBALL_ROUNDS_FOR_CAST: u8 = 6;\n// global DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\nglobal MIN_DRAW_ROUNDS_FOR_SHOOT: u8 = 1;\nglobal MAX_DRAW_ROUNDS_FOR_SHOOT: u8 = 3;\nglobal STATUS_BITS: u8 = 4;\nglobal STATUS_MASK: u8 = (1 << STATUS_BITS) - 1;\nglobal STATUS_COUNT: u8 = 16 ; // just to be more in line with the other constants, actually used as a counter\nglobal MAX_HEALTH: u8 = 255;\n\n// GAMEPLAY\nglobal VIEW_DISTANCE: u8 = 6;\n// global MAX_TRAPS: u32 = 8; // note: only lowest bit of first byte of field is usable! => ! Field = 1 bit + 31 bytes!\n// global TRAPS_BUFFER_SIZE: Field = 16;\n// global TRAPS_BUFFER_MASK: Field = 15; // has to be 2^n - 1\nglobal MAX_ACTIONS: u32 = 4;\nglobal MAX_EVENTS: u32 = 4; // = MAX_ACTIONS // NO! handle traps in a different way (by passing as argument!)+ 4 (2 FOUND_TRAP + WIN/LOSE + 1 reserved)\nglobal MAX_OBSTACLES: u32 = 24; // leave traps for now + MAX_TRAPS; // 24 + 8 player placeables\npub global MAX_CHARACTERS: u32 = 5;\npub global MAX_STATUS: u8 = STATUS_COUNT - 1;\nglobal SERIALIZED_OBSTACLE_BYTE_SIZE: u32 = 3;//3\npub global SERIALIZED_OBSTACLES_ARRAY_SIZE: u32 = 3;//3 // TODO: we take 3 because 3 x 8 = MAX_OBSTACLES ... should assert on this (MAX_OBSTACLES + MAX_CHARACTERS + 7) / 8;\npub global SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE: u32 = SERIALIZED_OBSTACLES_ARRAY_SIZE + 1; // +1 because enemy characters are also serialized as obstacles\nglobal SERIALIZED_OBSTACLES_PER_FIELD: u32 = 8;//8 // TODO: need to verify that SERIALIZED_OBSTACLES_ARRAY_SIZE * SERIALIZED_OBSTACLES_PER_FIELD = MAX_OBSTACLES!\nglobal SERIALIZED_EVENT_BYTE_SIZE: u32 = 7;\npub global SERIALIZED_EVENTS_ARRAY_SIZE: u32 = 1; // MAX_EVENTS / SERIALIZED_EVENTS_PER_FIELD => 4 / 4 = 1\nglobal SERIALIZED_EVENTS_PER_FIELD: u32 = 4; // 31 / 7 = 4\nglobal SERIALIZED_ACTION_BYTE_SIZE: u32 = 5;\npub global SERIALIZED_ACTIONS_ARRAY_SIZE: u32 = 1;\nglobal SERIALIZED_ACTIONS_PER_FIELD: u32 = 4; // could be up to 6, but we only use 4\nglobal UNREADABLE_BYTES_PER_FIELD: u32 = 1;\n\n// #[export]\n// fn tf(x: Field) -> (u32, [u8;32]) {\n//     let mut result: [u8;32] = [0;32];\n//     let bts = x.to_be_bytes::<32>();\n//     for j in 0..31 {\n//         result[j] = 2*j;//bts[j];\n//     }\n//     (32 , result)\n// }\n// i,\n// 20, 0 -> 25,\n// 25 -> 0, \n// x, 0, 0, d0,\n// x, 0, 0, 9d, 1, 0,\n// x, 0, 0, 1, 0, b4, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 91, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 23, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, d4, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, 66, 1, 0, 1, 1, \n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 50, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b9, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, c5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 55, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, b2, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, e8, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, de, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2a, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, cb, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 9b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 5c, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, a6, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 86, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, d5, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 38, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 2b, 1, 0, 1, 1,\n// x, 0, 0, 1, 0, 8e, 1, 0, 0, 1,\n// 0, 32, 1, 0, 1, 1, x, 0, 0, 1,\n// x, 0, 0, 1, x, 0, 0, 1, 0, 1, 1\n\n// i,\n// 20, 0, 1e -> 0, 0 -> 1e, 0\n// x, 0, 0, d0,\n// x, 0, 0, ba, 1, 0,\n// x, 0, 0, 1, 0, cf, 1, 0, 1, 1,\n\n#[export]\nfn get_actor_from_move(mut move: u32) -> u8 {\n    if (move % 2) == 1 {\n        move -= 1; //((move % 10) - 1) >> 1 // actually not needed ... but clearer this way\n    }\n    let single_digit: u32 = (move % 10 as u32) >> 1;\n    single_digit as u8\n}\n// 3, 1, 1, 1, 0, 1, 2, 0, 2, 8, 1, 0, 0, 1\n// 4, 2, 2, 0, x, 0, 0, 0, 4, a, 2, 0, 0, 2\n\n#[export]\npub fn hash_match(my_chars: Field, my_char_actions: [u8; ACTION_DEFINITION_REGISTER_SIZE], my_obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE], secret_be_bytes: [u8; 32]) -> Field {\n    let my_chars_be_bytes: [u8; 32] = my_chars.to_be_bytes::<32>();\n    assert(my_chars_be_bytes.len() == 32);\n    let gamestate_before_hash_calculated = get_data_hash(secret_be_bytes, my_chars_be_bytes, my_char_actions, my_obstacles);\n    let gamestate_before_hash_calculated_field = std::field::bytes32_to_field(gamestate_before_hash_calculated);\n    gamestate_before_hash_calculated_field\n}\n\n#[export]\nfn get_serialized_obstacle(id: u8, x: u8, y: u8, obstacle_type: u8) -> Field {\n    let mut result: [u8; 32] = [0; 32];\n    result[0] = id;\n    result[1] = x;\n    result[2] = y;\n    result[3] = obstacle_type;\n    std::field::bytes32_to_field(result)\n}\n\n#[export]\npub fn calculate_turn(\n    my_chars_input: Field,\n    my_char_actions_input: [u8; ACTION_DEFINITION_REGISTER_SIZE],\n    my_obstacles_input: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE],\n    //mut my_obstacles_parsed: [[u8; 5]; 24],\n    actions_input: [Field; SERIALIZED_ACTIONS_ARRAY_SIZE],\n    // Common Inputs\n    move_input: u32, //pub\n    // Enemy Inputs\n    enemy_advance_input: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects_input: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE], // pub\n    enemy_events_input: [Field; SERIALIZED_EVENTS_ARRAY_SIZE], // pub //MAX_EVENTS],\n\n) -> (bool, Field, [u8; ACTION_DEFINITION_REGISTER_SIZE], [[u8; 5];24], u8, [Field; SERIALIZED_EVENTS_ARRAY_SIZE], [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE]) {\n    let mut success = true;\n\n    let actionRegister = ActionDefinitionRegister::new(my_char_actions_input);\n    // calculate enemy advance in our coordinates and shadow\n    // let (enemy_advance_valid, enemy_advance) = their_x_to_mine(enemy_advance);\n    let enemy_advance = if enemy_advance_input >= WIDTH { 0 } else { WIDTH - enemy_advance_input - 1 };\n\n\n    // TODO: Validate map => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    let (events_valid, events) = Event::parse_their_events(enemy_events_input);\n    softassert!(quote { success }, quote { events_valid }, quote { f\"Failed to parse their events {events}\" });\n\n    // let side = move as u1;\n    let (my_chars_valid, mut my_chars) = parse_characters(my_chars_input, events, enemy_advance);\n    softassert!(quote { success }, quote { my_chars_valid }, quote { f\"Failed to parse my characters {my_chars}\" });\n\n    let actor_id = get_actor_from_move(move_input);\n    let mut actor = my_chars[actor_id]; //Character::parse(actor_id, my_chars, events);\n    \n    let actions = parse_actions(actions_input); // actions.map(|action| Action::from_field(action));\n    \n    comptime {\n        assert(MAX_OBSTACLES == 24);\n    }\n\n    let (valid, my_obstacles_parsed) = parse_my_obstacles(my_obstacles_input, events);\n    softassert!(quote { success }, quote { valid }, quote { f\"Failed to parse my obstacles {my_obstacles_input}\" });\n    let mut my_obstacles_parsed: [Obstacle; MAX_OBSTACLES] = my_obstacles_parsed.as_array();\n\n    // let mut my_obstacles_parsed = my_obstacles_parsed.as_array();\n//    let (valid, mut my_obstacles_parsed) = parse_my_obstacles(my_obstacles, events).as_array();\n    // TODO: validate obstacles => check that initial setup is ok => unique ids and no coordination overlaps!\n\n    // Note: no need to validate enemy obstacles => opponent proof verifies that they are correct already!\n    let (enemy_objects_parsed_valid, enemy_objects_parsed) = parse_their_obstacles(enemy_objects_input);\n    softassert!(quote { success }, quote { enemy_objects_parsed_valid }, quote { f\"Failed to parse their obstacles {enemy_objects_input}\" });\n\n    let mut energy: u8 = 12;\n    let mut result_events_calculated: [Event] = &[];\n    for i in 0..MAX_ACTIONS {\n        // TODO: ensure that if actor committed suicide, it is not allowed to do any more actions\n        let action = actions[i];\n        let resolved_action = actionRegister.resolve_action(action); //resolve_action(action);\n        let result = execute_action(resolved_action, enemy_advance, actor, energy, my_obstacles_parsed, enemy_objects_parsed);\n        //assert(result.0);\n        success &= result.0;\n        let result_event = result.1;\n        let internal_event = result.2;\n        actor = result.3;\n        energy = result.4;\n        \n        // 4461 / 5 = 892,2\n        my_chars = my_chars.map(|c| wb_apply_damage_to_char(c, result_event, actor));\n        // 16800 / 24 = 700\n        my_obstacles_parsed = my_obstacles_parsed.map(|obstacle| {\n            let (updated_obstacle_valid, updated_obstacle) = update_my_obstacle(obstacle, result_event);\n            //success = success & updated_obstacle_valid;\n            softassert!(quote { success }, quote { updated_obstacle_valid }, quote { f\"Failed to update my obstacle {obstacle}, {result_event}\" });\n            updated_obstacle\n        });\n\n        result_events_calculated = result_events_calculated.push_back(result_event);\n    }\n    let result_events_calculated = Event::serialize_events(result_events_calculated);\n    assert(result_events_calculated.len() == SERIALIZED_EVENTS_ARRAY_SIZE);\n\n    // send death events => no need\n\n    // determine view range\n    let mut my_advance_calculated = 0;\n    for i in 0..MAX_CHARACTERS {\n        if my_chars[i].x > my_advance_calculated {\n            my_advance_calculated = my_chars[i].x;\n        }\n    }\n    my_advance_calculated += VIEW_DISTANCE;\n\n    let serialized_characters = serialize_chars(my_chars);\n    let serialized_obstacles: [Field] = serialize_my_obstacles(enemy_advance, my_obstacles_parsed);\n    let (serialized_chars_as_obstacles_valid, serialized_chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance, my_chars);\n    // success = success & serialized_chars_as_obstacles_valid;\n    softassert!(quote { success }, quote { serialized_chars_as_obstacles_valid }, quote { f\"Failed to serialize chars as obstacles: {my_chars}\" });\n    let serialized_obstacles_for_enemy: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE] = serialized_obstacles.push_back(serialized_chars_as_obstacles).as_array();\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles_parsed);\n\n    (success, serialized_characters, my_char_actions_input, my_obstacles_parsed, my_advance_calculated, result_events_calculated.as_array(), serialized_obstacles_for_enemy)\n}\n\n#[export]\npub fn turn(\n    // verification_key: pub [Field; 114],\n    // proof: pub [Field; 93],\n    // public_inputs: pub [Field; 1 ],//+ 2 * SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE + 2 * SERIALIZED_EVENTS_ARRAY_SIZE],\n    // key_hash: pub Field,\n    // last_move: pub u32,\n    // last_enemy_advance: pub u8,\n    // last_enemy_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // last_events: pub [Field, SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_advance: pub u8,\n    // last_my_result_events: pub [Field; SERIALIZED_EVENTS_ARRAY_SIZE],\n    // last_my_result_objects: pub [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE],\n    // Gamestate Hashes\n    // gamestate_before_hash: pub Field,\n    // gamestate_after_hash: pub Field,\n    // My Secret State\n    secret: Field,\n    my_chars_input: Field,\n    //my_char_actions: [u8; ACTION_DEFINITION_REGISTER_SIZE],\n    my_obstacles_input: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE],\n    //my_obstacles: [[u8; 5]; 24],\n    actions: [Field; SERIALIZED_ACTIONS_ARRAY_SIZE],\n    // Common Inputs\n    move: u32, //pub\n    // Enemy Inputs\n    enemy_advance: u8, // pub // from enemy point of view => starting from 0\n    enemy_objects: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE], // pub\n    enemy_events: [Field; SERIALIZED_EVENTS_ARRAY_SIZE], // pub //MAX_EVENTS],\n    // My Results\n    my_result_advance: u8, // pub // 1 bit win, 1 bit lose, 1 bit reserved, 5 bits advance\n    my_result_events: [Field; SERIALIZED_EVENTS_ARRAY_SIZE], // pub\n    my_result_objects: [Field; SERIALIZED_ENEMY_OBSTACLES_ARRAY_SIZE], // pub\n    // Gamestate Hashes\n    gamestate_before_hash: Field, // pub\n    gamestate_after_hash: Field, // pub\n) -> pub bool {\n    // Validate global constants (to make sure one didn't change one without updating dependet ones)\n    comptime {\n        assert((SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLE_BYTE_SIZE) < 32);\n        assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE >= MAX_OBSTACLES);\n        assert(SERIALIZED_EVENTS_PER_FIELD * SERIALIZED_EVENTS_ARRAY_SIZE == MAX_EVENTS);\n        // assert(SERIALIZED_OBSTACLES_PER_FIELD * SERIALIZED_OBSTACLES_ARRAY_SIZE == MAX_OBSTACLES);\n    }\n\n    let my_char_actions = get_test_action_register();\n\n    let mut success = true;\n    let secret_be_bytes: [u8; 32] = secret.to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n\n    // let serialized_obstacles_for_me = serialize_my_obstacles_for_me(my_obstacles);\n    let gamestate_before_hash_calculated_field = hash_match(my_chars_input, my_char_actions, my_obstacles_input, secret_be_bytes);\n    // assert(gamestate_before_hash == gamestate_before_hash_calculated_field, f\"{gamestate_before_hash} != {gamestate_before_hash_calculated_field}\");\n    softassert!(quote { success }, quote { gamestate_before_hash == gamestate_before_hash_calculated_field }, quote { f\"Invalid pre-hash: {gamestate_before_hash} != {gamestate_before_hash_calculated_field}\" });\n    // std::verify_proof(verification_key, proof, public_inputs, key_hash);\n\n    let  (turn_calc_valid, serialized_characters, my_char_actions_after, serialized_obstacles, my_advance_calculated, result_events_calculated, serialized_obstacles_for_enemy) = calculate_turn(\n        my_chars_input,\n        my_char_actions,\n        my_obstacles_input,\n        actions,\n        move,\n        enemy_advance,\n        enemy_objects,\n        enemy_events\n    );\n    softassert!(quote { success }, quote { turn_calc_valid }, quote { f\"Tun calculation failed\" });\n\n    // if side == 0 {\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x > my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated += VIEW_DISTANCE;\n    // } else {\n    //     my_advance_calculated = WIDTH - 1;\n    //     for i in 0..MAX_CHARACTERS {\n    //         if my_chars[i].x < my_advance_calculated {\n    //             my_advance_calculated = my_chars[i].x;\n    //         }\n    //     }\n    //     my_advance_calculated -= VIEW_DISTANCE;\n    // }\n    softassert!(quote { success }, quote { my_result_advance == my_advance_calculated }, quote { f\"Invalid result advance: {my_advance} != {my_advance_calculated}\" });\n\n    // validate result\n    for i in 0..SERIALIZED_EVENTS_ARRAY_SIZE {\n        let result_event_calculated = result_events_calculated[i];\n        let result_event_should = my_result_events[i];\n        softassert!(quote { success }, quote { result_event_should == result_event_calculated }, quote { f\"Invalid result event {i}: {result_event_should} != {result_event_calculated}\" });\n    }\n    // assert(serialized_obstacles.len() == SERIALIZED_OBSTACLES_ARRAY_SIZE);\n    let serialized_characters_be_bytes: [u8; 32] = serialized_characters.to_be_bytes::<32>();\n    assert(serialized_characters_be_bytes.len() == 32);\n    debug!(quote {\n        println(f\"serialized_obstacles: {serialized_obstacles}\");\n        println(f\"serialized_obstacles_for_enemy: {serialized_obstacles_for_enemy}\");\n        println(f\"serialized_characters: {serialized_characters}\");\n        println(f\"serialized_characters_be_bytes: {serialized_characters_be_bytes}\");\n    });\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(serialized_obstacles);\n    let new_hash_bytes = get_data_hash(secret_be_bytes, serialized_characters_be_bytes, my_char_actions_after, my_obstacles_serialized_for_me);\n    let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n    for i in 0..my_result_objects.len() {\n        let my_result_object = my_result_objects[i];\n        let serialized_obstacle = serialized_obstacles_for_enemy[i];\n        softassert!(quote { success }, quote { my_result_object == serialized_obstacle }, quote { f\"Invalid result obstacle row {i}: {my_result_object} != {serialized_obstacle}\" });\n    }\n    softassert!(quote { success }, quote { new_hash == gamestate_after_hash }, quote { f\"Invalid result hash: {new_hash} != {gamestate_after_hash}\" });\n    success\n}\n\nfn wb_apply_damage_to_char(mut c: Character, event: Event, actor: Character) -> Character {\n    if c.id == actor.id {\n        c = actor;\n    }\n    apply_damage_to_char(c, event)\n}\n\nfn apply_damage_to_char(c: Character, event: Event) -> Character {\n    let dmg = event.get_applied_damage_to_my_asset(c.x, c.y, c.class);\n    Character {\n        id: c.id,\n        x: c.x,\n        y: c.y,\n        class: c.class,\n        health: safe_subtract_dmg(c.health, dmg),\n        status: c.status,\n        target_x: c.target_x,\n        target_y: c.target_y,\n        has_been_seen: c.has_been_seen,\n        is_hidden: c.is_hidden,\n        damage_mod: c.damage_mod,\n        last_action: c.last_action,\n        actions: c.actions\n    }\n}\nfn update_my_obstacle(obstacle: Obstacle, event: Event) -> (bool, Obstacle) {\n    let dmg =\n        // event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle)) +\n        event.get_applied_damage_to_my_asset(get_obstacle_x(obstacle), get_obstacle_y(obstacle), get_obstacle_type(obstacle));\n    new_obstacle(get_obstacle_id(obstacle), get_obstacle_x(obstacle), get_obstacle_y(obstacle), safe_subtract_dmg(get_obstacle_health(obstacle), dmg), get_obstacle_type(obstacle))\n    // Obstacle {\n    //     health: safe_subtract_dmg(obstacle.health, dmg),\n    //     id: obstacle.id,\n    //     x: obstacle.x,\n    //     y: obstacle.y,\n    //     obstacle_type: obstacle.obstacle_type,\n    // }\n}\n\nfn get_data_hash(secret: [u8], characters: [u8], character_actions: [u8; ACTION_DEFINITION_REGISTER_SIZE], obstacles: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> [u8; 32] {\n    assert(secret.len() == 32);\n    assert(characters.len() == 32);\n\n    let mut data: [u8; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE] = [0; 32 + 32 + SERIALIZED_OBSTACLES_ARRAY_SIZE * 32 + ACTION_DEFINITION_REGISTER_SIZE];\n    for i in 0..32 {\n        data[i] = secret[i];\n        data[i + 32] = characters[i];\n    }\n    let offset = 32 + 32;\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        let obstacle: [u8; 32] = obstacles[i].to_be_bytes::<32>();\n        assert(obstacle.len() == 32);\n        for j in 0..32 {\n            data[offset + i * 32 + j] = obstacle[j];\n        }\n    }\n    let offset = 32 + 32 + 32 * SERIALIZED_OBSTACLES_ARRAY_SIZE;\n    for i in 0..ACTION_DEFINITION_REGISTER_SIZE {\n        data[offset + i] = character_actions[i];\n    }\n    // let offset = WIDTH * HEIGHT + 32 * 3;\n    // for i in 0..10 {\n    //     data[offset + i * 4] = (searched_traps[i] & 255) as u8;\n    //     data[offset + i * 4 + 1] = ((searched_traps[i] >> 8) & 255) as u8;\n    //     data[offset + i * 4 + 2] = ((searched_traps[i] >> 16) & 255) as u8;\n    //     data[offset + i * 4 + 3] = ((searched_traps[i] >> 24) & 255) as u8;\n    // }\n    std::hash::blake3(data)\n}\n\nfn serialize_chars(chars: [Character; MAX_CHARACTERS]) -> Field {\n    comptime {\n        assert(MAX_CHARACTERS <= 5);\n    }\n    let mut result: [u8; 32] = [0; 32];\n    for i in 0..MAX_CHARACTERS {\n        let serialized = chars[i].serialize();\n        for j in 0..6 {\n            result[2 + i * 6 + j] = serialized[j];\n        }\n    }\n    std::field::bytes32_to_field(result)\n}\n\nfn serialize_chars_as_obstacles(enemy_advance: u8, chars: [Character; MAX_CHARACTERS]) -> (bool, Field) {\n    let mut result: [u8; 32] = [0; 32];\n    let mut valid_result = true;\n    for i in 0..MAX_CHARACTERS {\n        if (chars[i].is_hidden == 0) & is_visible(enemy_advance, chars[i].get_x()) {\n            let (valid, char_as_obstacle) = chars[i].to_obstacle();\n            let serialized = serialize_obstacle(char_as_obstacle);\n            valid_result = valid_result & valid;\n            result[2 + i * 3] = serialized[0];\n            result[2 + i * 3 + 1] = serialized[1];\n            result[2 + i * 3 + 2] = serialized[2];\n        }\n    }\n    (valid_result, std::field::bytes32_to_field(result))\n}\n\nfn safe_subtract_dmg(a: u8, b: u16) -> u8 {\n    let mut result = 0;\n    if (a as u16) > b {\n        result = a - (b as u8);\n    }\n    result\n}\n\nfn test_result_object_builder(enemy_advance: u8, chars: [Character; MAX_CHARACTERS], obs: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE]) -> (bool, [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1]) {\n    let mut result: [Field; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1] = [0; SERIALIZED_OBSTACLES_ARRAY_SIZE + 1];\n    for i in 0..SERIALIZED_OBSTACLES_ARRAY_SIZE {\n        result[i] = obs[i];\n    }\n    let (valid, chars_as_obstacles) = serialize_chars_as_obstacles(enemy_advance, chars);\n    result[SERIALIZED_OBSTACLES_ARRAY_SIZE] = chars_as_obstacles;\n    (valid, result)\n}\n\n// fn test_helper_roster(actor: Character, mut chars: [Character; MAX_CHARACTERS]) -> [Character; MAX_CHARACTERS] {\n//     chars[actor.id] = actor;\n//     chars\n// }\n\n// fn test_helper_execute_move(move: u32, actor: Character, advances: [u8; 2], secret: [Field; 2], last_hashes: [Field; 2], chars: [[Character; MAX_CHARACTERS]; 2], obs: [[Obstacle; MAX_OBSTACLES]; 2], actions: [Action], my_events: [Event], their_events: [Event]) -> (u32, [Character; MAX_CHARACTERS], Field) {\n//     let side = move as u1;\n//     let other_side = (side as u8 + 1) as u1;\n//     let chars_after = test_helper_roster(actor, chars[side]);\n//     let my_obstacles_serialized = serialize_obstacles(advances[other_side], obs[side]);\n//     let secret_be_bytes: [u8; 32] = secret[side].to_be_bytes();\n//     assert(secret_be_bytes.len() == 32);\n//     let serialized_chars_after = serialize_chars(chars_after);\n//     let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes();\n//     assert(serialized_chars_after_be_bytes.len() == 32);\n//     let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, my_obstacles_serialized)); \n\n//     let (enemy_objects_valid, enemy_objects) = test_result_object_builder(chars[other_side], serialize_obstacles(other_side, advances[side], obs[other_side]));\n//     assert(enemy_objects_valid, \"Invalid enemy objects\");\n//     let (my_result_objects_valid, my_result_objects) = test_result_object_builder(chars_after, my_obstacles_serialized);\n//     assert(my_result_objects_valid, \"Invalid my result objects\");\n\n//     let result = turn(\n//         secret[side],\n//         character::serialize_chars(chars[side]),\n//         my_obstacles_serialized,\n//         serialize_actions(actions),\n//         move,\n//         advances[other_side],\n//         enemy_objects,\n//         Event::serialize_events(their_events).as_array(),\n//         advances[side],\n//         Event::serialize_events(my_events).as_array(),\n//         my_result_objects,\n//         last_hashes[side],\n//         current_hash\n//     );\n//     assert(result, \"Invalid result\");\n\n//     (move + 1, chars_after, current_hash)\n// }\n\n// #[test]\n// fn test_main() {\n//     let secrets = [123456789, 9876543210];\n//     let mut chars = [ character::get_default_characters(0), character::get_default_characters(1) ];\n//     let mut obs = [ Obstacle::get_default_obstacles(0), Obstacle::get_default_obstacles(1) ];\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 2, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 3, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 4, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 5, target_y: 1 },\n//     ];\n//     let their_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let mut move = 0;\n//     let mut actor = chars[0][0].move(5, 1);\n//     let mut last_hashes = [ 0x12b8f97907a05ec6a77da3f70368fa3b02e166c74edab8ea0695d6f406146559, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n//     let mut advances = [2 + VIEW_DISTANCE, 29 - VIEW_DISTANCE];\n//     advances[0] = 5 + VIEW_DISTANCE;\n\n//     let mut side = move % 2;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 0, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 1 },\n//         Action { action: MOVE, actor: 0, target_x: 28, target_y: 0 },\n//         Action { action: MOVE, actor: 0, target_x: 27, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(0); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(27, 0);\n//     advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 1, target_y: 3 },\n//         Action { action: MOVE, actor: 1, target_x: 0, target_y: 3 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(0, 3);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n\n//     side = move % 2;\n//     let actions = &[\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 2 },\n//         Action { action: MOVE, actor: 1, target_x: 29, target_y: 1 },\n//         Action { action: MOVE, actor: 1, target_x: 28, target_y: 1 },\n//         Action { action: WAIT, actor: 1, target_x: 0, target_y: 0 },\n//     ];\n//     let their_events = my_events;\n//     let my_events: [Event] = &[Event::empty(1); MAX_EVENTS];\n//     let actor = chars[side][((move as u64 / 2) % MAX_CHARACTERS)].move(28, 1);\n//     //advances[side] = 27 - VIEW_DISTANCE;\n//     let result = test_helper_execute_move(move, actor, advances, secrets, last_hashes, chars, obs, actions, my_events, their_events);\n//     move = result.0;\n//     chars[side] = result.1;\n//     last_hashes[side] = result.2;\n// }\n\n#[test]\nfn test_main_fireball_ff() {\n    let secrets = [123456789, 9876543210];\n    let mut chars = [\n        [\n            Character { id: 0, class: ARCHER, x: 9, y: 2, health: 100, status: 1, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 1, class: RITUALIST, x: 11, y: 3, health: 25, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 2, class: ROGUE, x: 12, y: 4, health: 20, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 3, class: KNIGHT, x: 10, y: 4, health: 100, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 4, class: MAGE, x: 10, y: 7, health: 100, status: MIN_FIREBALL_ROUNDS_FOR_CAST + 1, target_x: 11, target_y: 4, has_been_seen: true, is_hidden: 0, damage_mod: 10, last_action: 3, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n        ], [\n            Character { id: 0, class: MAGE, x: 13, y: 2, health: 100, status: 2, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 1, class: ROGUE, x: 14, y: 6, health: 0, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 1, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 2, class: RITUALIST, x: 16, y: 3, health: 20, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 3, class: ARCHER, x: 16, y: 6, health: 100, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT, actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n            Character { id: 4, class: KNIGHT, x: 11, y: 4, health: 30, status: 0, target_x: 0, target_y: 0, has_been_seen: true, is_hidden: 0, damage_mod: 0, last_action: WAIT,actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER] },\n        ]\n    ];\n// x, y & type, health\n// 0x091264 0b2300 0c3400 0a442d 095764 000000000000000000000000000000 // direct\n// 0x091264 0b2319 0c3414 0a4464 095764 000000000000000000000000000000 // turn\n    let mut obs = [ get_default_obstacles(0), get_default_obstacles(1) ];\n    let actions = &[\n        new_action(4, 4, 11, 4), //Action { action: CAST_FIREBALL, actor: 4, target_x: 11, target_y: 4 },\n        new_action(1, 4, 9, 7), //Action { action: MOVE, actor: 4, target_x: 9, target_y: 7 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n        new_action(WAIT, 4, 0, 0), //Action { action: WAIT, actor: 4, target_x: 0, target_y: 0 },\n    ];\n    let their_events: [Event] = &[\n        Event { event: RECEIVE_ATTACK, actor_id: 3, x: 20, y: 3, subtype: ATTACK_RANGED, value: 50, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 5, subtype: 0, value: 0, radius: 0 },\n        Event { event: SEE_MOVE, actor_id: 3, x: 16, y: 6, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 3, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    let my_events: [Event] = &[\n        Event { event: RECEIVE_ATTACK, actor_id: 4, x: 11, y: 4, subtype: ATTACK_FIREBALL, value: 0x78, radius: 1 },\n        Event { event: SEE_MOVE, actor_id: 4, x: 9, y: 7, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n        Event { event: NO_EVENT, actor_id: 4, x: 255, y: 255, subtype: 0, value: 0, radius: 0 },\n    ];\n    // event actor x y value subt rad\n    // 0x091264 0b2300 0c3400 0a4428 0b5464 000000000000000000000000000000\n    // 0x0a040b04780201 03040907000000 0004000000000000040000000000000000\n    // 0x0a040b04780201 03040907000000 0004ffff0000000004ffff000000000000\n    // 0x091264 0b2300 0c3400 0a4428 095764000000000000000000000000000000\n    let mut move = 8;\n    let mut actor = Character { //chars[0][4].move(9, 7).set_status(0);\n        id: chars[0][4].id,\n        class: chars[0][4].class,\n        x: get_action_target_x(actions[1]),\n        y: get_action_target_y(actions[1]),\n        target_x: get_action_target_x(actions[1]), // TODO\n        target_y: get_action_target_y(actions[1]),\n        has_been_seen: chars[0][4].has_been_seen,\n        is_hidden: 0 as u1,\n        health: chars[0][4].health,\n        damage_mod: chars[0][4].damage_mod,\n        last_action: get_action_type(actions[1]),\n        status: 0,\n        actions: [[0 as u8; 29]; MAX_ACTIONS_PER_CHARACTER]\n    };\n    //let mut last_hashes = [ 0x090a46a65d4c7c05f3c98b25c2639539d91c1542fd78e9c9c837f96de08c6a84, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut last_hashes = [ 0x118fec2c103f254f64c0bf927eaf0a2cab59e21e5e1d5121b2dd7ae234b25965, 0x2bca22f32b0b864574d0509ba146be256d2186fc490311756f541e1b5f8e391f ];\n    let mut advances = [12 + VIEW_DISTANCE, 18 + VIEW_DISTANCE];\n\n    let side = move as u1;\n    let other_side = (side as u8 + 1) as u1;\n    let chars_after = [ chars[side][0], chars[side][1].take_damage(ATTACK_RANGED, 50).take_damage(ATTACK_FIREBALL, 60), chars[side][2].take_damage(ATTACK_FIREBALL, 54), chars[side][3].take_damage(ATTACK_FIREBALL, 60), actor ];\n    let my_obstacles_serialized_for_enemy = serialize_my_obstacles(31 - advances[other_side], obs[side]);\n    let my_obstacles_serialized_for_me = serialize_my_obstacles_for_me(obs[side]);\n    let secret_be_bytes: [u8; 32] = secrets[side].to_be_bytes::<32>();\n    assert(secret_be_bytes.len() == 32);\n    let serialized_chars_after = serialize_chars(chars_after);\n    let serialized_chars_after_be_bytes: [u8; 32] = serialized_chars_after.to_be_bytes::<32>();\n    assert(serialized_chars_after_be_bytes.len() == 32);\n    let current_hash = std::field::bytes32_to_field(get_data_hash(secret_be_bytes, serialized_chars_after_be_bytes, get_test_action_register(), my_obstacles_serialized_for_me)); \n\n    // turn:  0x2912640000004b03000000006c04002000008a0428000000a9076400000a\n    // calc:  0x2912640000004b03000000006c04002000008a0428000000a907640b340a\n    let (test_result_object_chars_after_valid, test_result_object_chars_after) = test_result_object_builder(31 - advances[other_side], chars_after, my_obstacles_serialized_for_enemy);\n    let test_result_object_other_side_result = serialize_their_obstacles(31 - advances[side], obs[other_side]);\n    let test_result_object_other_side = test_result_object_other_side_result.1;\n    let (test_result_object_other_chars_valid, test_result_object_other_chars) = test_result_object_builder(31 - advances[side], chars[other_side], test_result_object_other_side);\n    println(\"Test-Inputs:\");\n    println(secrets[side]);\n    println(character::serialize_chars(chars[side]));\n    // println(get_test_action_register());\n    println(my_obstacles_serialized_for_me);\n    println(serialize_actions(actions));\n    println(move);\n    println(advances[other_side]);\n    println(test_result_object_other_chars);\n    println(Event::serialize_events(their_events));\n    println(advances[side]);\n    println(Event::serialize_events(my_events));\n    println(test_result_object_chars_after);\n    println(last_hashes[side]);\n    println(current_hash);\n    println(\"Test-Inputs done\");\n    assert(test_result_object_chars_after_valid, \"Invalid test result object chars after\");\n    assert(test_result_object_other_chars_valid, \"Invalid test result object other chars\");\n    let result = turn(\n        secrets[side],\n        character::serialize_chars(chars[side]),\n        // get_test_action_register(),\n        my_obstacles_serialized_for_me, //obs[side],\n        serialize_actions(actions),\n        move,\n        advances[other_side],\n        test_result_object_other_chars,\n        Event::serialize_events(their_events).as_array(),\n        advances[side],\n        Event::serialize_events(my_events).as_array(),\n        test_result_object_chars_after,\n        last_hashes[side],\n        current_hash\n    );\n    assert(result, \"Turn failed\");\n}\n\n\n#[export]\npub fn setup_obstacles(\n    \n)","path":"/home/andreas/git_repositories/heroes-of-penta/noir-react-native-starter-main/circuits/skpl/src/lib.nr"}},"names":["hash_match"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}